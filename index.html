<!DOCTYPE html>
<html lang="en">

<head>
	<meta name="generator" content="Hugo 0.67.1" />
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Filecoin Specification | Filecoin Spec</title>



<link rel="stylesheet" href="./book.min.cc8a7af7caa5a1f2d6cb09b76c451c38ff26f98a05f07f81e81723e47f8f3ef8.css">
<link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=EB+Garamond" />


<link rel="icon" href="./favicon.png" type="image/x-icon">


<link rel="alternate" type="application/rss+xml" href="./index.xml" title="Filecoin Spec" />

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript" src="./gumshoe.polyfills.min.js"></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  <link rel="stylesheet" href="./css/syntax.css">
<link href="./mermaid/mermaid.css" type="text/css" rel="stylesheet" />
<script src="./mermaid/mermaid.js"></script>
<script src="./spec.js"></script>

</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href=""><span>Filecoin Spec</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" placeholder="Search" id="book-search-input" maxlength="64" readonly />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    
  
  
  
    
    
  

  <style>
  nav ul a[href="\2f "] {
      color: #0b3a53;
  }
  </style>


  <div id="menu-toc">

  <div>
    
    <input id="menu-detail-slider" type="range" onchange="onMenuDetailChange();"
      min="1" value="3" max="5" step="1" />

    <span id="menu-detail-slider-label">3</span>
  </div>

  
  
  <ul class="menu-item-section depth-0">
  
      <li>
      
        











<a href="./#intro" class="menu-item depth-1">
    
    
    <strong>
    
        Introduction
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#intro__arch" class="menu-item depth-2">
    
    
        Architecture Diagrams
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__concepts" class="menu-item depth-2">
    
    
        Key Concepts
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__filecoin_vm" class="menu-item depth-2">
    
    
        Filecoin VM
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__process" class="menu-item depth-2">
    
    
        Process
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#intro__process__about" class="menu-item depth-3">
    
    
        About
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__process__fip" class="menu-item depth-3">
    
    
        FIPs
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__process__contributing" class="menu-item depth-3">
    
    
        Contributing
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__process__related_resources" class="menu-item depth-3">
    
    
        Related Resources
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#intro__process__related_resources__research_portal" class="menu-item depth-4">
    
    
        Research portal
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__process__related_resources__network_tooling" class="menu-item depth-4">
    
    
        Network tooling
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#intro__process__related_resources__testing" class="menu-item depth-4">
    
    
        Testing and implementation compliance
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__changelog" class="menu-item depth-2">
    
    
        Change Log
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__system" class="menu-item depth-2">
    
    
        System Decomposition
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#intro__system__why_systems" class="menu-item depth-3">
    
    
        What are Systems?
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#intro__system__impl_systems" class="menu-item depth-3">
    
    
        Implementing Systems
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#systems" class="menu-item depth-1">
    
    
    <strong>
    
        Systems
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#systems__filecoin_nodes" class="menu-item depth-2">
    ‚öôÔ∏è
    
        <strong>Filecoin Nodes</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types" class="menu-item depth-3">
    
    
        Node Types
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__node" class="menu-item depth-4">
    
    
        Node Interface
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__node_types" class="menu-item depth-4">
    
    
        Examples
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__verifier_node" class="menu-item depth-4">
    
    
        Chain Verifier Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__client_node" class="menu-item depth-4">
    
    
        Client Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__storage_miner_node" class="menu-item depth-4">
    
    
        Storage Miner Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__retrieval_miner_node" class="menu-item depth-4">
    
    
        Retrieval Miner Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__node_types__relayer_node" class="menu-item depth-4">
    
    
        Relayer Node
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_nodes__repository" class="menu-item depth-3">
    
    
        Repository
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_nodes__repository__config" class="menu-item depth-4">
    
    
        Config
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__repository__key_store" class="menu-item depth-4">
    
    
        Key Store
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_nodes__repository__ipldstore" class="menu-item depth-4">
    
    
        IpldStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__network" class="menu-item depth-3">
    
    
        Network Interface
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_nodes__clock" class="menu-item depth-3">
    
    
        Clock
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_files" class="menu-item depth-2">
    üìë
    
        <strong>Files &amp; Data</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#systems__filecoin_files__file" class="menu-item depth-3">
    
    
        File
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_files__file__filestore" class="menu-item depth-4">
    
    
        FileStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_files__piece" class="menu-item depth-3">
    
    
        Piece
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_files__piece__piece_store" class="menu-item depth-4">
    
    
        PieceStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_files__data_transfer" class="menu-item depth-3">
    
    
        Data Transfer
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_files__serialization" class="menu-item depth-3">
    
    
        Formats and Serialization
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm" class="menu-item depth-2">
    üíª
    
        <strong>Virtual Machine</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_vm__actor" class="menu-item depth-3">
    
    
        Actor
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__state_tree" class="menu-item depth-3">
    
    
        State Tree
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__indices" class="menu-item depth-3">
    
    
        Indices
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__message" class="menu-item depth-3">
    
    
        Message
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__runtime" class="menu-item depth-3">
    
    
        Runtime
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__runtime__gascost" class="menu-item depth-4">
    
    
        Gas Costs
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors" class="menu-item depth-3">
    
    
        System Actors
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors__init_actor" class="menu-item depth-4">
    
    
        InitActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors__cron_actor" class="menu-item depth-4">
    
    
        CronActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors__account_actor" class="menu-item depth-4">
    
    
        AccountActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_vm__sysactors__reward_actor" class="menu-item depth-4">
    
    
        RewardActor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_vm__interpreter" class="menu-item depth-3">
    
    
        Interpreter
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain" class="menu-item depth-2">
    üì¶
    
        <strong>Blockchain</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct" class="menu-item depth-3">
    
    
        Blocks
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__block" class="menu-item depth-4">
    
    
        Block
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__tipset" class="menu-item depth-4">
    
    
        Tipset
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__chain" class="menu-item depth-4">
    
    
        Chain
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__chain_manager" class="menu-item depth-4">
    
    
        Chain Manager
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__struct__block_producer" class="menu-item depth-4">
    
    
        Block Producer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__message_pool" class="menu-item depth-3">
    
    
        Message Pool
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__message_pool__message_syncer" class="menu-item depth-4">
    
    
        Message Syncer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__message_pool__message_storage" class="menu-item depth-4">
    
    
        Message Storage
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_blockchain__chainsync" class="menu-item depth-3">
    
    
        ChainSync
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_blockchain__storage_power_consensus" class="menu-item depth-3">
    
    
        Storage Power Consensus
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor" class="menu-item depth-4">
    
    
        Storage Power Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_token" class="menu-item depth-2">
    üìÄ
    
        <strong>Token</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_token__wallets" class="menu-item depth-3">
    
    
        Wallet
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_token__payment_channels" class="menu-item depth-3">
    
    
        Payment Channels
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_token__payment_channels__payment_channel_actor" class="menu-item depth-4">
    
    
        Payment Channel Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_token__multisig" class="menu-item depth-3">
    
    
        Multisig Wallet
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_token__multisig__multisig_actor" class="menu-item depth-4">
    
    
        Multisig Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_mining" class="menu-item depth-2">
    ‚õè
    
        <strong>Storage Mining</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_mining__storage_mining" class="menu-item depth-3">
    
    
        Storage Miner
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_mining__mining_cycle" class="menu-item depth-4">
    
    
        Storage Mining Cycle
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor" class="menu-item depth-4">
    
    
        Storage Miner Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector" class="menu-item depth-3">
    
    
        Sector
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_mining__sector__sectorset" class="menu-item depth-4">
    
    
        Sector Set
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector__posting" class="menu-item depth-4">
    
    
        Sector PoSting
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector__sealing" class="menu-item depth-4">
    
    
        Sector Sealing
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector_index" class="menu-item depth-3">
    
    
        Sector Index
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
    </li>

    <li>
    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector_index__sector_builder" class="menu-item depth-4">
    
    
        Sector Builder
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__sector_index__sector_store" class="menu-item depth-4">
    
    
        SectorStore
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_mining__storage_proving" class="menu-item depth-3">
    
    
        Storage Proving
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_mining__storage_proving__sealer" class="menu-item depth-4">
    
    
        Sector Sealer
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_mining__storage_proving__poster" class="menu-item depth-4">
    
    
        Sector Poster
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets" class="menu-item depth-2">
    ‚öñÔ∏è
    
        <strong>Market</strong>
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#systems__filecoin_markets__storage_market" class="menu-item depth-3">
    
    
        Storage Market
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      










  


<a href="./#systems__filecoin_markets__storage_market__storage_deal" class="menu-item depth-4">
    
    
        Storage Deal
    
</a>



<ul class="menu-item-section depth-4">

    <li>
    
      










  


<a href="./#systems__filecoin_markets__storage_market__storage_deal__storage_deal_flow" class="menu-item depth-5">
    
    
        Deal Flow
    
</a>



<ul class="menu-item-section depth-5">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets__storage_market__storage_deal__storage_deal_states" class="menu-item depth-5">
    
    
        Deal States
    
</a>



<ul class="menu-item-section depth-5">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__storage_deal__faults" class="menu-item depth-5">
    
    
        Faults
    
</a>



<ul class="menu-item-section depth-5">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__storage_market_actor" class="menu-item depth-4">
    
    
        Storage Market Actor
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__storage_provider" class="menu-item depth-4">
    
    
        Storage Provider
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__storage_market__storage_client" class="menu-item depth-4">
    
    
        Storage Client
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#systems__filecoin_markets__retrieval_market" class="menu-item depth-3">
    
    
        Retrieval Market
    
</a>



<ul class="menu-item-section depth-3">

    <li>
    
      











<a href="./#systems__filecoin_markets__retrieval_market__retrieval_peer_resolver" class="menu-item depth-4">
    
    
        Retrieval Peer Resolver
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__retrieval_market__retrieval_protocols" class="menu-item depth-4">
    
    
        Retrieval Protocols
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__retrieval_market__retrieval_client" class="menu-item depth-4">
    
    
        Retrieval Client
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

    <li>
    
      











<a href="./#systems__filecoin_markets__retrieval_market__retrieval_provider" class="menu-item depth-4">
    
    
        Retrieval Provider (Miner)
    
</a>



<ul class="menu-item-section depth-4">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        










  


<a href="./#libraries" class="menu-item depth-1">
    
    
    <strong>
    
        Libraries
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      










  


<a href="./#libraries__filcrypto" class="menu-item depth-2">
    
    
        Filcrypto
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#libraries__filcrypto__filproofs" class="menu-item depth-3">
    
    
        filproofs
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__fcs" class="menu-item depth-2">
    
    
        FCS
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__ipld" class="menu-item depth-2">
    
    
        IPLD
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#libraries__ipld__cid" class="menu-item depth-3">
    
    
        CID
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__ipld__datamodel" class="menu-item depth-3">
    
    
        Data Model
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__ipld__selectors" class="menu-item depth-3">
    
    
        Selectors
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__libp2p" class="menu-item depth-2">
    
    
        libp2p
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      










  


<a href="./#libraries__libp2p__gossipsub" class="menu-item depth-3">
    
    
        gossipsub
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__libp2p__kad_dht" class="menu-item depth-3">
    
    
        kad-dht
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__libp2p__fil_libp2p_nodes" class="menu-item depth-3">
    
    
        fil-libp2p Nodes
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__ipfs" class="menu-item depth-2">
    
    
        IPFS
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#libraries__ipfs__bitswap" class="menu-item depth-3">
    
    
        BitSwap
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__ipfs__graphsync" class="menu-item depth-3">
    
    
        GraphSync
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#libraries__ipfs__unixfs" class="menu-item depth-3">
    
    
        UnixFS
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      










  


<a href="./#libraries__multiformats" class="menu-item depth-2">
    
    
        Multiformats
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#algorithms" class="menu-item depth-1">
    
    
    <strong>
    
        Algorithms
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#algorithms__expected_consensus" class="menu-item depth-2">
    
    
        Expected Consensus
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__porep" class="menu-item depth-2">
    
    
        Proof-of-Replication
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#algorithms__porep__stacked_drg" class="menu-item depth-3">
    
    
        Stacked DRG PoRep
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__porep__porep_commitments" class="menu-item depth-3">
    
    
        PoRep Commitments
    
</a>




    
    </li>

    <li>
    
      











<a href="./#algorithms__porep__stacked_drg_circuit" class="menu-item depth-3">
    
    
        Stacked DRG - Offline PoRep Circuit Spec
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__post" class="menu-item depth-2">
    
    
        Proof-of-Spacetime
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#algorithms__post__election_post" class="menu-item depth-3">
    
    
        Election PoSt
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__post__proof_of_spacetime_parameters" class="menu-item depth-3">
    
    
        PoSt Parameters
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__payment_channels" class="menu-item depth-2">
    
    
        Payment Channels
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__block_sync" class="menu-item depth-2">
    
    
        BlockSync
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__gossip_sub" class="menu-item depth-2">
    
    
        GossipSub
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#algorithms__crypto" class="menu-item depth-2">
    
    
        Cryptographic Primitives
    
</a>




    
    </li>

    <li>
    
      










  


<a href="./#algorithms__cryptoecon" class="menu-item depth-2">
    
    
        Cryptoecon
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#listings" class="menu-item depth-1">
    
    
    <strong>
    
        Listings
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#listings__actors" class="menu-item depth-2">
    
    
        Filecoin VM Actors
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__reserved_ranges" class="menu-item depth-2">
    
    
        Reserved Ranges
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__data_structures" class="menu-item depth-2">
    
    
        Data Structures
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__system_map" class="menu-item depth-2">
    
    
        Components
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#listings__libp2p_protocols" class="menu-item depth-2">
    
    
        libp2p Protocols
    
</a>



<ul class="menu-item-section depth-2">

    <li>
    
      











<a href="./#listings__libp2p_protocols__data_transfer_protocol" class="menu-item depth-3">
    
    
        Data Transfer Protocol
    
</a>



<ul class="menu-item-section depth-3">

</ul>


    
    </li>

</ul>


    
    </li>

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#glossary" class="menu-item depth-1">
    
    
    <strong>
    
        Glossary
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

</ul>


      
      </li>
  
      <li>
      
        











<a href="./#appendix" class="menu-item depth-1">
    
    
    <strong>
    
        Appendix
    
    </strong>
    
</a>



<ul class="menu-item-section depth-1">

    <li>
    
      











<a href="./#appendix__sharray" class="menu-item depth-2">
    
    
        Sharded IPLD Array
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#appendix__address" class="menu-item depth-2">
    
    
        Address
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

    <li>
    
      











<a href="./#appendix__network_params" class="menu-item depth-2">
    
    
        Filecoin Parameters
    
</a>



<ul class="menu-item-section depth-2">

</ul>


    
    </li>

</ul>


      
      </li>
  
  </ul>
  
</div>










</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="./svg/menu.svg" alt="Menu" />
  </label>
  <strong>Filecoin Specification</strong>
</header>

      
<article class="markdown"><script>
  structSet = new Set([
    "Actor",
    "Address",
    "Bitfield",
    "Block",
    "BytesAmount",
    "ElectionProof",
    "FaultSet",
    "Message",
    "MessageReceipt",
    "PeerId",
    "PoSTProof",
    "PublicKey",
    "SealProof",
    "SectorID",
    "SectorSet",
    "Signature",
    "SignedMessage",
    "StateTree",
    "Ticket",
    "TipSet",
    "TokenAmount",
    "UnsignedMessage",
  ]);

  structRefs = {
    "AddressId":               "Address",
    "AddressSecp256k1":        "Address",
    "AddressActor":            "Address",
    "AddressBLS12_381":        "Address",
    "Bls12_381Signature":      "Signature",
    "Secp256k1Signature":      "Signature",
    "TxMeta":                  "Block",
    "VDFProof":                "Ticket",
    "VDFResult":               "Ticket",
    "VRFProof":                "Ticket",
  };

  fillSingleCodeRef = (x, isTokenDef) => {
    let origKey = x.textContent;
    let key = origKey;
    let newKey = structRefs[key];
    if (newKey !== undefined) {
      key = newKey;
    }
    if (structSet.has(key)) {
      if (x.className == "nx" && isTokenDef) {
        x.innerHTML = "<span id=go__" + origKey + "><a class=codeLink href=\"/#go__" + origKey + "\">" + x.innerHTML + "</a></div>";
      } else {
        x.innerHTML = "<a class=codeLink href=\"/#go__" + origKey + "\">" + x.innerHTML + "</a>";
      }
    }
  };

  fillCodeRefs = (xs, parent) => {
    if (xs.length == 0 && parent.textContent.length != 0) {
      fillSingleCodeRef(parent);
      return;
    }

    let isTokenDef = false;

    for (let x of xs) {
      if (x.className == "kd" && x.innerHTML == "type") {
        isTokenDef = true;
        continue;
      }

      if (x.className != "nx" && x.className != "codeRef") {
        isTokenDef = false;
        continue;
      }

      fillSingleCodeRef(x, isTokenDef);
      isTokenDef = false;
    }
  };

  window.onload = (event) => {
    let codeBlocks = document.getElementsByTagName("code");
    for (let codeBlock of codeBlocks) {
      fillCodeRefs(codeBlock.children, codeBlock);
    }

    let hashPrev = location.hash;
    if ((typeof hashPrev) == "string" && hashPrev != "") {
      location.hash = "";
      location.hash = hashPrev;
    }
  };
</script>

<div>
  
  








<div id="">

<h0 class="section-header">
  
</h0>

<div class="section-content">




































<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->


</div>


  
    








<div id="intro">

<h1 class="section-header">
  Introduction
</h1>

<div class="section-content">




































<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Filecoin is a distributed storage network based on a blockchain mechanism.
Filecoin <em>miners</em> can elect to provide storage capacity for the network, and thereby
earn units of the Filecoin cryptocurrency (FIL) by periodically producing
cryptographic proofs that certify that they are providing the capacity specified.
In addition, Filecoin enables parties to exchange FIL currency
through transactions recorded in a shared ledger on the Filecoin blockchain.
Rather than using Nakamoto-style proof of work to maintain consensus on the chain, however,
Filecoin uses proof of storage itself: a miner&rsquo;s power in the consensus protocol
is proportional to the amount of storage it provides.</p>
<p>The Filecoin blockchain not only maintains the ledger for FIL transactions and
accounts, but also implements the Filecoin VM, a replicated state machine which executes
a variety of cryptographic contracts and market mechanisms among participants
on the network.
These contracts include <em>storage deals</em>, in which clients pay FIL currency to miners
in exchange for storing the specific file data that the clients request.
Via the distributed implementation of the Filecoin VM, storage deals
and other contract mechanisms recorded on the chain continue to be processed
over time, without requiring further interaction from the original parties
(such as the clients who requested the data storage).</p>


</div>


  
    








<div id="intro__arch">

<h2 class="section-header">
  Architecture Diagrams
</h2>

<div class="section-content">




































<h3 id="filecoin-systems">Filecoin Systems</h3>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Status Legend:</p>
<ul>
<li>üõë <strong>Bare</strong> - Very incomplete at this time.
<ul>
<li><strong>Implementors:</strong> This is far from ready for you.</li>
</ul>
</li>
<li>‚ö†Ô∏è <strong>Rough</strong> &ndash; work in progress, heavy changes coming, as we put in place key functionality.
<ul>
<li><strong>Implementors:</strong> This will be ready for you soon.</li>
</ul>
</li>
<li>üîÅ <strong>Refining</strong> - Key functionality is there, some small things expected to change. Some big things may change.
<ul>
<li><strong>Implementors:</strong> Almost ready for you. You can start building these parts, but beware there may be changes still.</li>
</ul>
</li>
<li>‚úÖ <strong>Stable</strong> - Mostly complete, minor things expected to change, no major changes expected.
<ul>
<li><strong>Implementors:</strong> Ready for you. You can build these parts.</li>
</ul>
</li>
</ul>
<p><em>Note that the status relates to the state of the spec either written out either in english or in code. The goal is for the spec to eventually be fleshed out in both language-sets.</em></p>
<p>[<!-- raw HTML omitted -->Show<!-- raw HTML omitted --> / <!-- raw HTML omitted -->Hide<!-- raw HTML omitted --> ] status indicators</p>

<div class="tocMap colorful">


  
  
    















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems">
        

        Systems

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes">
        

        <strong>Filecoin Nodes</strong>

        
            <br /><br /><i class="menuIcon">‚öôÔ∏è</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__node_types">
        
            <i class="statusIcon">‚úÖ</i>
        

        Node Types

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__repository">
        
            <i class="statusIcon">‚úÖ</i>
        

        Repository

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__network">
        
            <i class="statusIcon">üîÅ</i>
        

        Network Interface

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_nodes__clock">
        
            <i class="statusIcon">‚úÖ</i>
        

        Clock

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files">
        

        <strong>Files &amp; Data</strong>

        
            <br /><br /><i class="menuIcon">üìë</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__file">
        
            <i class="statusIcon">‚úÖ</i>
        

        File

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__piece">
        
            <i class="statusIcon">‚úÖ</i>
        

        Piece

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__data_transfer">
        
            <i class="statusIcon">‚úÖ</i>
        

        Data Transfer

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__serialization">
        
            <i class="statusIcon">üîÅ</i>
        

        Formats and Serialization

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm">
        

        <strong>Virtual Machine</strong>

        
            <br /><br /><i class="menuIcon">üíª</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__actor">
        
            <i class="statusIcon">‚úÖ</i>
        

        Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__state_tree">
        
            <i class="statusIcon">üîÅ</i>
        

        State Tree

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__indices">
        
            <i class="statusIcon">‚ö†Ô∏è</i>
        

        Indices

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__message">
        
            <i class="statusIcon">‚úÖ</i>
        

        Message

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime">
        
            <i class="statusIcon">üîÅ</i>
        

        Runtime

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors">
        
            <i class="statusIcon">üîÅ</i>
        

        System Actors

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__interpreter">
        
            <i class="statusIcon">üîÅ</i>
        

        Interpreter

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain">
        

        <strong>Blockchain</strong>

        
            <br /><br /><i class="menuIcon">üì¶</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct">
        
            <i class="statusIcon">‚úÖ</i>
        

        Blocks

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool">
        
            <i class="statusIcon">üõë</i>
        

        Message Pool

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__chainsync">
        
            <i class="statusIcon">‚úÖ</i>
        

        ChainSync

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__storage_power_consensus">
        
            <i class="statusIcon">‚úÖ</i>
        

        Storage Power Consensus

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token">
        

        <strong>Token</strong>

        
            <br /><br /><i class="menuIcon">üìÄ</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__wallets">
        
            <i class="statusIcon">üõë</i>
        

        Wallet

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payment_channels">
        
            <i class="statusIcon">üîÅ</i>
        

        Payment Channels

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__multisig">
        
            <i class="statusIcon">‚úÖ</i>
        

        Multisig Wallet

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining">
        

        <strong>Storage Mining</strong>

        
            <br /><br /><i class="menuIcon">‚õè</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining">
        
            <i class="statusIcon">üîÅ</i>
        

        Storage Miner

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector">
        
            <i class="statusIcon">üîÅ</i>
        

        Sector

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index">
        
            <i class="statusIcon">‚úÖ</i>
        

        Sector Index

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving">
        
            <i class="statusIcon">‚úÖ</i>
        

        Storage Proving

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets">
        

        <strong>Market</strong>

        
            <br /><br /><i class="menuIcon">‚öñÔ∏è</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market">
        
            <i class="statusIcon">‚úÖ</i>
        

        Storage Market

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market">
        
            <i class="statusIcon">‚úÖ</i>
        

        Retrieval Market

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>

<h3 id="overview-diagram">Overview Diagram</h3>
<p>TODO:</p>
<ul>
<li>cleanup / reorganize
<ul>
<li>this diagram is accurate, and helps lots to navigate, but it&rsquo;s still a bit confusing</li>
<li>the arrows and lines make it a bit hard to follow. We should have a much cleaner version (maybe based on <a href="https://c4model.com">C4</a>)</li>
</ul>
</li>
<li>reflect addition of Token system
<ul>
<li>move data_transfers into Token</li>
</ul>
</li>
</ul>












<div class="diagram">

<span class="diagram-title">Protocol Overview Diagram</span>




(<a href="docs/intro/../diagrams/overview1/overview.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/overview1/overview.dot.svg" />




</div>

<h3 id="protocol-flow-diagram----deals-on-chain">Protocol Flow Diagram &ndash; deals on chain</h3>












<div class="diagram">

<span class="diagram-title">Protocol Sequence Diagram - Deals on Chain</span>




(<a href="docs/intro/../diagrams/sequence/full-deals-on-chain.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/sequence/full-deals-on-chain.mmd.svg" />




</div>

<h3 id="parameter-calculation-dependency-graph">Parameter Calculation Dependency Graph</h3>
<p>This is a diagram of the model for parameter calculation. This is made with <a href="https://github.com/filecoin-project/orient">orient</a>, our tool for modeling and solving for constraints.</p>












<div class="diagram">

<span class="diagram-title">Parameter Calculation Dependency Graph</span>




(<a href="docs/intro/../diagrams/orient/filecoin.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/intro/../diagrams/orient/filecoin.dot.svg" />




</div>



</div>



</div>

  

  
    








<div id="intro__concepts">

<h2 class="section-header">
  Key Concepts
</h2>

<div class="section-content">




































<p>For clarity, we refer the following types of entities to describe implementations of the Filecoin protocol:</p>
<ul>
<li>
<p><strong><em>Data structures</em></strong> are collections of semantically-tagged data members (e.g., structs, interfaces, or enums).</p>
</li>
<li>
<p><strong><em>Functions</em></strong> are computational procedures that do not depend on external state (i.e., mathematical functions,
or programming language functions that do not refer to global variables).</p>
</li>
<li>
<p><strong><em>Components</em></strong> are sets of functionality that are intended to be represented as single software units
in the implementation structure.
Depending on the choice of language and the particular component, this might
correspond to a single software module,
a thread or process running some main loop, a disk-backed database, or a variety of other design choices.
For example, the <a href="./#systems__filecoin_blockchain__chainsync">ChainSync - synchronizing the Blockchain</a> is a component: it could be implemented
as a process or thread running a single specified main loop, which waits for network messages
and responds accordingly by recording and/or forwarding block data.</p>
</li>
<li>
<p><strong><em>APIs</em></strong> are messages that can be sent to components.
A client&rsquo;s view of a given sub-protocol, such as a request to a miner node&rsquo;s
<a href="./#systems__filecoin_markets__storage_market__storage_provider">Storage Provider</a> component to store files in the storage market,
may require the execution of a series of APIs.</p>
</li>
<li>
<p><strong><em>Nodes</em></strong> are complete software and hardware systems that interact with the protocol.
A node might be constantly running several of the above <em>components</em>, participating in several <em>subsystems</em>,
and exposing <em>APIs</em> locally and/or over the network,
depending on the node configuration.
The term <em>full node</em> refers to a system that runs all of the above components, and supports all of the APIs detailed in the spec.</p>
</li>
<li>
<p><strong><em>Subsystems</em></strong> are conceptual divisions of the entire Filecoin protocol, either in terms of complete protocols
(such as the <a href="./#systems__filecoin_markets__storage_market___index">Storage Market</a> or <a href="./#systems__filecoin_markets__retrieval_market___index">Retrieval Market</a>), or in terms of functionality
(such as the <a href="./#systems__filecoin_vm">VM - Virtual Machine</a>). They do not necessarily correspond to any particular node or software component.</p>
</li>
<li>
<p><strong><em>Actors</em></strong> are virtual entities embodied in the state of the Filecoin VM.
Protocol actors are analogous to participants in smart contracts;
an actor carries a FIL currency balance and can interact with other actors
via the operations of the VM, but does not necessarily correspond to any particular node or software component.</p>
</li>
</ul>


</div>



</div>

  

  
    








<div id="intro__filecoin_vm">

<h2 class="section-header">
  Filecoin VM
</h2>

<div class="section-content">




































<p>The majority of Filecoin&rsquo;s user facing functionality (payments, storage market, power table, etc) is managed through the Filecoin Virtual Machine (Filecoin VM). The network generates a series of blocks, and agrees which &lsquo;chain&rsquo; of blocks is the correct one. Each block contains a series of state transitions called <code>messages</code>, and a checkpoint of the current <code>global state</code> after the application of those <code>messages</code>.</p>
<p>The <code>global state</code> here consists of a set of <code>actors</code>, each with their own private <code>state</code>.</p>
<p>An <code>actor</code> is the Filecoin equivalent of Ethereum&rsquo;s smart contracts, it is essentially an &lsquo;object&rsquo; in the filecoin network with state and a set of methods that can be used to interact with it. Every actor has a Filecoin balance attributed to it, a <code>state</code> pointer, a <code>code</code> CID which tells the system what type of actor it is, and a <code>nonce</code> which tracks the number of messages sent by this actor. (TODO: the nonce is really only needed for external user interface actors, AKA <code>account actors</code>. Maybe we should find a way to clean that up?)</p>
<p>There are two routes to calling a method on an <code>actor</code>. First, to call a method as an external participant of the system (aka, a normal user with Filecoin) you must send a signed <code>message</code> to the network, and pay a fee to the miner that includes your <code>message</code>.  The signature on the message must match the key associated with an account with sufficient Filecoin to pay for the messages execution. The fee here is equivalent to transaction fees in Bitcoin and Ethereum, where it is proportional to the work that is done to process the message (Bitcoin prices messages per byte, Ethereum uses the concept of &lsquo;gas&rsquo;. We also use &lsquo;gas&rsquo;).</p>
<p>Second, an <code>actor</code> may call a method on another actor during the invocation of one of its methods.  However, the only time this may happen is as a result of some actor being invoked by an external users message (note: an actor called by a user may call another actor that then calls another actor, as many layers deep as the execution can afford to run for).</p>
<p>For full implementation details, see the <a href="./#systems__filecoin_vm">VM subsystem</a>.</p>


</div>



</div>

  

  
    








<div id="intro__process">

<h2 class="section-header">
  Filecoin Spec Process (v1)
</h2>

<div class="section-content">




































<h3 id="-pre-launch-mode">üöÄ Pre-launch mode</h3>
<p>Until we launch, we are making lots of changes to the spec to finish documenting the current version of the protocol. Changes will be made to the spec by a simple PR process, with approvals by key stakeholders. Some refinements are still to happen and testnet is expected to bring a few significant fixes/improvements. Most changes now are changing <em>the document</em>, <strong>NOT</strong> changing <em>the protocol</em>, at least not in a major way.</p>
<p>Until we launch, if something is missing, PR it in. If something is wrong, PR a fix. If something needs to be elaborated, PR in updates. What is in the top level of this repo, in master, is the spec, is the Filecoin Protocol. Nothing else matters (ie. no other documents, issues contain &ldquo;the protocol&rdquo;).</p>
<h3 id="new-proposals---drafts---spec">New Proposals -&gt; Drafts -&gt; Spec</h3>
<!-- raw HTML omitted -->
<p>For anything that is not part of the currently speced systems (like &lsquo;repair&rsquo;, for example) the process we will use is:</p>
<ul>
<li><strong>(1) First, discuss the problem(s) and solution(s) in an issue</strong>
<ul>
<li>Or several issues, if the space is large and multithreaded enough.</li>
<li>Work out all the details required to make this proposal work.</li>
</ul>
</li>
<li><strong>(2) Write a draft with all the details.</strong>
<ul>
<li>When you feel like a solution is near, write up a draft document that contains all the details, and includes what changes would need to happen to the spec</li>
<li>E.g. &ldquo;Add a System called X with &hellip;&quot;, or &ldquo;Add a library called Y, &hellip;&quot;, or &ldquo;Modify vm/state_tree to include &hellip;&rdquo;</li>
<li>Place this document inside the <code>src/drafts/</code> directory.</li>
<li>Anybody is welcome to contribute well-reasoned and detailed drafts.</li>
<li>(Note: these drafts will give way to FIPs in the future)</li>
</ul>
</li>
<li><strong>(3) Seek approval to merge this into the specification.</strong>
<ul>
<li>To seek approval, open an issue and discuss it.</li>
<li>If the draft approved by the owners of the filecoin-spec, then the changes to the spec will need to be made in a PR.</li>
<li>Once changes make it into the spec, remove the draft.</li>
</ul>
</li>
</ul>
<p>It is acceptable for a PR for a draft to stay open for quite a while, as thought and discussion on the topic happens. At some point, if the reviewers and the author feel that the current state of the draft is stable enough (though not &lsquo;done&rsquo;) then it should be merged into the repo. Further changes to the draft are additional PRs, which may generate more discussion. Comments on these drafts are welcome from anyone, but if you wish to be involved in the actual research process, you will need to devote very considerable time and energy to the process.</p>
<h3 id="on-merging">On merging</h3>
<p>For anything in the drafts or notes folder, merge yourself after a review from a relevant person. For anything in the top level (canonical spec), @zixuanzh, @anorth, @whyrusleeping or @jbenet will merge after proper review.</p>
<h3 id="issues">Issues</h3>
<p>Issues in the specs repo will be high signal. They will either be proposals, or issues directly relating to problems in the spec. More speculative research questions and discussion will happen in the research repo.</p>


</div>


  
    








<div id="intro__process__about">

<h3 class="section-header">
  About this specification
</h3>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__fip">

<h3 class="section-header">
  FIPs - Filecoin Improvement Proposals
</h3>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__contributing">

<h3 class="section-header">
  Contributing to the Filecoin spec
</h3>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__related_resources">

<h3 class="section-header">
  Related Resources
</h3>

<div class="section-content">




































<p>TODO</p>


</div>


  
    








<div id="intro__process__related_resources__research_portal">

<h4 class="section-header">
  Research portal
</h4>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__related_resources__network_tooling">

<h4 class="section-header">
  Network tooling
</h4>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="intro__process__related_resources__testing">

<h4 class="section-header">
  Testing and implementation compliance
</h4>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="intro__changelog">

<h2 class="section-header">
  Change Log - Version History
</h2>

<div class="section-content">




































<h3 id="v11---2019-10-30---c3f6a6dd">v1.1 - 2019-10-30 - <code>c3f6a6dd</code></h3>
<ul>
<li><strong>Deals on chain</strong>
<ul>
<li>Storage Deals</li>
<li>Full <code>StorageMarketActor</code> logic:
<ul>
<li>client and miner balances: deposits, locking, charges, and withdrawls</li>
<li>collateral slashing</li>
</ul>
</li>
<li>Full <code>StorageMinerActor</code> logic:
<ul>
<li>sector states, state transitions, state accounting, power accounting</li>
<li>DeclareFaults + RecoverSectors flow</li>
<li><code>CommitSector</code> flow</li>
<li><code>SubmitElectionPost</code> or <code>SubmitSurprisePoSt</code> flow
<ul>
<li>Sector proving, faults, recovery, and expiry</li>
</ul>
</li>
<li><code>OnMissedSurprisePost</code> flow
<ul>
<li>Fault sectors, drop power, expiry, and more</li>
</ul>
</li>
</ul>
</li>
<li><code>StoragePowerActor</code>
<ul>
<li>power accounting based on <code>StorageMinerActor</code> state changes</li>
<li>Collaterals: deposit, locking, withdrawal</li>
<li>Slashing collaerals</li>
</ul>
</li>
<li>Interactive-Post
<ul>
<li><code>StorageMinerActor</code>: <code>PrecommitSector</code> and <code>CommitSector</code></li>
</ul>
</li>
<li>Surprise-Post
<ul>
<li>Challenge flow through <code>CronActor -&gt; StoragePowerActor -&gt; StorageMiner</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Virtual Machine</strong>
<ul>
<li>Extracted VM system out of blockchain</li>
<li>Addresses</li>
<li>Actors
<ul>
<li>Separation of code and state</li>
</ul>
</li>
<li>Messages
<ul>
<li>Method invocation representation</li>
</ul>
</li>
<li>Runtime
<ul>
<li>Slimmed down interface</li>
<li>Safer state Acquire, Release, Commit flow</li>
<li>Exit codes</li>
<li>Full invocation flow</li>
<li>Safer recursive context construction</li>
<li>Error levels and handling</li>
<li>Detecting and handling out of gas errors</li>
</ul>
</li>
<li>Interpreter
<ul>
<li><code>ApplyMessage</code></li>
<li><code>{Deduct,Deposit} -&gt; Transfer</code> - safer</li>
<li>Gas accounting</li>
</ul>
</li>
<li>VM system actors
<ul>
<li><code>InitActor</code> basic flow, plug into Runtime</li>
<li><code>CronActor</code> full flow, static registry</li>
</ul>
</li>
<li><code>AccountActor</code> basic flow</li>
</ul>
</li>
<li><strong>Data Transfer</strong>
<ul>
<li>Full Data Transfer flows
<ul>
<li>push, pull, 1-RTT pull</li>
</ul>
</li>
<li>protocol, data structures, interface</li>
<li>diagrams</li>
</ul>
</li>
<li><strong>blockchain/ChainSync:</strong>
<ul>
<li>first version of ChainSync protocol description</li>
<li>Includes protocol state machine description</li>
<li>Network bootstrap &ndash; connectivity and state</li>
<li>Progressive Block Validation</li>
<li>Progressive Block Propagation</li>
</ul>
</li>
<li><strong>Other</strong>
<ul>
<li>Spec section status indicators</li>
<li>Changelog</li>
</ul>
</li>
</ul>
<h3 id="v10---2019-10-07---583b1d06">v1.0 - 2019-10-07 - <code>583b1d06</code></h3>
<ul>
<li><strong>Full spec reorganization</strong></li>
<li><strong>Tooling</strong>
<ul>
<li>added a build system to compile tools</li>
<li>added diagraming tools (dot, mermaid, etc)</li>
<li>added dependency installation</li>
<li>added Orient to calculate protocol parameters</li>
</ul>
</li>
<li><strong>Content</strong>
<ul>
<li><strong>filecoin_nodes</strong>
<ul>
<li>types - an overview of different filecoin node types</li>
<li>repository - local data-structure storage</li>
<li>network interface - connecting to libp2p</li>
<li>clock - a wall clock</li>
</ul>
</li>
<li><strong>files &amp; data</strong>
<ul>
<li>file - basic representation of data</li>
<li>piece - representation of data to store in filecoin</li>
</ul>
</li>
<li><strong>blockchain</strong>
<ul>
<li>blocks - basic blockchain data structures (block, tipset, chain, etc)</li>
<li>storage power consensus - basic algorithms and crypto artifacts for SPC</li>
<li><code>StoragePowerActor</code> basics</li>
</ul>
</li>
<li><strong>token</strong>
<ul>
<li>skeleton of sections</li>
</ul>
</li>
<li><strong>storage mining</strong>
<ul>
<li>storage miner: module that controls and coordinates storage mining</li>
<li>sector: unit of storage, sealing, crypto artifacts, etc.</li>
<li>sector index: accounting sectors and metadata</li>
<li>storage proving: seals, posts, and more</li>
</ul>
</li>
<li><strong>market</strong>
<ul>
<li>deals: storage market deal basics</li>
<li>storage market: <code>StorageMarketActor</code> basics</li>
</ul>
</li>
<li><strong>orient</strong>
<ul>
<li>orient models for proofs and block sizes</li>
</ul>
</li>
<li><strong>libraries</strong>
<ul>
<li>filcrypto - sealing, PoRep, PoSt algorithms</li>
<li>ipld - cids, ipldstores</li>
<li>libp2p - host/node representation</li>
<li>ipfs - graphsync and bitswap</li>
<li>multiformats - multihash, multiaddr</li>
</ul>
</li>
<li><strong>diagrams</strong>
<ul>
<li>system overview</li>
<li>full protocol mermaid flow</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="pre-v10">pre v1.0</h3>
<ul>
<li>Extensive write up of the filecoin protocol - visible <a href="https://github.com/filecoin-project/specs/tree/prevspec">here</a></li>
<li>See full changelog: <a href="https://github.com/filecoin-project/specs/commits/prevspec">https://github.com/filecoin-project/specs/commits/prevspec</a></li>
</ul>


</div>



</div>

  

  
    








<div id="intro__system">

<h2 class="section-header">
  System Decomposition
</h2>

<div class="section-content">






































</div>


  
    








<div id="intro__system__why_systems">

<h3 class="section-header">
  What are Systems? How do they work?
</h3>

<div class="section-content">




































<p>Filecoin decouples and modularizes functionality into loosely-joined <code>systems</code>.
Each system adds significant functionality, usually to achieve a set of important and tightly related goals.</p>
<p>For example, the Blockchain System provides structures like Block, Tipset, and Chain, and provides functionality
like Block Sync, Block Propagation, Block Validation, Chain Selection, and Chain Access. This is
separated from the Files, Pieces, Piece Preparation, and Data Transfer. Both of these systems are separated from
the Markets, which provide Orders, Deals, Market Visibility, and Deal Settlement.</p>
<h4 id="why-is-system-decoupling-useful">Why is System decoupling useful?</h4>
<p>This decoupling is useful for:</p>
<ul>
<li><strong>Implementation Boundaries:</strong> it is possible to build implementations of Filecoin that only implement a
subset of systems. This is especially useful for <em>Implementation Diversity</em>: we want many implementations
of security critical systems (eg Blockchain), but do not need many implementations of Systems that can be
decoupled.</li>
<li><strong>Runtime Decoupling:</strong> system decoupling makes it easier to build and run Filecoin Nodes that isolate
Systems into separate programs, and even separate physical computers.</li>
<li><strong>Security Isolation:</strong> some systems require higher operational security than others. System decoupling allows
implementations to meet their security and functionality needs. A good example of this is separating Blockchain
processing from Data Transfer.</li>
<li><strong>Scalability:</strong> systems and various use cases may drive different performance requirements for different opertators.
System decoupling makes it easier for operators to scale their deployments along system boundaries.</li>
</ul>
<h4 id="filecoin-nodes-dont-need-all-the-systems">Filecoin Nodes don&rsquo;t need all the systems</h4>
<p>Filecoin Nodes vary significantly, and do not need all the systems.
Most systems are only needed for a subset of use cases.</p>
<p>For example, the Blockchain System is required for synchronizing the chain, participating in secure consensus,
storage mining, and chain validation.
Many Filecoin Nodes do not need the chain and can perform their work by just fetching content from the latest
StateTree, from a node they trust. Of course, such nodes</p>
<p>Note: Filecoin does not use the &ldquo;full node&rdquo; or &ldquo;light client&rdquo; terminology, in wide use in Bitcoin and other blockchain
networks. In filecoin, these terms are not well defined. It is best to define nodes in terms of their capabilities,
and therefore, in terms of the Systems they run. For example:</p>
<ul>
<li><strong>Chain Verifier Node:</strong> Runs the Blockchain system. Can sync and validate the chain. Cannot mine or produce blocks.</li>
<li><strong>Client Node:</strong> Runs the Blockchain, Market, and Data Transfer systems. Can sync and validate the chain. Cannot mine or produce blocks.</li>
<li><strong>Retrieval Miner Node:</strong> Runs the Market and Data Transfer systems. Does not need the chain. Can make Retrieval Deals
(Retrieval Provider side). Can send Clients data, and get paid for it.</li>
<li><strong>Storage Miner Node:</strong> Runs the Blockchain, Storage Market, Storage Mining systems. Can sync and validate the chain.
Can make Storage Deals (Storage Provider side). Can seal stored data into sectors. Can acquire
storage consensus power. Can mine and produce blocks.</li>
</ul>
<h4 id="separating-systems">Separating Systems</h4>
<blockquote>
<p>How do we determine what functionality belongs in one system vs another?</p>
</blockquote>
<p>Drawing boundaries between systems is the art of separating tightly related functionality from unrelated parts.
In a sense, we seek to keep tightly integrated components in the same system, and away from other unrelated
components. This is sometimes straightforward, the boundaries naturally spring from the data structures or
functionality. For example, it is straightforward to observe that Clients and Miners negotiating a deal
with each other is very unrelated to VM Execution.</p>
<p>Sometimes this is harder, and it requires detangling, adding, or removing abstractions. For
example, the <code>StoragePowerActor</code> and the <code>StorageMarketActor</code> were a single <code>Actor</code> previously. This caused
a large coupling of functionality across <code>StorageDeal</code> making, the <code>StorageMarket</code>, markets in general, with
Storage Mining, Sector Sealing, PoSt Generation, and more. Detangling these two sets of related functionality
requried breaking apart the one actor into two.</p>
<h4 id="decomposing-within-a-system">Decomposing within a System</h4>
<p>Systems themselves decompose into smaller subunits. These are sometimes called &ldquo;subsystems&rdquo; to avoid confusion
with the much larger, first-class Systems. Subsystems themselves may break down further. The naming here is not
strictly enforced, as these subdivisions are more related to protocol and implementation engineering concerns
than to user capabilities.</p>


</div>



</div>

  

  
    








<div id="intro__system__impl_systems">

<h3 class="section-header">
  Implementing Systems
</h3>

<div class="section-content">




































<h4 id="system-requirements">System Requirements</h4>
<p>In order to make it easier to decouple functionality into systems, the Filecoin Protocol assumes
a set of functionality available to all systems. This functionality can be achieved by implementations
in a variety of ways, and should take the guidance here as a recommendation (SHOULD).</p>
<p>All Systems, as defined in this document, require the following:</p>
<ul>
<li><strong>Repository:</strong>
<ul>
<li><strong>Local <code>IpldStore</code>.</strong> Some amount of persistent local storage for data structures (small structured objects).
Systems expect to be initialized with an IpldStore in which to store data structures they expect to persist across crashes.</li>
<li><strong>User Configuration Values.</strong> A small amount of user-editable configuration values.
These should be easy for end-users to access, view, and edit.</li>
<li><strong>Local, Secure <code>KeyStore</code>.</strong> A facility to use to generate and use cryptographic keys, which MUST remain secret to the
Filecoin Node. Systems SHOULD NOT access the keys directly, and should do so over an abstraction (ie the <code>KeyStore</code>) which
provides the ability to Encrypt, Decrypt, Sign, SigVerify, and more.</li>
</ul>
</li>
<li><strong>Local <code>FileStore</code>.</strong> Some amount of persistent local storage for files (large byte arrays).
Systems expect to be initialized with a FileStore in which to store large files.
Some systems (like Markets) may need to store and delete large volumes of smaller files (1MB - 10GB).
Other systems (like Storage Mining) may need to store and delete large volumes of large files (1GB - 1TB).</li>
<li><strong>Network.</strong> Most systems need access to the network, to be able to connect to their counterparts in other Filecoin Nodes.
Systems expect to be initialized with a libp2p.Node on which they can mount their own protocols.</li>
<li><strong>Clock.</strong> Some systems need access to current network time, some with low tolerance for drift.
Systems expect to be initialized with a Clock from which to tell network time. Some systems (like Blockchain)
require very little clock drift, and require <em>secure</em> time.</li>
</ul>
<p>For this purpose, we use the <code>FilecoinNode</code> data structure, which is passed into all systems at initialization:</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">repo</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository&#34;</span>
<span class="kn">import</span> <span class="nx">filestore</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>
<span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>
<span class="kn">import</span> <span class="nx">message_pool</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/message_pool&#34;</span>

<span class="kd">type</span> <span class="nx">FilecoinNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Node</span>         <span class="nx">libp2p</span><span class="p">.</span><span class="nx">Node</span>

    <span class="nx">Repository</span>   <span class="nx">repo</span><span class="p">.</span><span class="nx">Repository</span>
    <span class="nx">FileStore</span>    <span class="nx">filestore</span><span class="p">.</span><span class="nx">FileStore</span>
    <span class="nx">Clock</span>        <span class="nx">clock</span><span class="p">.</span><span class="nx">UTCClock</span>

    <span class="nx">MessagePool</span>  <span class="nx">message_pool</span><span class="p">.</span><span class="nx">MessagePoolSubsystem</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">key_store</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/key_store&#34;</span>
<span class="kn">import</span> <span class="nx">config</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/config&#34;</span>

<span class="kd">type</span> <span class="nx">Repository</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Config</span>      <span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
    <span class="nx">KeyStore</span>    <span class="nx">key_store</span><span class="p">.</span><span class="nx">KeyStore</span>
    <span class="nx">ChainStore</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">GraphStore</span>
    <span class="nx">StateStore</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">GraphStore</span>
<span class="p">}</span>
</code></pre></div>





<h4 id="system-limitations">System Limitations</h4>
<p>Further, Systems MUST abide by the following limitations:</p>
<ul>
<li><strong>Random crashes.</strong> A Filecoin Node may crash at any moment. Systems must be secure and consistent through crashes.
This is primarily achived by limiting the use of persistent state, persisting such state through Ipld data structures,
and through the use of initialization routines that check state, and perhaps correct errors.</li>
<li><strong>Isolation.</strong> Systems must communicate over well-defined, isolated interfaces. They must not build their critical
functionality over a shared memory space. (Note: for performance, shared memory abstractions can be used to power
IpldStore, FileStore, and libp2p, but the systems themselves should not require it). This is not just an operational
concern; it also significantly simplifies the protocol and makes it easier to understand, analyze, debug, and change.</li>
<li><strong>No direct access to host OS Filesystem or Disk.</strong> Systems cannot access disks directly &ndash; they do so over the FileStore
and IpldStore abstractions. This is to provide a high degree of portability and flexibility for end-users, especially
storage miners and clients of large amounts of data, which need to be able to easily replace how their Filecoin Nodes
access local storage.</li>
<li><strong>No direct access to host OS Network stack or TCP/IP.</strong> Systems cannot access the network directly &ndash; they do so over the
libp2p library. There must not be any other kind of network access. This provides a high degree of portability across
platforms and network protocols, enabling Filecoin Nodes (and all their critical systems) to run in a wide variety of
settings, using all kinds of protocols (eg Bluetooth, LANs, etc).</li>
</ul>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems">

<h1 class="section-header">
  Systems
</h1>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_nodes">

<h2 class="section-header">
  <strong>Filecoin Nodes</strong>
</h2>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_nodes__node_types">

<h3 class="section-header">
  Node Types
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_nodes__node_types__node">

<h4 class="section-header">
  Node Interface
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">repo</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository&#34;</span>
<span class="kn">import</span> <span class="nx">filestore</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>
<span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>
<span class="kn">import</span> <span class="nx">message_pool</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/message_pool&#34;</span>

<span class="kd">type</span> <span class="nx">FilecoinNode</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Node</span>         <span class="nx">libp2p</span><span class="p">.</span><span class="nx">Node</span>

    <span class="nx">Repository</span>   <span class="nx">repo</span><span class="p">.</span><span class="nx">Repository</span>
    <span class="nx">FileStore</span>    <span class="nx">filestore</span><span class="p">.</span><span class="nx">FileStore</span>
    <span class="nx">Clock</span>        <span class="nx">clock</span><span class="p">.</span><span class="nx">UTCClock</span>

    <span class="nx">MessagePool</span>  <span class="nx">message_pool</span><span class="p">.</span><span class="nx">MessagePoolSubsystem</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__node_types">

<h4 class="section-header">
  Examples
</h4>

<div class="section-content">




































<p>There are many kinds of Filecoin Nodes &hellip;</p>
<p>This section should contain:</p>
<ul>
<li>what all nodes must have, and why</li>
<li>examples of using different systems</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__verifier_node">

<h4 class="section-header">
  Chain Verifier Node
</h4>

<div class="section-content">




































<pre><code>type ChainVerifierNode interface {
  FilecoinNode

  systems.Blockchain
}
</code></pre>

</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__client_node">

<h4 class="section-header">
  Client Node
</h4>

<div class="section-content">




































<pre><code>type ClientNode struct {
  FilecoinNode

  systems.Blockchain
  markets.StorageMarketClient
  markets.RetrievalMarketClient
  markets.MarketOrderBook
  markets.DataTransfers
}
</code></pre>

</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__storage_miner_node">

<h4 class="section-header">
  Storage Miner Node
</h4>

<div class="section-content">




































<pre><code>type StorageMinerNode interface {
  FilecoinNode

  systems.Blockchain
  systems.Mining
  markets.StorageMarketProvider
  markets.MarketOrderBook
  markets.DataTransfers
}
</code></pre>

</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__retrieval_miner_node">

<h4 class="section-header">
  Retrieval Miner Node
</h4>

<div class="section-content">




































<pre><code>type RetrievalMinerNode interface {
  FilecoinNode

  blockchain.Blockchain
  markets.RetrievalMarketProvider
  markets.MarketOrderBook
  markets.DataTransfers
}
</code></pre>

</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__node_types__relayer_node">

<h4 class="section-header">
  Relayer Node
</h4>

<div class="section-content">




































<pre><code>type RelayerNode interface {
  FilecoinNode

  blockchain.MessagePool
  markets.MarketOrderBook
}
</code></pre>

</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_nodes__repository">

<h3 class="section-header">
  Repository - Local Storage for Chain Data and Systems
</h3>

<div class="section-content">




































<p>The Filecoin node repository is simply an abstraction denoting that data which any functional Filecoin node needs to store locally in order to run correctly.</p>
<p>The repo is accessible to the node&rsquo;s systems and subsystems and acts as local storage compartementalized from the node&rsquo;s <code>FileStore</code> (for instance).</p>
<p>It stores the node&rsquo;s keys, the IPLD datastructures of stateful objects and node configs.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">key_store</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/key_store&#34;</span>
<span class="kn">import</span> <span class="nx">config</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/repository/config&#34;</span>

<span class="kd">type</span> <span class="nx">Repository</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Config</span>      <span class="nx">config</span><span class="p">.</span><span class="nx">Config</span>
    <span class="nx">KeyStore</span>    <span class="nx">key_store</span><span class="p">.</span><span class="nx">KeyStore</span>
    <span class="nx">ChainStore</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">GraphStore</span>
    <span class="nx">StateStore</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">GraphStore</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_nodes__repository__config">

<h4 class="section-header">
  Config - Local Storage for ConfigurationValues
</h4>

<div class="section-content">




































<p>Filecoin Node configuration</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">ConfigKey</span> <span class="kt">string</span>
<span class="kd">type</span> <span class="nx">ConfigVal</span> <span class="nx">Bytes</span>

<span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Get</span><span class="p">(</span><span class="nx">k</span> <span class="nx">ConfigKey</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">c</span> <span class="nx">ConfigVal</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Put</span><span class="p">(</span><span class="nx">k</span> <span class="nx">ConfigKey</span><span class="p">,</span> <span class="nx">v</span> <span class="nx">ConfigVal</span><span class="p">)</span> <span class="kt">error</span>

    <span class="nf">Subconfig</span><span class="p">(</span><span class="nx">k</span> <span class="nx">ConfigKey</span><span class="p">)</span> <span class="nx">Config</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__repository__key_store">

<h4 class="section-header">
  Key Store
</h4>

<div class="section-content">




































<p>The <code>Key Store</code> is a fundamental abstraction in any full Filecoin node used to store the keypairs associated to a given miner&rsquo;s address and distinct workers (should the miner choose to run multiple workers).</p>
<p>Node security depends in large part on keeping these keys secure. To that end we recommend keeping keys separate from any given subsystem and using a separate key store to sign requests as required by subsystems as well as keeping those keys not used as part of mining in cold storage.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">address</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>

<span class="kd">type</span> <span class="nx">KeyStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">MinerAddress</span>  <span class="nx">address</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">OwnerKey</span>      <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFKeyPair</span>
    <span class="nx">WorkerKey</span>     <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFKeyPair</span>
<span class="p">}</span>
</code></pre></div>





<p>Filecoin storage miners rely on three main components:</p>
<ul>
<li><strong>The miner address</strong> uniquely assigned to a given storage miner actor upon calling <code>registerMiner()</code> in the Storage Power Consensus Subsystem. It is a unique identifier for a given storage miner to which its power and other keys will be associated.</li>
<li><strong>The owner keypair</strong> is provided by the miner ahead of registration and its public key associated to the miner address. Block rewards and other payments are made to the ownerAddress.</li>
<li><strong>The worker keypair</strong> can be chosen and changed by the miner, its public key associated to the miner address. It is used to sign transactions, signatures, etc. It must be a BLS keypair given its use as part of the <a href="./#algorithms__crypto__vrf">Verifiable Random Function</a>.</li>
</ul>
<p>While miner addresses are unique, multiple storage miner actors can share an owner public key or likewise a worker public key.</p>
<p>The process for changing the worker keypairs on-chain (i.e. the workerKey associated to a storage miner) is specified in <a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor">Storage Miner Actor</a>. Note that this is a two-step process. First a miner stages a change by sending a message to the chain. When received, the key change is staged to occur in twice the randomness lookback parameter number of epochs, to prevent adaptive key selection attacks.
Every time a worker key is queried, a pending change is lazily checked and state is potentially updated as needed.</p>
<p>TODO:</p>
<ul>
<li>potential reccomendations or clear disclaimers with regards to consequences of failed key security</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__repository__ipldstore">

<h4 class="section-header">
  IpldStore - Local Storage for hash-linked data
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// imported as ipld.Object
</span><span class="c1"></span>
<span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>

<span class="kd">type</span> <span class="nx">Object</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">CID</span><span class="p">()</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>

    <span class="c1">// Populate(v interface{}) error
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">GraphStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Retrieves a serialized value from the store by CID. Returns the value and whether it was found.
</span><span class="c1"></span>    <span class="nf">Get</span><span class="p">(</span><span class="nx">c</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span><span class="p">)</span> <span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="c1">// Puts a serialized value in the store, returning the CID.
</span><span class="c1"></span>    <span class="nf">Put</span><span class="p">(</span><span class="nx">value</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>





<p>Filecoin datastructures are stored in <a href="https://ipld.io">IPLD</a> format, a data format akin to json built for storage, retrieval and traversal of hash-linked data DAGs.</p>
<p>The Filecoin network relies primarily on two distinct IPLD GraphStores:</p>
<ul>
<li>One <code>ChainStore</code> which stores the blockchain, including block headers, associated messages, etc.</li>
<li>One <code>StateStore</code> which stores the payload state from a given blockchain, or the <code>stateTree</code> resulting from all block messages in a given chain being applied to the genesis state by the <a href="./#systems__filecoin_vm">Filecoin VM</a>.</li>
</ul>
<p>The <code>ChainStore</code> is downloaded by nodes from their peers during the bootstrapping phase of <a href="./#systems__filecoin_blockchain__chainsync">ChainSync - synchronizing the Blockchain</a> and stored by the node thereafter. It is updated on every new block reception, or if the node syncs to a new best chain.</p>
<p>The <code>StateStore</code> is computed through execution of all block messages in a given <code>ChainStore</code> and stored by the node thereafter. It is updated with every new incoming block&rsquo;s processing by the <a href="./#systems__filecoin_vm__interpreter">VM Interpreter - Message Invocation (Outside VM)</a> and referenced accordingly by new blocks produced atop it in the block <a href="./#systems__filecoin_blockchain__struct__block___index">block header</a>&rsquo;s <code>ParentState</code> field.</p>
<p>TODO:</p>
<ul>
<li>What is IPLD
<ul>
<li>hash linked data</li>
<li>from IPFS</li>
</ul>
</li>
<li>Why is it relevant to filecoin
<ul>
<li>all network datastructures are definitively IPLD</li>
<li>all local datastructures can be IPLD</li>
</ul>
</li>
<li>What is an IpldStore
<ul>
<li>local storage of dags</li>
</ul>
</li>
<li>How to use IpldStores in filecoin
<ul>
<li>pass it around</li>
</ul>
</li>
<li>One ipldstore or many
<ul>
<li>temporary caches</li>
<li>intermediately computed state</li>
</ul>
</li>
<li>Garbage Collection</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_nodes__network">

<h3 class="section-header">
  Network Interface
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="nx">libp2p</span><span class="p">.</span><span class="nx">Node</span>
</code></pre></div>





<p>Filecoin nodes use the libp2p protocol for peer discovery, peer routing, and message multicast, and so on. Libp2p is a set of modular protocols common to the peer-to-peer networking stack. Nodes open connections with one another and mount different protocols or streams over the same connection. In the initial handshake, nodes exchange the protocols that each of them supports and all Filecoin related protcols will be mounted under <code>/fil/...</code> protocol identifiers.</p>
<p>Here is the list of libp2p protocols used by Filecoin.</p>
<ul>
<li>Graphsync:
<ul>
<li>Graphsync is used to transfer blockchain and user data</li>
<li><a href="https://github.com/ipld/specs/blob/master/block-layer/graphsync/graphsync.md">Draft spec</a></li>
<li>No filecoin specific modifications to the protocol id</li>
</ul>
</li>
<li>Gossipsub:
<ul>
<li>block headers and messages are broadcasted through a Gossip PubSub protocol where nodes can subscribe to topics for blockchain data and receive messages in those topics. When receiving messages related to a topic, nodes processes the message and forwards it to its peers who also subscribed to the same topic.</li>
<li>Spec is <a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">here</a></li>
<li>No filecoin specific modifications to the protocol id.  However the topic identifiers MUST be of the form <code>fil/blocks/&lt;network-name&gt;</code> and <code>fil/msgs/&lt;network-name&gt;</code></li>
</ul>
</li>
<li>KademliaDHT:
<ul>
<li>Kademlia DHT is a distributed hash table with a logarithmic bound on the maximum number of lookups for a particular node. Kad DHT is used primarily for peer routing as well as peer discovery in the Filecoin protocol.</li>
<li>Spec TODO <a href="https://github.com/libp2p/go-libp2p-kad-dht">reference implementation</a></li>
<li>The protocol id must be of the form <code>fil/&lt;network-name&gt;/kad/1.0.0</code></li>
</ul>
</li>
<li>Bootstrap List:
<ul>
<li>Bootstrap is a list of nodes that a new node attempts to connect upon joining the network. The list of bootstrap nodes and their addresses are defined by the users.</li>
</ul>
</li>
<li>Peer Exchange:
<ul>
<li>Peer Exchange is a discovery protocol enabling peers to create and issue queries for desired peers against their existing peers</li>
<li>spec <a href="https://github.com/libp2p/specs/issues/222">TODO</a></li>
<li>No Filecoin specific modifications to the protocol id.</li>
</ul>
</li>
<li>DNSDiscovery: Design and spec needed before implementing</li>
<li>HTTPDiscovery: Design and spec needed before implementing</li>
<li>Hello:
<ul>
<li>Hello protocol handles new connections to filecoin nodes to facilitate discovery</li>
<li>the protocol string is <code>fil/hello/1.0.0</code>.</li>
</ul>
</li>
</ul>
<h4 id="hello-spec">Hello Spec</h4>
<h5 id="protocol-flow">Protocol Flow</h5>
<p><code>fil/hello</code> is a filecoin specific protocol built on the libp2p stack.  It consists of two conceptual
procedures: <code>hello_connect</code> and <code>hello_listen</code>.</p>
<p><code>hello_listen</code>: <code>on new stream</code> -&gt; <code>read peer hello msg from stream</code> -&gt; <code>write latency message to stream</code> -&gt; <code>close stream</code></p>
<p><code>hello_connect</code>: <code>on connected</code> -&gt; <code>open stream</code> -&gt; <code>write own hello msg to stream</code> -&gt; <code>read peer latency msg from stream</code>  -&gt; <code>close stream</code></p>
<p>where stream and connection operations are all standard libp2p operations.  Nodes running the Hello Protocol should consume the incoming Hello Message and use it to help manage peers and sync the chain.</p>
<h5 id="messages">Messages</h5>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>

<span class="c1">// HelloMessage shares information about a peer&#39;s chain head
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">HelloMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">HeaviestTipSet</span>        <span class="p">[</span><span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span><span class="p">]</span>
    <span class="nx">HeaviestTipSetWeight</span>  <span class="nx">BigInt</span>
    <span class="nx">HeaviestTipSetHeight</span>  <span class="nx">Int</span>
    <span class="nx">GenesisHash</span>           <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
<span class="p">}</span>

<span class="c1">// LatencyMessage shares information about a peer&#39;s network latency
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">LatencyMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Measured in unix nanoseconds 
</span><span class="c1"></span>    <span class="nx">TArrival</span>  <span class="nx">Int</span>
    <span class="c1">// Measured in unix nanoseconds
</span><span class="c1"></span>    <span class="nx">TSent</span>     <span class="nx">Int</span>
<span class="p">}</span>
</code></pre></div>





<p>When writing the <code>HelloMessage</code> to the stream the peer must inspect its current head to provide accurate information.  When writing the <code>LatencyMessage</code> to the stream the peer should set <code>TArrival</code> immediately upon receipt and <code>TSent</code> immediately before writing the message to the stream.</p>


</div>



</div>

  

  
    








<div id="systems__filecoin_nodes__clock">

<h3 class="section-header">
  Clock
</h3>

<div class="section-content">




































<div id="systems__filecoin_nodes__clock__clock"></div>
<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">UnixTime</span> <span class="kt">int64</span>  <span class="c1">// unix timestamp
</span><span class="c1"></span>
<span class="c1">// UTCClock is a normal, system clock reporting UTC time.
</span><span class="c1">// It should be kept in sync, with drift less than 1 second.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UTCClock</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">NowUTCUnix</span><span class="p">()</span> <span class="nx">UnixTime</span>
<span class="p">}</span>

<span class="c1">// ChainEpoch represents a round of a blockchain protocol.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ChainEpoch</span> <span class="kt">int64</span>

<span class="c1">// ChainEpochClock is a clock that represents epochs of the protocol.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ChainEpochClock</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// GenesisTime is the time of the first block. EpochClock counts
</span><span class="c1"></span>    <span class="c1">// up from there.
</span><span class="c1"></span>    <span class="nx">GenesisTime</span>              <span class="nx">UnixTime</span>

    <span class="nf">EpochAtTime</span><span class="p">(</span><span class="nx">t</span> <span class="nx">UnixTime</span><span class="p">)</span>  <span class="nx">ChainEpoch</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">clock</span>

<span class="kn">import</span> <span class="s">&#34;time&#34;</span>

<span class="c1">// UTCSyncPeriod notes how often to sync the UTC clock with an authoritative
</span><span class="c1">// source, such as NTP, or a very precise hardware clock.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">UTCSyncPeriod</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span>

<span class="c1">// EpochDuration is a constant that represents the duration in seconds
</span><span class="c1">// of a blockchain epoch.
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">EpochDuration</span> <span class="p">=</span> <span class="nf">UnixTime</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">_</span> <span class="o">*</span><span class="nx">UTCClock_I</span><span class="p">)</span> <span class="nf">NowUTCUnix</span><span class="p">()</span> <span class="nx">UnixTime</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">UnixTime</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Unix</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// EpochAtTime returns the ChainEpoch corresponding to time `t`.
</span><span class="c1">// It first subtracts GenesisTime, then divides by EpochDuration
</span><span class="c1">// and returns the resulting number of epochs.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ChainEpochClock_I</span><span class="p">)</span> <span class="nf">EpochAtTime</span><span class="p">(</span><span class="nx">t</span> <span class="nx">UnixTime</span><span class="p">)</span> <span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nx">difference</span> <span class="o">:=</span> <span class="nx">t</span> <span class="o">-</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GenesisTime</span><span class="p">()</span>
	<span class="nx">epochs</span> <span class="o">:=</span> <span class="nx">difference</span> <span class="o">/</span> <span class="nx">EpochDuration</span>
	<span class="k">return</span> <span class="nf">ChainEpoch</span><span class="p">(</span><span class="nx">epochs</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>




</p>
<p>Filecoin assumes weak clock synchrony amongst participants in the system. That is, the system relies on participants having access to a globally synchronized clock (tolerating some bounded drift).</p>
<p>Filecoin relies on this system clock in order to secure consensus.  Specifically the clock is necessary to support validation rules that prevent block producers from mining blocks with a future timstamp, and running leader elections more frequently than the protocol allows.</p>
<h5 id="clock-uses">Clock uses</h5>
<p>The Filecoin system clock is used:</p>
<ul>
<li>by syncing nodes to validate that incoming blocks were mined in the appropriate epoch given their timestamp (see <a href="./#systems__filecoin_blockchain__block__block_validation">Block Validation</a>).  This is possible because the system clock maps all times to a unique epoch number totally determined by the start time in the genesis block.</li>
<li>by syncing nodes to drop blocks coming from a future epoch</li>
<li>by mining nodes to maintain protocol liveness by allowing participants to try leader election in the next round if no one has produced a block in the current round (see <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a>).</li>
</ul>
<p>In order to allow miners to do the above, the system clock must:</p>
<ol>
<li>Have low enough clock drift (sub 1s) relative to other nodes so that blocks are not mined in epochs considered future epochs from the persective of other nodes (those blocks should not be validated until the proper epoch/time as per <a href="./#systems__filecoin_blockchain__struct__block___index">validation rules</a>).</li>
<li>Set epoch number on node initialization equal to <code>epoch = Floor[(current_time - genesis_time) / epoch_time]</code></li>
</ol>
<p>It is expected that other subsystems will register to a NewRound() event from the clock subsystem.</p>
<h5 id="clock-requirements">Clock Requirements</h5>
<p>Clocks used as part of the Filecoin protocol should be kept in sync, with drift less than 1 second so as to enable appropriate validation.</p>
<p>Computer-grade clock crystals can be expected to have drift rates on the order of <a href="https://www.hindawi.com/journals/jcnc/2008/583162/">1ppm</a> (i.e. 1 microsecond every second or .6 seconds a week), therefore, in order to respect the above-requirement,</p>
<ul>
<li>clients SHOULD query an NTP server (<code>pool.ntp.org</code> is recommended) on an hourly basis to adjust clock skew.
<ul>
<li>We recommend one of the following:
<ul>
<li><code>pool.ntp.org</code> (can be catered to a <a href="https://www.ntppool.org/zone">specific zone</a>)</li>
<li><code>time.cloudflare.com:1234</code> (more on <a href="https://www.cloudflare.com/time/">Cloudflare time services</a>)</li>
<li><code>time.google.com</code> (more on <a href="https://developers.google.com/time">Google Public NTP</a>)</li>
<li><code>ntp-b.nist.gov</code> (<a href="https://tf.nist.gov/tf-cgi/servers.cgi">NIST</a> servers require registration)</li>
</ul>
</li>
<li>We further recommend making 3 measurements in order to drop by using the network to drop outliers</li>
<li>See how <a href="https://github.com/ethereum/go-ethereum/blob/master/p2p/discv5/ntp.go">go-ethereum does this</a> for inspiration</li>
</ul>
</li>
<li>clients MAY consider using cesium clocks instead for accurate synchrony within larger mining operations</li>
</ul>
<p>Mining operations have a strong incentive to prevent their clock from drifting ahead more than one epoch to keep their block submissions from being rejected.  Likewise they have an incentive to prevent their clocks from drifting behind more than one epoch to avoid partitioning themselves off from the synchronized nodes in the network.</p>
<h5 id="future-work">Future work</h5>
<p>If either of the above metrics show significant network skew over time, future versions of Filecoin may include potential timestamp/epoch correction periods at regular intervals.</p>
<p>When recoverying from exceptional chain halting outages (for example all implementations panic on a given block) the network can potentially opt for per-outage &ldquo;dead zone&rdquo; rules banning the authoring of blocks during the outage epochs to prevent attack vectors related to unmined epochs during chain restart.</p>
<p>Future versions of the Filecoin protocol may use Verifiable Delay Functions (VDFs) to strongly enforce block time and fulfill this leader election requirement; we choose to explicitly assume clock synchrony until hardware VDF security has been proven more extensively.</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_files">

<h2 class="section-header">
  Files &amp; Data
</h2>

<div class="section-content">




































<p>Filecoin&rsquo;s primary aim is to store client&rsquo;s Files and Data.
This section details data structures and tooling related to working with files,
chunking, encoding, graph representations, <code>Pieces</code>, storage abstractions, and more.</p>

<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files">
        

        <strong>Files &amp; Data</strong>

        
            <br /><br /><i class="menuIcon">üìë</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__file">
        
            <i class="statusIcon">‚úÖ</i>
        

        File

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__file__filestore">
        

        FileStore

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__piece">
        
            <i class="statusIcon">‚úÖ</i>
        

        Piece

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__piece__piece_store">
        

        PieceStore

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__data_transfer">
        
            <i class="statusIcon">‚úÖ</i>
        

        Data Transfer

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_files__serialization">
        
            <i class="statusIcon">üîÅ</i>
        

        Formats and Serialization

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>



</div>


  
    








<div id="systems__filecoin_files__file">

<h3 class="section-header">
  File
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Path is an opaque locator for a file (e.g. in a unix-style filesystem).
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Path</span> <span class="kt">string</span>

<span class="c1">// File is a variable length data container.
</span><span class="c1">// The File interface is modeled after a unix-style file, but abstracts the
</span><span class="c1">// underlying storage system.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">File</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Path</span><span class="p">()</span>   <span class="nx">Path</span>
    <span class="nf">Size</span><span class="p">()</span>   <span class="kt">int</span>
    <span class="nf">Close</span><span class="p">()</span>  <span class="kt">error</span>

    <span class="c1">// Read reads from File into buf, starting at offset, and for size bytes.
</span><span class="c1"></span>    <span class="nf">Read</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Write writes from buf into File, starting at offset, and for size bytes.
</span><span class="c1"></span>    <span class="nf">Write</span><span class="p">(</span><span class="nx">offset</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_files__file__filestore">

<h4 class="section-header">
  FileStore - Local Storage for Files
</h4>

<div class="section-content">




































<p>The <code>FileStore</code> is an abstraction used to refer to any underlying system or device
that Filecoin will store its data to. It is based on Unix filesystem semantics, and
includes the notion of <code>Paths</code>. This abstraction is here in order to make sure Filecoin
implementations make it easy for end-users to replace the underlying storage system with
whatever suits their needs. The simplest version of <code>FileStore</code> is just the host operating
system&rsquo;s file system.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// FileStore is an object that can store and retrieve files by path.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FileStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Open</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">)</span>           <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">File</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Create</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">)</span>         <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">File</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Store</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">,</span> <span class="nx">f</span> <span class="nx">File</span><span class="p">)</span>  <span class="kt">error</span>
    <span class="nf">Delete</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Path</span><span class="p">)</span>         <span class="kt">error</span>

    <span class="c1">// maybe add:
</span><span class="c1"></span>    <span class="c1">// Copy(SrcPath, DstPath)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>





<h5 id="varying-user-needs">Varying user needs</h5>
<p>Filecoin user needs vary significantly, and many users &ndash; especially miners &ndash; will implement
complex storage architectures underneath and around Filecoin. The <code>FileStore</code> abstraction is here
to make it easy for these varying needs to be easy to satisfy. All file and sector local data
storage in the Filecoin Protocol is defined in terms of this <code>FileStore</code> interface, which makes
it easy for implementations to make swappable, and for end-users to swap out with their system
of choice.</p>
<h5 id="implementation-examples">Implementation examples</h5>
<p>The <code>FileStore</code> interface may be implemented by many kinds of backing data storage systems. For example:</p>
<ul>
<li>The host Operating System file system</li>
<li>Any Unix/Posix file system</li>
<li>RAID-backed file systems</li>
<li>Networked of distributed file systems (NFS, HDFS, etc)</li>
<li>IPFS</li>
<li>Databases</li>
<li>NAS systems</li>
<li>Raw serial or block devices</li>
<li>Raw hard drives (hdd sectors, etc)</li>
</ul>
<p>Implementations SHOULD implement support for the host OS file system.
Implementations MAY implement support for other storage systems.</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_files__piece">

<h3 class="section-header">
  Piece - a part of a file
</h3>

<div class="section-content">




































<p>A <code>Piece</code> is an object that represents a whole or part of a <code>File</code>,
and is used by <code>Clients</code> and <code>Miners</code> in <code>Deals</code>. <code>Clients</code> hire <code>Miners</code>
to store <code>Pieces</code>.</p>
<p>The piece data structure is designed for proving storage of arbitrary
IPLD graphs and client data. This diagram shows the detailed composition
of a piece and its proving tree, including both full and bandwidth-optimized
piece data structures.</p>












<div class="diagram">

<span class="diagram-title">Pieces, Proving Trees, and Piece Data Structures</span>




(<a href="docs/systems/filecoin_files/piece/diagrams/pieces.png" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_files/piece/diagrams/pieces.png" />




</div>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>

<span class="c1">// PieceInfo is an object that describes details about a piece, and allows
</span><span class="c1">// decoupling storage of this information from the piece itself.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>    <span class="nx">PieceID</span>
    <span class="nx">Size</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span>
    <span class="c1">// TODO: store which algorithms were used to construct this piece.
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Piece represents the basic unit of tradeable data in Filecoin. Clients
</span><span class="c1">// break files and data up into Pieces, maybe apply some transformations,
</span><span class="c1">// and then hire Miners to store the Pieces.
</span><span class="c1">//
</span><span class="c1">// The kinds of transformations that may ocurr include erasure coding,
</span><span class="c1">// encryption, and more.
</span><span class="c1">//
</span><span class="c1">// Note: pieces are well formed.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Piece</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Info</span>       <span class="nx">PieceInfo</span>

    <span class="c1">// tree is the internal representation of Piece. It is a tree
</span><span class="c1"></span>    <span class="c1">// formed according to a sequence of algorithms, which make the
</span><span class="c1"></span>    <span class="c1">// piece able to be verified.
</span><span class="c1"></span>    <span class="nx">tree</span>       <span class="nx">PieceTree</span>

    <span class="c1">// Payload is the user&#39;s data.
</span><span class="c1"></span>    <span class="nf">Payload</span><span class="p">()</span>  <span class="nx">Bytes</span>

    <span class="c1">// Data returns the serialized representation of the Piece.
</span><span class="c1"></span>    <span class="c1">// It includes the payload data, and intermediate tree objects,
</span><span class="c1"></span>    <span class="c1">// formed according to relevant storage algorithms.
</span><span class="c1"></span>    <span class="nf">Data</span><span class="p">()</span>     <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="c1">// // LocalPieceRef is an object used to refer to pieces in local storage.
</span><span class="c1">// // This is used by subsystems to store and locate pieces.
</span><span class="c1">// type LocalPieceRef struct {
</span><span class="c1">//   ID   PieceID
</span><span class="c1">//   Path file.Path
</span><span class="c1">// }
</span><span class="c1"></span>
<span class="c1">// PieceTree is a data structure used to form pieces. The algorithms involved
</span><span class="c1">// in the storage proofs determine the shape of PieceTree and how it must be
</span><span class="c1">// constructed.
</span><span class="c1">//
</span><span class="c1">// Usually, a node in PieceTree will include either Children or Data, but not
</span><span class="c1">// both.
</span><span class="c1">//
</span><span class="c1">// TODO: move this into filproofs -- use a tree from there, as that&#39;s where
</span><span class="c1">// the algorightms are defined. Or keep this as an interface, met by others.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceTree</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Children</span>  <span class="p">[</span><span class="nx">PieceTree</span><span class="p">]</span>
    <span class="nx">Data</span>      <span class="nx">Bytes</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_files__piece__piece_store">

<h4 class="section-header">
  PieceStore - storing and indexing pieces
</h4>

<div class="section-content">




































<p>A <code>PieceStore</code> is an object that can store and retrieve pieces
from some local storage. The <code>PieceStore</code> additionally keeps
an index of pieces.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>

<span class="kd">type</span> <span class="nx">PieceID</span> <span class="nx">UVarint</span>

<span class="c1">// PieceStore is an object that stores pieces into some local storage.
</span><span class="c1">// it is internally backed by an IpldStore.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PieceStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Store</span>              <span class="nx">ipld</span><span class="p">.</span><span class="nx">GraphStore</span>
    <span class="nx">Index</span>              <span class="p">{</span><span class="nx">PieceID</span><span class="p">:</span> <span class="nx">Piece</span><span class="p">}</span>

    <span class="nf">Get</span><span class="p">(</span><span class="nx">i</span> <span class="nx">PieceID</span><span class="p">)</span>     <span class="kd">struct</span> <span class="p">{</span><span class="nx">p</span> <span class="nx">Piece</span><span class="p">,</span> <span class="nx">e</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">Put</span><span class="p">(</span><span class="nx">p</span> <span class="nx">Piece</span><span class="p">)</span>       <span class="kt">error</span>
    <span class="nf">Delete</span><span class="p">(</span><span class="nx">i</span> <span class="nx">PieceID</span><span class="p">)</span>  <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_files__data_transfer">

<h3 class="section-header">
  Data Transfer in Filecoin
</h3>

<div class="section-content">




































<p><em>Data Transfer</em> is a system for transferring all or part of a <code>Piece</code> across the network when a deal is made.</p>
<h4 id="modules">Modules</h4>
<p>This diagram shows how Data Transfer and its modules fit into the picture with the Storage and Retrieval Markets.
In particular, note how the Data Transfer Request Validators from the markets are plugged into the Data Transfer module,
but their code belongs in the Markets system.</p>












<div class="diagram">

<span class="diagram-title">Data Transfer - Push Flow</span>




(<a href="docs/systems/filecoin_files/data_transfer/data-transfer-modules.png" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_files/data_transfer/data-transfer-modules.png" />




</div>

<h4 id="terminology">Terminology</h4>
<ul>
<li><strong>Push Request</strong>: A request to send data to the other party</li>
<li><strong>Pull Request</strong>: A request to have the other party send data</li>
<li><strong>Requestor</strong>: The party that initiates the data transfer request (whether Push or Pull)</li>
<li><strong>Responder</strong>: The party that receives the data transfer request</li>
<li><strong>Data Transfer Voucher</strong>: A wrapper around storage or retrieval data that can identify and validate the transfer request to the other party</li>
<li><strong>Request Validator</strong>: The data transfer module only initiates a transfer when the responder can validate that the request is tied directly to either an existing storage deal or retrieval deal. Validation is not performed by the data transfer module itself. Instead, a request validator inspects the data transfer voucher to determine whether to respond to the request.</li>
<li><strong>Scheduler</strong>:  Once a request is negotiated and validated, actual transfer is managed by a scheduler on both sides. The scheduler is part of the data transfer module but is isolated from the negotiation process. It has access to an underlying verifiable transport protocol and uses it to send data and track progress.</li>
<li><strong>Subscriber</strong>: An external component that monitors progress of a data transfer by subscribing to data transfer events, such as progress or completion.</li>
<li><strong>GraphSync</strong>: The default underlying transfer protocol used by the Scheduler. The full graphsync specification can be found at <a href="https://github.com/ipld/specs/blob/master/block-layer/graphsync/graphsync.md">https://github.com/ipld/specs/blob/master/block-layer/graphsync/graphsync.md</a></li>
</ul>
<h4 id="request-phases">Request Phases</h4>
<p>There are two basic phases to any data transfer:</p>
<ol>
<li>Negotiation - the requestor and responder agree to the transfer by validating with the data transfer voucher</li>
<li>Transfer - Once the negotiation phase is complete, the data is actually transferred. The default protocol used to do the transfer is Graphsync.</li>
</ol>
<p>Note that the Negotiation and Transfer stages can occur in separate round trips,
or potentially the same round trip, where the requesting party implicitly agrees by sending the request, and the responding party can agree and immediately send or receive data.</p>
<h4 id="example-flows">Example Flows</h4>
<h5 id="push-flow">Push Flow</h5>












<div class="diagram">

<span class="diagram-title">Data Transfer - Push Flow</span>




(<a href="docs/systems/filecoin_files/data_transfer/push-flow.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_files/data_transfer/push-flow.mmd.svg" />




</div>

<ol>
<li>A requestor initiates a Push transfer when it wants to send data to another party.</li>
<li>The requestors&rsquo; data transfer module will send a push request to the responder along with the data transfer voucher. It also puts the data transfer in the scheduler queue, meaning it expects the responder to initiate a transfer once the request is verified</li>
<li>The responder&rsquo;s data transfer module validates the data transfer request via the Validator provided as a dependency by the responder</li>
<li>The responder&rsquo;s data transfer module schedules the transfer</li>
<li>The responder makes a GraphSync request for the data</li>
<li>The requestor receives the graphsync request, verifies it&rsquo;s in the scheduler and begins sending data</li>
<li>The responder receives data and can produce an indication of progress</li>
<li>The responder completes receiving data, and notifies any listeners</li>
</ol>
<p>The push flow is ideal for storage deals, where the client initiates the push
once it verifies the the deal is signed and on chain</p>
<h5 id="pull-flow">Pull Flow</h5>












<div class="diagram">

<span class="diagram-title">Data Transfer - Pull Flow</span>




(<a href="docs/systems/filecoin_files/data_transfer/pull-flow.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_files/data_transfer/pull-flow.mmd.svg" />




</div>

<ol>
<li>A requestor initiates a Pull transfer when it wants to receive data from another party.</li>
<li>The requestors&rsquo; data transfer module will send a pull request to the responder along with the data transfer voucher.</li>
<li>The responder&rsquo;s data transfer module validates the data transfer request via a PullValidator provided as a dependency by the responder</li>
<li>The responder&rsquo;s data transfer module schedules the transfer (meaning it is expecting the requestor to initiate the actual transfer)</li>
<li>The responder&rsquo;s data transfer module sends a response to the requestor saying it has accepted the transfer and is waiting for the requestor to initiate the transfer</li>
<li>The requestor schedules the data transfer</li>
<li>The requestor makes a GraphSync request for the data</li>
<li>The responder receives the graphsync request, verifies it&rsquo;s in the scheduler and begins sending data</li>
<li>The requestor receives data and can produce an indication of progress</li>
<li>The requestor completes receiving data, and notifies any listeners</li>
</ol>
<p>The pull flow is ideal for retrieval deals, where the client initiates the pull when the deal is agreed upon.</p>
<h4 id="alternater-pull-flow---single-round-trip">Alternater Pull Flow - Single Round Trip</h4>












<div class="diagram">

<span class="diagram-title">Data Transfer - Single Round Trip Pull Flow</span>




(<a href="docs/systems/filecoin_files/data_transfer/alternate-pull-flow.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_files/data_transfer/alternate-pull-flow.mmd.svg" />




</div>

<ol>
<li>A requestor initiates a Pull transfer when it wants to receive data from another party.</li>
<li>The requestor‚Äôs DTM schedules the data transfer</li>
<li>The requestor makes a Graphsync request to the responder with a data transfer request</li>
<li>The responder receives the graphsync request, and forwards the data transfer request to the data transfer module</li>
<li>The requestors&rsquo; data transfer module will send a pull request to the responder along with the data transfer voucher.</li>
<li>The responder&rsquo;s data transfer module validates the data transfer request via a PullValidator provided as a dependency by the responder</li>
<li>The responder&rsquo;s data transfer module schedules the transfer</li>
<li>The responder sends a graphsync response along with a data transfer accepted response piggypacked</li>
<li>The requestor receives data and can produce an indication of progress</li>
<li>The requestor completes receiving data, and notifies any listeners</li>
</ol>
<h4 id="protocol">Protocol</h4>
<p>A data transfer CAN be negotiated over the network via the <a href="./#listings__libp2p_protocols__data_transfer_protocol">Data Transfer Protocol</a>, a Libp2p protocol type</p>
<p>A Pull request expects a response. The requestor does not initiate the transfer
until they know the request is accepted.</p>
<p>The responder should send a response to a push request as well so the requestor can release the resources (if not accepted). However, if the Responder accepts the request they can immediately initiate the transfer</p>
<p>Using the Data Transfer Protocol as an independent libp2p communciation mechanism is not a hard requirement &ndash; as long as both parties have an implementation of the Data Transfer Subsystem that can talk to the other, any
transport mechanism (including offline mechanisms) is acceptable.</p>
<h4 id="data-structures">Data Structures</h4>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">libp2p</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/libp2p&#34;</span>
<span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>

<span class="kd">type</span> <span class="nx">StorageDeal</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">RetrievalDeal</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="c1">// A DataTransferVoucher is used to validate
</span><span class="c1">// a data transfer request against the underlying storage or retrieval deal
</span><span class="c1">// that precipitated it
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DataTransferVoucher</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">StorageDealVoucher</span>
    <span class="nx">RetrievalDealVoucher</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageDealVoucher</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">deal</span> <span class="nx">StorageDeal</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalDealVoucher</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">deal</span> <span class="nx">RetrievalDeal</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Ongoing</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Paused</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Completed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Failed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">ChannelNotFoundError</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">DataTransferStatus</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Ongoing</span>
    <span class="nx">Paused</span>
    <span class="nx">Completed</span>
    <span class="nx">Failed</span>
    <span class="nx">ChannelNotFoundError</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">TransferID</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">ChannelID</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">to</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
    <span class="nx">id</span> <span class="nx">TransferID</span>
<span class="p">}</span>

<span class="c1">// All immutable data for a channel
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DataTransferChannel</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// an identifier for this channel shared by request and responder, set by requestor through protocol
</span><span class="c1"></span>    <span class="nx">transferID</span>  <span class="nx">TransferID</span>
    <span class="c1">// base CID for the piece being transferred
</span><span class="c1"></span>    <span class="nx">PieceRef</span>    <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
    <span class="c1">// portion of Piece to return, specified by an IPLD selector
</span><span class="c1"></span>    <span class="nx">Selector</span>    <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="c1">// used to verify this channel
</span><span class="c1"></span>    <span class="nx">voucher</span>     <span class="nx">DataTransferVoucher</span>
    <span class="c1">// the party that is sending the data (not who initiated the request)
</span><span class="c1"></span>    <span class="nx">sender</span>      <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
    <span class="c1">// the party that is receiving the data (not who initiated the request)
</span><span class="c1"></span>    <span class="nx">recipient</span>   <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
    <span class="c1">// expected amount of data to be transferred
</span><span class="c1"></span>    <span class="nx">totalSize</span>   <span class="nx">UVarint</span>
<span class="p">}</span>

<span class="c1">// DataTransferState is immutable channel data plus mutable state
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DataTransferState</span> <span class="kd">struct</span> <span class="err">@</span><span class="p">(</span><span class="nx">mutable</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">DataTransferChannel</span>
    <span class="c1">// total bytes sent from this node (0 if receiver)
</span><span class="c1"></span>    <span class="nx">sent</span>                 <span class="nx">UVarint</span>
    <span class="c1">// total bytes received by this node (0 if sender)
</span><span class="c1"></span>    <span class="nx">received</span>             <span class="nx">UVarint</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Open</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Initiator</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SendData</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BytesToSend</span> <span class="nx">UInt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Progress</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BytesSent</span> <span class="nx">UInt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Pause</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Initiator</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Error</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ErrorMsg</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Complete</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">DataTransferEvent</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Open</span>
    <span class="nx">SendData</span>
    <span class="nx">Progress</span>
    <span class="nx">Pause</span>
    <span class="nx">Error</span>
    <span class="nx">Complete</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DataTransferSubscriber</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">OnEvent</span><span class="p">(</span><span class="nx">event</span> <span class="nx">DataTransferEvent</span><span class="p">,</span> <span class="nx">channelState</span> <span class="nx">DataTransferState</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// RequestValidator is an interface implemented by the client of the data transfer module to validate requests
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RequestValidator</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">ValidatePush</span><span class="p">(</span>
        <span class="nx">sender</span>    <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
        <span class="nx">voucher</span>   <span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>  <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
        <span class="nx">Selector</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span>
    <span class="nf">ValidatePull</span><span class="p">(</span>
        <span class="nx">receiver</span>  <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
        <span class="nx">voucher</span>   <span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>  <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
        <span class="nx">Selector</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span>
    <span class="nf">ValidateIntermediate</span><span class="p">(</span>
        <span class="nx">otherPeer</span>  <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
        <span class="nx">voucher</span>    <span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>   <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
        <span class="nx">Selector</span>   <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DataTransferSubsystem</span> <span class="kd">struct</span> <span class="err">@</span><span class="p">(</span><span class="nx">mutable</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">host</span>              <span class="nx">libp2p</span><span class="p">.</span><span class="nx">Node</span>
    <span class="nx">dataTransfers</span>     <span class="p">{</span><span class="nx">ChannelID</span><span class="p">:</span> <span class="nx">DataTransferState</span><span class="p">}</span>
    <span class="nx">requestValidator</span>  <span class="nx">RequestValidator</span>
    <span class="nx">pieceStore</span>        <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceStore</span>

    <span class="c1">// open a data transfer that will send data to the recipient peer and
</span><span class="c1"></span>    <span class="c1">// open a data transfer that will send data to the recipient peer and
</span><span class="c1"></span>    <span class="c1">// transfer parts of the piece that match the selector
</span><span class="c1"></span>    <span class="nf">OpenPushDataChannel</span><span class="p">(</span>
        <span class="nx">to</span>        <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
        <span class="nx">voucher</span>   <span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>  <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
        <span class="nx">Selector</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span> <span class="nx">ChannelID</span>

    <span class="c1">// open a data transfer that will request data from the sending peer and
</span><span class="c1"></span>    <span class="c1">// transfer parts of the piece that match the selector
</span><span class="c1"></span>    <span class="nf">OpenPullDataChannel</span><span class="p">(</span>
        <span class="nx">to</span>        <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
        <span class="nx">voucher</span>   <span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>  <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
        <span class="nx">Selector</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span> <span class="nx">ChannelID</span>

    <span class="c1">// close an open channel (effectively a cancel)
</span><span class="c1"></span>    <span class="nf">CloseDataTransferChannel</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ChannelID</span><span class="p">)</span>

    <span class="c1">// get status of a transfer
</span><span class="c1"></span>    <span class="nf">TransferChannelStatus</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ChannelID</span><span class="p">)</span> <span class="nx">DataTransferStatus</span>

    <span class="c1">// pause an ongoing channel
</span><span class="c1"></span>    <span class="nf">PauseChannel</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ChannelID</span><span class="p">)</span>

    <span class="c1">// resume an ongoing channel
</span><span class="c1"></span>    <span class="nf">ResumeChannel</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ChannelID</span><span class="p">)</span>

    <span class="c1">// send an additional voucher for an in progress request
</span><span class="c1"></span>    <span class="nf">SendIntermediateVoucher</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ChannelID</span><span class="p">,</span> <span class="nx">voucher</span> <span class="nx">DataTransferVoucher</span><span class="p">)</span>

    <span class="c1">// get notified when certain types of events happen
</span><span class="c1"></span>    <span class="nf">SubscribeToEvents</span><span class="p">(</span><span class="nx">subscriber</span> <span class="nx">DataTransferSubscriber</span><span class="p">)</span>

    <span class="c1">// get all in progress transfers
</span><span class="c1"></span>    <span class="nf">InProgressChannels</span><span class="p">()</span> <span class="p">{</span><span class="nx">ChannelID</span><span class="p">:</span> <span class="nx">DataTransferState</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_files__serialization">

<h3 class="section-header">
  Data Formats and Serialization
</h3>

<div class="section-content">




































<p>Filecoin seeks to make use of as few data formats as needed, with well-specced serialization rules to
better protocol security through simplicity and enable interoperability amongst implementations of the
Filecoin protocol.</p>
<p>Read more on design considerations <a href="https://github.com/filecoin-project/specs/issues/621">here for CBOR-usage</a> and <a href="https://github.com/filecoin-project/specs/issues/615">here for int types in Filecoin</a>.</p>
<h6 id="data-formats">Data Formats</h6>
<p>Filecoin in-memory data types are mostly straightforward.
Implementations should support two integer types: Int (meaning native 64-bit integer), and BigInt (meaning arbitrary length)
and avoid dealing with floating-point numbers to minimize interoperability issues across programming languages and implementations.</p>
<p>You can also read more on <a href="./#algorithms__crypto__randomness">data formats as part of randomness generation</a>) in the Filecoin protocol.</p>
<h6 id="serialization">Serialization</h6>
<p>Data <code>Serialization</code> in Filecoin ensures a consistent format for serializing in-memory data for transfer
in-flight and in-storage. Serialization is critical to protocol security and interoperability across
implementations of the Filecoin protocol, enabling consistent state updates across Filecoin nodes.</p>
<p>All data structures in Filecoin are <a href="https://tools.ietf.org/html/rfc7049">CBOR</a>-tuple encoded.
That is, any data structures used in the Filecoin system (structs in this spec) should be serialized
as CBOR-arrays with items corresponding to the data structure fields in their order of declaration.</p>
<p>You can find the encoding structure for major data types in CBOR <a href="https://tools.ietf.org/html/rfc7049#section-2.1">here</a>.</p>
<p>For illustration, an in-memory map would be represented as a CBOR-array of the keys and values listed in some
pre-determined order. A near-term update to the serialization format will involve tagging fields appropriately
to ensure appropriate serialization/deserialization as the protocol evolves.</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm">

<h2 class="section-header">
  VM - Virtual Machine
</h2>

<div class="section-content">




































<div id="systems__filecoin_vm__sys_vm"></div>

<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm">
        

        <strong>Virtual Machine</strong>

        
            <br /><br /><i class="menuIcon">üíª</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__actor">
        
            <i class="statusIcon">‚úÖ</i>
        

        Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__state_tree">
        
            <i class="statusIcon">üîÅ</i>
        

        State Tree

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__indices">
        
            <i class="statusIcon">‚ö†Ô∏è</i>
        

        Indices

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__message">
        
            <i class="statusIcon">‚úÖ</i>
        

        Message

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime">
        
            <i class="statusIcon">üîÅ</i>
        

        Runtime

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__runtime__gascost">
        

        Gas Costs

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors">
        
            <i class="statusIcon">üîÅ</i>
        

        System Actors

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors__init_actor">
        

        InitActor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors__cron_actor">
        

        CronActor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors__account_actor">
        

        AccountActor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__sysactors__reward_actor">
        

        RewardActor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_vm__interpreter">
        
            <i class="statusIcon">üîÅ</i>
        

        Interpreter

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>

<span class="c1">// VM is the object that controls execution.
</span><span class="c1">// It is a stateless, pure function. It uses no local storage.
</span><span class="c1">//
</span><span class="c1">// TODO: make it just a function: VMExec(...) ?
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">VM</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Execute computes and returns outTree, a new StateTree which is the
</span><span class="c1"></span>    <span class="c1">// application of msgs to inTree.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// *Important:* Execute is intended to be a pure function, with no side-effects.
</span><span class="c1"></span>    <span class="c1">// however, storage of the new parts of the computed outTree may exist in
</span><span class="c1"></span>    <span class="c1">// local storage.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// *TODO:* define whether this should take 0, 1, or 2 IpldStores:
</span><span class="c1"></span>    <span class="c1">// - (): storage of IPLD datastructures is assumed implicit
</span><span class="c1"></span>    <span class="c1">// - (store): get and put to same IpldStore
</span><span class="c1"></span>    <span class="c1">// - (inStore, outStore): get from inStore, put new structures into outStore
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// This decision impacts callers, and potentially impacts how we reason about
</span><span class="c1"></span>    <span class="c1">// local storage, and intermediate storage. It is definitely the case that
</span><span class="c1"></span>    <span class="c1">// implementations may want to operate on this differently, depending on
</span><span class="c1"></span>    <span class="c1">// how their IpldStores work.
</span><span class="c1"></span>    <span class="nf">Execute</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">msgs</span> <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span><span class="p">])</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_vm__actor">

<h3 class="section-header">
  VM Actor Interface
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// This contains actor things that are _outside_ of VM exection.
</span><span class="c1">// The VM uses this to execute abi.
</span><span class="c1"></span>
<span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors&#34;</span>
<span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>

<span class="c1">// CallSeqNum is an invocation (Call) sequence (Seq) number (Num).
</span><span class="c1">// This is a value used for securing against replay attacks:
</span><span class="c1">// each AccountActor (user) invocation must have a unique CallSeqNum
</span><span class="c1">// value. The sequenctiality of the numbers is used to make it
</span><span class="c1">// easy to verify, and to order messages.
</span><span class="c1">//
</span><span class="c1">// Q&amp;A
</span><span class="c1">// - &gt; Does it have to be sequential?
</span><span class="c1">//   No, a random nonce could work against replay attacks, but
</span><span class="c1">//   making it sequential makes it much easier to verify.
</span><span class="c1">// - &gt; Can it be used to order events?
</span><span class="c1">//   Yes, a user may submit N separate messages with increasing
</span><span class="c1">//   sequence number, causing them to execute in order.
</span><span class="c1">//
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CallSeqNum</span> <span class="kt">int64</span>

<span class="c1">// Actor is a base computation object in the Filecoin VM. Similar
</span><span class="c1">// to Actors in the Actor Model (programming), or Objects in Object-
</span><span class="c1">// Oriented Programming, or Ethereum Contracts in the EVM.
</span><span class="c1">//
</span><span class="c1">// ActorState represents the on-chain storage all actors keep.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ActorState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Identifies the code this actor executes.
</span><span class="c1"></span>    <span class="nx">CodeID</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span>
    <span class="c1">// CID of the root of optional actor-specific sub-state.
</span><span class="c1"></span>    <span class="nx">State</span>       <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSubstateCID</span>
    <span class="c1">// Balance of tokens held by this actor.
</span><span class="c1"></span>    <span class="nx">Balance</span>     <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="c1">// Expected sequence number of the next message sent by this actor.
</span><span class="c1"></span>    <span class="c1">// Initially zero, incremented when an account actor originates a top-level message.
</span><span class="c1"></span>    <span class="c1">// Always zero for other abi.
</span><span class="c1"></span>    <span class="nx">CallSeqNum</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ActorSystemStateCID</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>

<span class="c1">// ActorState represents the on-chain storage actors keep. This type is a
</span><span class="c1">// union of concrete types, for each of the Actors:
</span><span class="c1">// - InitActor
</span><span class="c1">// - CronActor
</span><span class="c1">// - AccountActor
</span><span class="c1">// - PaymentChannelActor
</span><span class="c1">// - StoragePowerActor
</span><span class="c1">// - StorageMinerActor
</span><span class="c1">// - StroageMarketActor
</span><span class="c1">//
</span><span class="c1">// TODO: move this into a directory inside the VM that patches in all
</span><span class="c1">// the actors from across the system. this will be where we declare/mount
</span><span class="c1">// all actors in the VM.
</span><span class="c1">// type ActorState union {
</span><span class="c1">//     Init struct {
</span><span class="c1">//         AddressMap  {addr.Address: ActorID}
</span><span class="c1">//         NextID      ActorID
</span><span class="c1">//     }
</span><span class="c1">// }
</span></code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">actor</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">IMPL_FINISH</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">IMPL_FINISH</span>
<span class="kd">var</span> <span class="nx">IMPL_TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">IMPL_TODO</span>
<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">TODO</span>

<span class="kd">type</span> <span class="nx">Serialization</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Serialization</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">ActorState_I</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>


  


</div>

  

  
    








<div id="systems__filecoin_vm__state_tree">

<h3 class="section-header">
  State Tree
</h3>

<div class="section-content">




































<p>The State Tree is the output of applying operations on the Filecoin Blockchain.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>

<span class="c1">// The on-chain state data structure is a map (HAMT) of addresses to actor states.
</span><span class="c1">// Only ID addresses are expected as keys.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StateTree</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ActorStates</span>  <span class="p">{</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">:</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorState</span><span class="p">}</span>  <span class="c1">// HAMT
</span><span class="c1"></span>
    <span class="c1">// Returns the CID of the root node of the HAMT.
</span><span class="c1"></span>    <span class="nf">RootCID</span><span class="p">()</span>    <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>

    <span class="c1">// Looks up an actor state by address.
</span><span class="c1"></span>    <span class="nf">GetActor</span><span class="p">(</span><span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span><span class="nx">state</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorState</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="c1">// Looks up an abi.ActorCodeID by address.
</span><span class="c1"></span>    <span class="nf">GetActorCodeID_Assert</span><span class="p">(</span><span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span>
<span class="p">}</span>
</code></pre></div>





<p>TODO</p>
<ul>
<li>Add ConvenienceAPI state to provide more user-friendly views.</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_vm__indices">

<h3 class="section-header">
  Macroeconomic Indices
</h3>

<div class="section-content">




































<p>Indices are a set of global economic indicators computed from State Tree and a collection of pure functions to compute policy output based on user state/action. Indices are used to compute and implement economic mechanisms and policies for the system. There are no persistent states in Indicies. Neither can Indices introduce any state mutation. Note that where indices should live is a design decision. It is possible to break Indices into multiple files or place indices in different actors once all economic mechanisms have been decided on. Temporarily, Indices is a holding file for all potential macroeconomic indicators that the system needs to be aware of.</p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">indices</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math/big&#34;</span>

	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">actor_util</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">PARAM_FINISH</span> <span class="p">=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">PARAM_FINISH</span>

<span class="c1">// Data in Indices are populated at instantiation with data from the state tree
</span><span class="c1">// Indices itself has no state tree or access to the runtime
</span><span class="c1">// it is a passive data structure that allows for convenience access to network indices
</span><span class="c1">// and pure functions in implementing economic policies given states
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Indices</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Epoch</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nf">NetworkKPI</span><span class="p">()</span> <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span>
	<span class="nf">TotalNetworkSectorWeight</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorWeight</span>
	<span class="nf">TotalPledgeCollateral</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">TotalNetworkEffectivePower</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="c1">// power above minimum miner size
</span><span class="c1"></span>	<span class="nf">TotalNetworkPower</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span>          <span class="c1">// total network power irrespective of meeting minimum miner size
</span><span class="c1"></span>
	<span class="nf">TotalMinedFIL</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">TotalUnminedFIL</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">TotalBurnedFIL</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">LastEpochReward</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>

	<span class="nf">StorageDeal_DurationBounds</span><span class="p">(</span>
		<span class="nx">pieceSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span>
		<span class="nx">startEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="p">)</span> <span class="p">(</span><span class="nx">minDuration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">maxDuration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span>
	<span class="nf">StorageDeal_StoragePricePerEpochBounds</span><span class="p">(</span>
		<span class="nx">pieceSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span>
		<span class="nx">startEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
		<span class="nx">endEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="p">)</span> <span class="p">(</span><span class="nx">minPrice</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">maxPrice</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
	<span class="nf">StorageDeal_ProviderCollateralBounds</span><span class="p">(</span>
		<span class="nx">pieceSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span>
		<span class="nx">startEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
		<span class="nx">endEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="p">)</span> <span class="p">(</span><span class="nx">minProviderCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">maxProviderCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
	<span class="nf">StorageDeal_ClientCollateralBounds</span><span class="p">(</span>
		<span class="nx">pieceSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span>
		<span class="nx">startEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
		<span class="nx">endEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="p">)</span> <span class="p">(</span><span class="nx">minClientCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">maxClientCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
	<span class="nf">SectorWeight</span><span class="p">(</span>
		<span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span>
		<span class="nx">startEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
		<span class="nx">endEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
		<span class="nx">dealWeight</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealWeight</span><span class="p">,</span>
	<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorWeight</span>
	<span class="nf">PledgeCollateralReq</span><span class="p">(</span><span class="nx">minerNominalPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">SectorWeightProportion</span><span class="p">(</span><span class="nx">minerActiveSectorWeight</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorWeight</span><span class="p">)</span> <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span>
	<span class="nf">PledgeCollateralProportion</span><span class="p">(</span><span class="nx">minerPledgeCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span>
	<span class="nf">StoragePower</span><span class="p">(</span>
		<span class="nx">minerActiveSectorWeight</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorWeight</span><span class="p">,</span>
		<span class="nx">minerInactiveSectorWeight</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorWeight</span><span class="p">,</span>
		<span class="nx">minerPledgeCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
	<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span>
	<span class="nf">StoragePowerProportion</span><span class="p">(</span>
		<span class="nx">minerStoragePower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span>
	<span class="p">)</span> <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span>
	<span class="nf">CurrEpochBlockReward</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">GetCurrBlockRewardRewardForMiner</span><span class="p">(</span>
		<span class="nx">minerStoragePower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span>
		<span class="nx">minerPledgeCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
		<span class="c1">// TODO extend or eliminate
</span><span class="c1"></span>	<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">StoragePower_PledgeSlashForSectorTermination</span><span class="p">(</span>
		<span class="nx">storageWeightDesc</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">SectorStorageWeightDesc</span><span class="p">,</span>
		<span class="nx">terminationType</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">SectorTermination</span><span class="p">,</span>
	<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">StoragePower_PledgeSlashForSurprisePoStFailure</span><span class="p">(</span>
		<span class="nx">minerClaimedPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span>
		<span class="nx">numConsecutiveFailures</span> <span class="kt">int64</span><span class="p">,</span>
	<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">StorageMining_PreCommitDeposit</span><span class="p">(</span>
		<span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span>
		<span class="nx">expirationEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">StorageMining_TemporaryFaultFee</span><span class="p">(</span>
		<span class="nx">storageWeightDescs</span> <span class="p">[]</span><span class="nx">actor_util</span><span class="p">.</span><span class="nx">SectorStorageWeightDesc</span><span class="p">,</span>
		<span class="nx">duration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">NetworkTransactionFee</span><span class="p">(</span>
		<span class="nx">toActorCodeID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span>
		<span class="nx">methodNum</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span>
	<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">GetCurrBlockRewardForMiner</span><span class="p">(</span>
		<span class="nx">minerStoragePower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span>
		<span class="nx">minerPledgeCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
	<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">IndicesImpl</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// these fields are computed from StateTree upon construction
</span><span class="c1"></span>	<span class="c1">// they are treated as globally available states
</span><span class="c1"></span>	<span class="nx">Epoch</span>                      <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nx">NetworkKPI</span>                 <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span>
	<span class="nx">TotalNetworkSectorWeight</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorWeight</span>
	<span class="nx">TotalPledgeCollateral</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">TotalNetworkEffectivePower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="c1">// power above minimum miner size
</span><span class="c1"></span>	<span class="nx">TotalNetworkPower</span>          <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="c1">// total network power irrespective of meeting minimum miner size
</span><span class="c1"></span>
	<span class="nx">TotalMinedFIL</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">TotalUnminedFIL</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">TotalBurnedFIL</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">LastEpochReward</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">StorageDeal_DurationBounds</span><span class="p">(</span>
	<span class="nx">pieceSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span>
	<span class="nx">startEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">minDuration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">maxDuration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// placeholder
</span><span class="c1"></span>	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nx">minDuration</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">ChainEpoch</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">maxDuration</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">ChainEpoch</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">StorageDeal_StoragePricePerEpochBounds</span><span class="p">(</span>
	<span class="nx">pieceSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span>
	<span class="nx">startEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="nx">endEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">minPrice</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">maxPrice</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// placeholder
</span><span class="c1"></span>	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">StorageDeal_ProviderCollateralBounds</span><span class="p">(</span>
	<span class="nx">pieceSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span>
	<span class="nx">startEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="nx">endEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">minProviderCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">maxProviderCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// placeholder
</span><span class="c1"></span>	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">StorageDeal_ClientCollateralBounds</span><span class="p">(</span>
	<span class="nx">pieceSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span>
	<span class="nx">startEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="nx">endEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">minClientCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">maxClientCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// placeholder
</span><span class="c1"></span>	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">SectorWeight</span><span class="p">(</span>
	<span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span>
	<span class="nx">startEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="nx">endEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
	<span class="nx">dealWeight</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealWeight</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorWeight</span> <span class="p">{</span>
	<span class="c1">// for every sector, given its size, start, end, and deals within the sector
</span><span class="c1"></span>	<span class="c1">// assign sector power for the duration of its lifetime
</span><span class="c1"></span>	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">PledgeCollateralReq</span><span class="p">(</span><span class="nx">minerNominalPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">SectorWeightProportion</span><span class="p">(</span><span class="nx">minerActiveSectorWeight</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorWeight</span><span class="p">)</span> <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="c1">// return proportion of SectorWeight for miner
</span><span class="c1"></span>	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">PledgeCollateralProportion</span><span class="p">(</span><span class="nx">minerPledgeCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="c1">// return proportion of Pledge Collateral for miner
</span><span class="c1"></span>	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">StoragePower</span><span class="p">(</span>
	<span class="nx">minerActiveSectorWeight</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorWeight</span><span class="p">,</span>
	<span class="nx">minerInactiveSectorWeight</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorWeight</span><span class="p">,</span>
	<span class="nx">minerPledgeCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="p">{</span>
	<span class="c1">// return StoragePower based on inputs
</span><span class="c1"></span>	<span class="c1">// StoragePower for miner = func(ActiveSectorWeight for miner, PledgeCollateral for miner, global indices)
</span><span class="c1"></span>	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">StoragePowerProportion</span><span class="p">(</span>
	<span class="nx">minerStoragePower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">CurrEpochBlockReward</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="c1">// total block reward allocated for CurrEpoch
</span><span class="c1"></span>	<span class="c1">// each expected winner get an equal share of this reward
</span><span class="c1"></span>	<span class="c1">// computed as a function of NetworkKPI, LastEpochReward, TotalUnmminedFIL, etc
</span><span class="c1"></span>	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">GetCurrBlockRewardRewardForMiner</span><span class="p">(</span>
	<span class="nx">minerStoragePower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span>
	<span class="nx">minerPledgeCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
	<span class="c1">// TODO extend or eliminate
</span><span class="c1"></span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// TerminationFault
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">StoragePower_PledgeSlashForSectorTermination</span><span class="p">(</span>
	<span class="nx">storageWeightDesc</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">SectorStorageWeightDesc</span><span class="p">,</span>
	<span class="nx">terminationType</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">SectorTermination</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// DetectedFault
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">StoragePower_PledgeSlashForSurprisePoStFailure</span><span class="p">(</span>
	<span class="nx">minerClaimedPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span>
	<span class="nx">numConsecutiveFailures</span> <span class="kt">int64</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">StorageMining_PreCommitDeposit</span><span class="p">(</span>
	<span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span>
	<span class="nx">expirationEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">StorageMining_TemporaryFaultFee</span><span class="p">(</span>
	<span class="nx">storageWeightDescs</span> <span class="p">[]</span><span class="nx">actor_util</span><span class="p">.</span><span class="nx">SectorStorageWeightDesc</span><span class="p">,</span>
	<span class="nx">duration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">NetworkTransactionFee</span><span class="p">(</span>
	<span class="nx">toActorCodeID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span>
	<span class="nx">methodNum</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">inds</span> <span class="o">*</span><span class="nx">IndicesImpl</span><span class="p">)</span> <span class="nf">GetCurrBlockRewardForMiner</span><span class="p">(</span>
	<span class="nx">minerStoragePower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span>
	<span class="nx">minerPledgeCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ConsensusPowerForStorageWeight</span><span class="p">(</span>
	<span class="nx">storageWeightDesc</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">SectorStorageWeightDesc</span><span class="p">,</span>
<span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">StorageDeal_ProviderInitTimedOutSlashAmount</span><span class="p">(</span><span class="nx">providerCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="c1">// placeholder
</span><span class="c1"></span>	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">providerCollateral</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">StoragePower_ConsensusMinMinerPower</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">StorageMining_PoStNoChallengePeriod</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">StorageMining_SurprisePoStProvingPeriod</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">StoragePower_SurprisePoStMaxConsecutiveFailures</span><span class="p">()</span> <span class="kt">int64</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">StorageMining_DeclaredFaultEffectiveDelay</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nf">PARAM_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>


  


</div>

  

  
    








<div id="systems__filecoin_vm__message">

<h3 class="section-header">
  VM Message - Actor Method Invocation
</h3>

<div class="section-content">




































<p>A message is the unit of communication between two actors, and thus the primitive cause of changes
in state. A message combines:</p>
<ul>
<li>a token amount to be transferred from the sender to the receiver, and</li>
<li>a method with parameters to be invoked on the receiver (optional).</li>
</ul>
<p>Actor code may send additional messages to other actors while processing a received message.
Messages are processed synchronously: an actor waits for a sent message to complete before resuming control.</p>
<p>The processing of a message consumes units of computation and storage denominated in gas.
A message&rsquo;s gas limit provides an upper bound on its computation. The sender of a message pays
for the gas units consumed by a message&rsquo;s execution (including all nested messages) at a
gas price they determine. A block producer chooses which messages to include in a block and is
rewarded according to each message&rsquo;s gas price and consumption, forming a market.</p>
<div id="systems__filecoin_vm__message__message_syntax"></div>
<h4 id="message-syntax-validation">Message syntax validation</h4>
<p>A syntactically invalid message must not be transmitted, retained in a message pool, or
included in a block.</p>
<p>A syntactically valid <code>UnsignedMessage</code>:</p>
<ul>
<li>has a well-formed, non-empty <code>To</code> address,</li>
<li>has a well-formed, non-empty <code>From</code> address,</li>
<li>has a non-negative <code>CallSeqNum</code>,</li>
<li>has <code>Value</code> no less than zero and no greater than the total token supply (<code>2e9 * 1e18</code>), and</li>
<li>has a non-negative <code>MethodNum</code>,</li>
<li>has non-empty <code>Params</code> only if <code>MethodNum</code> is zero,</li>
<li>has non-negative <code>GasPrice</code>,</li>
<li>has <code>GasLimit</code> that is at least equal to the gas consumption associated with the message&rsquo;s serialized bytes,</li>
<li>has <code>GasLimit</code> that is no greater than the block gas limit network parameter.</li>
</ul>
<p>When transmitted individually (before inclusion in a block), a message is packaged as
<code>SignedMessage</code>, regardless of signature scheme used. A valid signed message:</p>
<ul>
<li>has a total serialized size no greater than <code>message.MessageMaxSize</code>.</li>
</ul>
<h4 id="message-semantic-validation">Message semantic validation</h4>
<p>Semantic validation refers to validation requiring information outside of the message itself.</p>
<p>A semantically valid <code>SignedMessage</code> must carry a signature that verifies the payload as having
been signed with the public key of the account actor identified by the <code>From</code> address.
Note that when the <code>From</code> address is an ID-address, the public key must be
looked up in the state of the sending account actor in the parent state identified by the block.</p>
<p>Note: the sending actor must exist <em>in the parent state identified by the block</em> that includes the message.
This means that it is not valid for a single block to include a message that creates a new account
actor and a message from that same actor.
The first message from that actor must wait until a subsequent epoch.
Message pools may exclude messages from an actor that is not yet present in the chain state.</p>
<p>There is no further semantic validation of a message that can cause a block including the message
to be invalid. Every syntactically valid and correctly signed message can be included in a block and
will produce a receipt from execution.
However, a message may fail to execute to completion, in which case it will not effect the desired state change.</p>
<p>The reason for this &ldquo;no message semantic validation&rdquo; policy is that the state that a message will
be applied to cannot be known before the message is executed <em>as part of a tipset</em>. A block producer
does not know whether another block will precede it in the tipset, thus altering the state to
which the block&rsquo;s messages will apply from the declared parent state.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
<span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>

<span class="c1">// GasAmount is a quantity of gas.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">GasAmount</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">value</span>                <span class="nx">BigInt</span>

    <span class="nf">Add</span><span class="p">(</span><span class="nx">GasAmount</span><span class="p">)</span>       <span class="nx">GasAmount</span>
    <span class="nf">Subtract</span><span class="p">(</span><span class="nx">GasAmount</span><span class="p">)</span>  <span class="nx">GasAmount</span>
    <span class="nf">SubtractIfNonnegative</span><span class="p">(</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="nx">GasAmount</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>
    <span class="nf">LessThan</span><span class="p">(</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">Equals</span><span class="p">(</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">Scale</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="nx">GasAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">UnsignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Address of the receiving actor.
</span><span class="c1"></span>    <span class="nx">To</span>          <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="c1">// Address of the sending actor.
</span><span class="c1"></span>    <span class="nx">From</span>        <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="c1">// Expected CallSeqNum of the sending actor (only for top-level messages).
</span><span class="c1"></span>    <span class="nx">CallSeqNum</span>  <span class="nx">actor</span><span class="p">.</span><span class="nx">CallSeqNum</span>

    <span class="c1">// Amount of value to transfer from sender&#39;s to receiver&#39;s balance.
</span><span class="c1"></span>    <span class="nx">Value</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>

    <span class="c1">// GasPrice is a Gas-to-FIL cost
</span><span class="c1"></span>    <span class="nx">GasPrice</span>    <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">GasLimit</span>    <span class="nx">GasAmount</span>

    <span class="c1">// Optional method to invoke on receiver, zero for a plain value send.
</span><span class="c1"></span>    <span class="nx">Method</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span>
    <span class="c1">/// Serialized parameters to the method (if method is non-zero).
</span><span class="c1"></span>    <span class="nx">Params</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodParams</span>
<span class="p">}</span>  <span class="c1">// representation tuple
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">SignedMessage</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Message</span>    <span class="nx">UnsignedMessage</span>
    <span class="nx">Signature</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>
<span class="p">}</span>  <span class="c1">// representation tuple
</span></code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">message</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">IMPL_FINISH</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">IMPL_FINISH</span>

<span class="kd">type</span> <span class="nx">Serialization</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Serialization</span>

<span class="c1">// The maximum serialized size of a SignedMessage.
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">MessageMaxSize</span> <span class="p">=</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span>

<span class="kd">func</span> <span class="nf">SignedMessage_Make</span><span class="p">(</span><span class="nx">message</span> <span class="nx">UnsignedMessage</span><span class="p">,</span> <span class="nx">signature</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span><span class="p">)</span> <span class="nx">SignedMessage</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SignedMessage_I</span><span class="p">{</span>
		<span class="nx">Message_</span><span class="p">:</span>   <span class="nx">message</span><span class="p">,</span>
		<span class="nx">Signature_</span><span class="p">:</span> <span class="nx">signature</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Sign</span><span class="p">(</span><span class="nx">message</span> <span class="nx">UnsignedMessage</span><span class="p">,</span> <span class="nx">keyPair</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">SigKeyPair</span><span class="p">)</span> <span class="p">(</span><span class="nx">SignedMessage</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sig</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nf">Sign</span><span class="p">(</span><span class="nx">keyPair</span><span class="p">,</span> <span class="nx">util</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(</span><span class="nf">Serialize_UnsignedMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">)))</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">SignedMessage_Make</span><span class="p">(</span><span class="nx">message</span><span class="p">,</span> <span class="nx">sig</span><span class="p">),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SignatureVerificationError</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">message</span> <span class="nx">SignedMessage</span><span class="p">,</span> <span class="nx">publicKey</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">PublicKey</span><span class="p">)</span> <span class="p">(</span><span class="nx">UnsignedMessage</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">m</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(</span><span class="nf">Serialize_UnsignedMessage</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">Message</span><span class="p">()))</span>
	<span class="nx">sigValid</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">publicKey</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Signature</span><span class="p">(),</span> <span class="nx">m</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">sigValid</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nf">SignatureVerificationError</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Message</span><span class="p">(),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">GasAmount_I</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">y</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">GasAmount_I</span><span class="p">)</span> <span class="nf">Subtract</span><span class="p">(</span><span class="nx">y</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">GasAmount_I</span><span class="p">)</span> <span class="nf">SubtractIfNonnegative</span><span class="p">(</span><span class="nx">y</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="nx">GasAmount</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="p">=</span> <span class="nx">x</span><span class="p">.</span><span class="nf">Subtract</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
	<span class="nx">ok</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">if</span> <span class="nx">ret</span><span class="p">.</span><span class="nf">LessThan</span><span class="p">(</span><span class="nf">GasAmount_Zero</span><span class="p">())</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nx">x</span>
		<span class="nx">ok</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">GasAmount_I</span><span class="p">)</span> <span class="nf">LessThan</span><span class="p">(</span><span class="nx">y</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">GasAmount_I</span><span class="p">)</span> <span class="nf">Equals</span><span class="p">(</span><span class="nx">y</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">GasAmount_I</span><span class="p">)</span> <span class="nf">Scale</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GasAmount_Affine</span><span class="p">(</span><span class="nx">b</span> <span class="nx">GasAmount</span><span class="p">,</span> <span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">m</span> <span class="nx">GasAmount</span><span class="p">)</span> <span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">b</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nf">Scale</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GasAmount_Zero</span><span class="p">()</span> <span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">GasAmount_FromInt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GasAmount_FromInt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">GasAmount_SentinelUnlimited</span><span class="p">()</span> <span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="c1">// Amount of gas larger than any feasible execution; meant to indicated unlimited gas
</span><span class="c1"></span>	<span class="c1">// (e.g., for builtin system method invocations).
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">GasAmount_FromInt</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">Scale</span><span class="p">(</span><span class="mf">1e9</span><span class="p">).</span><span class="nf">Scale</span><span class="p">(</span><span class="mf">1e9</span><span class="p">)</span> <span class="c1">// 10^18
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__runtime">

<h3 class="section-header">
  VM Runtime Environment (Inside the VM)
</h3>

<div class="section-content">




































<h4 id="receipts">Receipts</h4>
<p>A <code>MessageReceipt</code> contains the result of a top-level message execution.</p>
<p>A syntactically valid receipt has:</p>
<ul>
<li>a non-negative <code>ExitCode</code>,</li>
<li>a non empty <code>ReturnValue</code> only if the exit code is zero,</li>
<li>a non-negative <code>GasUsed</code>.</li>
</ul>
<h4 id="vmruntime-interface"><code>vm/runtime</code> interface</h4>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">runtime</span>

<span class="kn">import</span> <span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors&#34;</span>
<span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">crypto</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/exitcode&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">indices</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&#34;</span>
<span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>

<span class="c1">// Runtime is the VM&#39;s internal runtime object.
</span><span class="c1">// this is everything that is accessible to actors, beyond parameters.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Runtime</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">CurrEpoch</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>

	<span class="c1">// Randomness returns a (pseudo)random string for the given epoch and tag.
</span><span class="c1"></span>	<span class="nf">GetRandomness</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span>

	<span class="c1">// The address of the immediate calling actor.
</span><span class="c1"></span>	<span class="c1">// Not necessarily the actor in the From field of the initial on-chain Message.
</span><span class="c1"></span>	<span class="c1">// Always an ID-address.
</span><span class="c1"></span>	<span class="nf">ImmediateCaller</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">caller</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
	<span class="nf">ValidateImmediateCallerInSet</span><span class="p">(</span><span class="nx">callers</span> <span class="p">[]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>
	<span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">type_</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">)</span>
	<span class="nf">ValidateImmediateCallerAcceptAnyOfTypes</span><span class="p">(</span><span class="nx">types</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">)</span>
	<span class="nf">ValidateImmediateCallerAcceptAny</span><span class="p">()</span>
	<span class="nf">ValidateImmediateCallerMatches</span><span class="p">(</span><span class="nx">CallerPattern</span><span class="p">)</span>

	<span class="c1">// The address of the actor receiving the message. Always an ID-address.
</span><span class="c1"></span>	<span class="nf">CurrReceiver</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="c1">// The actor who mined the block in which the initial on-chain message appears.
</span><span class="c1"></span>	<span class="c1">// Always an ID-address.
</span><span class="c1"></span>	<span class="nf">ToplevelBlockWinner</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="nf">AcquireState</span><span class="p">()</span> <span class="nx">ActorStateHandle</span>

	<span class="nf">SuccessReturn</span><span class="p">()</span> <span class="nx">InvocOutput</span>
	<span class="nf">ValueReturn</span><span class="p">([]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">InvocOutput</span>

	<span class="c1">// Throw an error indicating a failure condition has occurred, from which the given actor
</span><span class="c1"></span>	<span class="c1">// code is unable to recover.
</span><span class="c1"></span>	<span class="nf">Abort</span><span class="p">(</span><span class="nx">errExitCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span>

	<span class="c1">// Calls Abort with InvalidArguments_User.
</span><span class="c1"></span>	<span class="nf">AbortArgMsg</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span>
	<span class="nf">AbortArg</span><span class="p">()</span>

	<span class="c1">// Calls Abort with InconsistentState_User.
</span><span class="c1"></span>	<span class="nf">AbortStateMsg</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span>
	<span class="nf">AbortState</span><span class="p">()</span>

	<span class="c1">// Calls Abort with InsufficientFunds_User.
</span><span class="c1"></span>	<span class="nf">AbortFundsMsg</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span>
	<span class="nf">AbortFunds</span><span class="p">()</span>

	<span class="c1">// Calls Abort with RuntimeAPIError.
</span><span class="c1"></span>	<span class="c1">// For internal use only (not in actor code).
</span><span class="c1"></span>	<span class="nf">AbortAPI</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span>

	<span class="c1">// Check that the given condition is true (and call Abort if not).
</span><span class="c1"></span>	<span class="nf">Assert</span><span class="p">(</span><span class="kt">bool</span><span class="p">)</span>

	<span class="nf">CurrentBalance</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nf">ValueReceived</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>

	<span class="c1">// Look up the current values of several system-wide economic indices.
</span><span class="c1"></span>	<span class="nf">CurrIndices</span><span class="p">()</span> <span class="nx">indices</span><span class="p">.</span><span class="nx">Indices</span>

	<span class="c1">// Look up the code ID of a given actor address.
</span><span class="c1"></span>	<span class="nf">GetActorCodeID</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span>

	<span class="c1">// Run a (pure function) computation, consuming the gas cost associated with that function.
</span><span class="c1"></span>	<span class="c1">// This mechanism is intended to capture the notion of an ABI between the VM and native
</span><span class="c1"></span>	<span class="c1">// functions, and should be used for any function whose computation is expensive.
</span><span class="c1"></span>	<span class="nf">Compute</span><span class="p">(</span><span class="nx">ComputeFunctionID</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>

	<span class="c1">// Sends a message to another actor.
</span><span class="c1"></span>	<span class="c1">// If the invoked method does not return successfully, this caller will be aborted too.
</span><span class="c1"></span>	<span class="nf">SendPropagatingErrors</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">)</span> <span class="nx">InvocOutput</span>
	<span class="nf">Send</span><span class="p">(</span>
		<span class="nx">toAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
		<span class="nx">methodNum</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span>
		<span class="nx">params</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">,</span>
		<span class="nx">value</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
	<span class="p">)</span> <span class="nx">InvocOutput</span>
	<span class="nf">SendQuery</span><span class="p">(</span>
		<span class="nx">toAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
		<span class="nx">methodNum</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span>
		<span class="nx">params</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">,</span>
	<span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nf">SendFunds</span><span class="p">(</span><span class="nx">toAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>

	<span class="c1">// Sends a message to another actor, trapping an unsuccessful execution.
</span><span class="c1"></span>	<span class="c1">// This may only be invoked by the singleton Cron actor.
</span><span class="c1"></span>	<span class="nf">SendCatchingErrors</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">)</span> <span class="p">(</span><span class="nx">output</span> <span class="nx">InvocOutput</span><span class="p">,</span> <span class="nx">exitCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">)</span>

	<span class="c1">// Computes an address for a new actor. The returned address is intended to uniquely refer to
</span><span class="c1"></span>	<span class="c1">// the actor even in the event of a chain re-org (whereas an ID-address might refer to a
</span><span class="c1"></span>	<span class="c1">// different actor after messages are re-ordered).
</span><span class="c1"></span>	<span class="c1">// Always an ActorExec address.
</span><span class="c1"></span>	<span class="nf">NewActorAddress</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>

	<span class="c1">// Creates an actor in the state tree, with empty state. May only be called by InitActor.
</span><span class="c1"></span>	<span class="nf">CreateActor</span><span class="p">(</span>
		<span class="c1">// The new actor&#39;s code identifier.
</span><span class="c1"></span>		<span class="nx">codeId</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span>
		<span class="c1">// Address under which the new actor&#39;s state will be stored. Must be an ID-address.
</span><span class="c1"></span>		<span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="p">)</span>

	<span class="c1">// Deletes an actor in the state tree. May only be called by the actor itself,
</span><span class="c1"></span>	<span class="c1">// or by StoragePowerActor in the case of StorageMinerActors.
</span><span class="c1"></span>	<span class="nf">DeleteActor</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span>

	<span class="c1">// Retrieves and deserializes an object from the store into o. Returns whether successful.
</span><span class="c1"></span>	<span class="nf">IpldGet</span><span class="p">(</span><span class="nx">c</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span><span class="p">,</span> <span class="nx">o</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">bool</span>
	<span class="c1">// Serializes and stores an object, returning its CID.
</span><span class="c1"></span>	<span class="nf">IpldPut</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>

	<span class="c1">// Provides the system call interface.
</span><span class="c1"></span>	<span class="nf">Syscalls</span><span class="p">()</span> <span class="nx">Syscalls</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Syscalls</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="c1">// Verifies that a signature is valid for an address and plaintext.
</span><span class="c1"></span>	<span class="nf">VerifySignature</span><span class="p">(</span>
		<span class="nx">signature</span> <span class="nx">crypto</span><span class="p">.</span><span class="nx">Signature</span><span class="p">,</span>
		<span class="nx">signer</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
		<span class="nx">plaintext</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span>
	<span class="p">)</span> <span class="kt">bool</span>
	<span class="c1">// Computes an unsealed sector CID (CommD) from its constituent piece CIDs (CommPs) and sizes.
</span><span class="c1"></span>	<span class="nf">ComputeUnsealedSectorCID</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">pieces</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
	<span class="c1">// Verifies a sector seal proof.
</span><span class="c1"></span>	<span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">vi</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>
	<span class="c1">// Verifies a proof of spacetime.
</span><span class="c1"></span>	<span class="nf">VerifyPoSt</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">vi</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">InvocInput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">To</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">Method</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span>
	<span class="nx">Params</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodParams</span>
	<span class="nx">Value</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ReturnValue</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ActorStateHandle</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newStateCID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSubstateCID</span><span class="p">)</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">checkStateCID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSubstateCID</span><span class="p">)</span>
	<span class="nf">Take</span><span class="p">()</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSubstateCID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ComputeFunctionID</span> <span class="kt">int64</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">Compute_VerifySignature</span> <span class="p">=</span> <span class="nf">ComputeFunctionID</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div>





<h4 id="vmruntime-implementation"><code>vm/runtime</code> implementation</h4>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">impl</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;encoding/binary&#34;</span>
	<span class="s">&#34;fmt&#34;</span>

	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">acctact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/account&#34;</span>
	<span class="nx">initact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/init&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
	<span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/exitcode&#34;</span>
	<span class="nx">indices</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&#34;</span>
	<span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
	<span class="nx">chain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/chain&#34;</span>
	<span class="nx">actstate</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
	<span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
	<span class="nx">gascost</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/gascost&#34;</span>
	<span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
	<span class="nx">cbornode</span> <span class="s">&#34;github.com/ipfs/go-ipld-cbor&#34;</span>
	<span class="nx">mh</span> <span class="s">&#34;github.com/multiformats/go-multihash&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">ActorSubstateCID</span> <span class="p">=</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSubstateCID</span>
<span class="kd">type</span> <span class="nx">ExitCode</span> <span class="p">=</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span>
<span class="kd">type</span> <span class="nx">CallerPattern</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">CallerPattern</span>
<span class="kd">type</span> <span class="nx">Runtime</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span>
<span class="kd">type</span> <span class="nx">InvocInput</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span>
<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="kd">type</span> <span class="nx">ActorStateHandle</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span>

<span class="kd">var</span> <span class="nx">EnsureErrorCode</span> <span class="p">=</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">EnsureErrorCode</span>

<span class="kd">type</span> <span class="nx">Bytes</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>

<span class="kd">var</span> <span class="nx">Assert</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Assert</span>
<span class="kd">var</span> <span class="nx">IMPL_FINISH</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">IMPL_FINISH</span>
<span class="kd">var</span> <span class="nx">IMPL_TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">IMPL_TODO</span>
<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">TODO</span>

<span class="kd">var</span> <span class="nx">EmptyCBOR</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>

<span class="kd">type</span> <span class="nx">RuntimeError</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ExitCode</span> <span class="nx">ExitCode</span>
	<span class="nx">ErrMsg</span>   <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cbornode</span><span class="p">.</span><span class="nf">WrapObject</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">struct</span><span class="p">{}{},</span> <span class="nx">mh</span><span class="p">.</span><span class="nx">SHA2_256</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">EmptyCBOR</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nf">Cid</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">RuntimeError</span><span class="p">)</span> <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;Runtime error: %v&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ErrMsg</span> <span class="o">!=</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="o">+=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34; (\&#34;%v\&#34;)&#34;</span><span class="p">,</span> <span class="nx">x</span><span class="p">.</span><span class="nx">ErrMsg</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RuntimeError_Make</span><span class="p">(</span><span class="nx">exitCode</span> <span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">errMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">RuntimeError</span> <span class="p">{</span>
	<span class="nx">exitCode</span> <span class="p">=</span> <span class="nf">EnsureErrorCode</span><span class="p">(</span><span class="nx">exitCode</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RuntimeError</span><span class="p">{</span>
		<span class="nx">ExitCode</span><span class="p">:</span> <span class="nx">exitCode</span><span class="p">,</span>
		<span class="nx">ErrMsg</span><span class="p">:</span>   <span class="nx">errMsg</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ActorSubstateCID_Equals</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ActorStateHandle_I</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">_initValue</span> <span class="o">*</span><span class="nx">ActorSubstateCID</span>
	<span class="nx">_rt</span>        <span class="o">*</span><span class="nx">VMContext</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">ActorStateHandle_I</span><span class="p">)</span> <span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newStateCID</span> <span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">_rt</span><span class="p">.</span><span class="nf">_updateReleaseActorSubstate</span><span class="p">(</span><span class="nx">newStateCID</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">ActorStateHandle_I</span><span class="p">)</span> <span class="nf">Release</span><span class="p">(</span><span class="nx">checkStateCID</span> <span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">_rt</span><span class="p">.</span><span class="nf">_releaseActorSubstate</span><span class="p">(</span><span class="nx">checkStateCID</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">ActorStateHandle_I</span><span class="p">)</span> <span class="nf">Take</span><span class="p">()</span> <span class="nx">ActorSubstateCID</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">_initValue</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">_rt</span><span class="p">.</span><span class="nf">_apiError</span><span class="p">(</span><span class="s">&#34;Must call Take() only once on actor substate object&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">h</span><span class="p">.</span><span class="nx">_initValue</span>
	<span class="nx">h</span><span class="p">.</span><span class="nx">_initValue</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="c1">// Concrete instantiation of the Runtime interface. This should be instantiated by the
</span><span class="c1">// interpreter once per actor method invocation, and responds to that method&#39;s Runtime
</span><span class="c1">// API calls.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">VMContext</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">_store</span>              <span class="nx">ipld</span><span class="p">.</span><span class="nx">GraphStore</span>
	<span class="nx">_globalStateInit</span>    <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
	<span class="nx">_globalStatePending</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
	<span class="nx">_running</span>            <span class="kt">bool</span>
	<span class="nx">_chain</span>              <span class="nx">chain</span><span class="p">.</span><span class="nx">Chain</span>
	<span class="nx">_actorAddress</span>       <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">_actorStateAcquired</span> <span class="kt">bool</span>
	<span class="c1">// Tracks whether actor substate has changed in order to charge gas just once
</span><span class="c1"></span>	<span class="c1">// regardless of how many times it&#39;s written.
</span><span class="c1"></span>	<span class="nx">_actorSubstateUpdated</span> <span class="kt">bool</span>

	<span class="nx">_immediateCaller</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="c1">// Note: This is the actor in the From field of the initial on-chain message.
</span><span class="c1"></span>	<span class="c1">// Not necessarily the immediate caller.
</span><span class="c1"></span>	<span class="nx">_toplevelSender</span>      <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">_toplevelBlockWinner</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="c1">// call sequence number of the top level message that began this execution sequence
</span><span class="c1"></span>	<span class="nx">_toplevelMsgCallSeqNum</span> <span class="nx">actstate</span><span class="p">.</span><span class="nx">CallSeqNum</span>
	<span class="c1">// Sequence number representing the total number of calls (to any actor, any method)
</span><span class="c1"></span>	<span class="c1">// during the current top-level message execution.
</span><span class="c1"></span>	<span class="c1">// Note: resets with every top-level message, and therefore not necessarily monotonic.
</span><span class="c1"></span>	<span class="nx">_internalCallSeqNum</span> <span class="nx">actstate</span><span class="p">.</span><span class="nx">CallSeqNum</span>
	<span class="nx">_valueReceived</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">_gasRemaining</span>       <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span>
	<span class="nx">_numValidateCalls</span>   <span class="kt">int</span>
	<span class="nx">_output</span>             <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">VMContext_Make</span><span class="p">(</span>
	<span class="nx">store</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">GraphStore</span><span class="p">,</span>
	<span class="nx">chain</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span>
	<span class="nx">toplevelSender</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">toplevelBlockWinner</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">toplevelMsgCallSeqNum</span> <span class="nx">actstate</span><span class="p">.</span><span class="nx">CallSeqNum</span><span class="p">,</span>
	<span class="nx">internalCallSeqNum</span> <span class="nx">actstate</span><span class="p">.</span><span class="nx">CallSeqNum</span><span class="p">,</span>
	<span class="nx">globalState</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span>
	<span class="nx">actorAddress</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">valueReceived</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
	<span class="nx">gasRemaining</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="o">*</span><span class="nx">VMContext</span> <span class="p">{</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">VMContext</span><span class="p">{</span>
		<span class="nx">_store</span><span class="p">:</span>                <span class="nx">store</span><span class="p">,</span>
		<span class="nx">_chain</span><span class="p">:</span>                <span class="nx">chain</span><span class="p">,</span>
		<span class="nx">_globalStateInit</span><span class="p">:</span>      <span class="nx">globalState</span><span class="p">,</span>
		<span class="nx">_globalStatePending</span><span class="p">:</span>   <span class="nx">globalState</span><span class="p">,</span>
		<span class="nx">_running</span><span class="p">:</span>              <span class="kc">false</span><span class="p">,</span>
		<span class="nx">_actorAddress</span><span class="p">:</span>         <span class="nx">actorAddress</span><span class="p">,</span>
		<span class="nx">_actorStateAcquired</span><span class="p">:</span>   <span class="kc">false</span><span class="p">,</span>
		<span class="nx">_actorSubstateUpdated</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>

		<span class="nx">_toplevelSender</span><span class="p">:</span>        <span class="nx">toplevelSender</span><span class="p">,</span>
		<span class="nx">_toplevelBlockWinner</span><span class="p">:</span>   <span class="nx">toplevelBlockWinner</span><span class="p">,</span>
		<span class="nx">_toplevelMsgCallSeqNum</span><span class="p">:</span> <span class="nx">toplevelMsgCallSeqNum</span><span class="p">,</span>
		<span class="nx">_internalCallSeqNum</span><span class="p">:</span>    <span class="nx">internalCallSeqNum</span><span class="p">,</span>
		<span class="nx">_valueReceived</span><span class="p">:</span>         <span class="nx">valueReceived</span><span class="p">,</span>
		<span class="nx">_gasRemaining</span><span class="p">:</span>          <span class="nx">gasRemaining</span><span class="p">,</span>
		<span class="nx">_numValidateCalls</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>
		<span class="nx">_output</span><span class="p">:</span>                <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span><span class="p">{},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">AbortArgMsg</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidArguments_User</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">AbortArg</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Invalid arguments&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">AbortStateMsg</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InconsistentState_User</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">AbortState</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Inconsistent state&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">AbortFundsMsg</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InsufficientFunds_User</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">AbortFunds</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortFundsMsg</span><span class="p">(</span><span class="s">&#34;Insufficient funds&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">AbortAPI</span><span class="p">(</span><span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">RuntimeAPIError</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">CreateActor</span><span class="p">(</span><span class="nx">codeID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span> <span class="o">!=</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">InitActorAddr</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;Only InitActor may call rt.CreateActor&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">address</span><span class="p">.</span><span class="nf">Protocol</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">ID</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;New actor adddress must be an ID-address&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">_createActor</span><span class="p">(</span><span class="nx">codeID</span><span class="p">,</span> <span class="nx">address</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_createActor</span><span class="p">(</span><span class="nx">codeID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Create empty actor state.
</span><span class="c1"></span>	<span class="nx">actorState</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">actstate</span><span class="p">.</span><span class="nx">ActorState_I</span><span class="p">{</span>
		<span class="nx">CodeID_</span><span class="p">:</span>     <span class="nx">codeID</span><span class="p">,</span>
		<span class="nx">State_</span><span class="p">:</span>      <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">EmptyCBOR</span><span class="p">),</span>
		<span class="nx">Balance_</span><span class="p">:</span>    <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">CallSeqNum_</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// Put it in the state tree.
</span><span class="c1"></span>	<span class="nx">actorStateCID</span> <span class="o">:=</span> <span class="nx">actstate</span><span class="p">.</span><span class="nf">ActorSystemStateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">actorState</span><span class="p">))</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_updateActorSystemStateInternal</span><span class="p">(</span><span class="nx">address</span><span class="p">,</span> <span class="nx">actorStateCID</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">_rtAllocGas</span><span class="p">(</span><span class="nx">gascost</span><span class="p">.</span><span class="nx">ExecNewActor</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">DeleteActor</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Only a given actor may delete itself.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span> <span class="o">!=</span> <span class="nx">address</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;Invalid actor deletion request&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">_deleteActor</span><span class="p">(</span><span class="nx">address</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_deleteActor</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithDeleteActorSystemState</span><span class="p">(</span><span class="nx">address</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_rtAllocGas</span><span class="p">(</span><span class="nx">gascost</span><span class="p">.</span><span class="nx">DeleteActor</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_updateActorSystemStateInternal</span><span class="p">(</span><span class="nx">actorAddress</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">newStateCID</span> <span class="nx">actstate</span><span class="p">.</span><span class="nx">ActorSystemStateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newGlobalStatePending</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithActorSystemState</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">,</span> <span class="nx">newStateCID</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Error in runtime implementation: failed to update actor system state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span> <span class="p">=</span> <span class="nx">newGlobalStatePending</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_updateActorSubstateInternal</span><span class="p">(</span><span class="nx">actorAddress</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">newStateCID</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newGlobalStatePending</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithActorSubstate</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">,</span> <span class="nx">newStateCID</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Error in runtime implementation: failed to update actor substate&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span> <span class="p">=</span> <span class="nx">newGlobalStatePending</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_updateReleaseActorSubstate</span><span class="p">(</span><span class="nx">newStateCID</span> <span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkActorStateAcquired</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_updateActorSubstateInternal</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">,</span> <span class="nx">newStateCID</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_actorSubstateUpdated</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_actorStateAcquired</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_releaseActorSubstate</span><span class="p">(</span><span class="nx">checkStateCID</span> <span class="nx">ActorSubstateCID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkActorStateAcquired</span><span class="p">()</span>

	<span class="nx">prevState</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">prevStateCID</span> <span class="o">:=</span> <span class="nx">prevState</span><span class="p">.</span><span class="nf">State</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">ActorSubstateCID_Equals</span><span class="p">(</span><span class="nx">prevStateCID</span><span class="p">,</span> <span class="nx">checkStateCID</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;State CID differs upon release call&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nx">_actorStateAcquired</span> <span class="p">=</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">Assert</span><span class="p">(</span><span class="nx">cond</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">cond</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Abort</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">RuntimeAssertFailure</span><span class="p">,</span> <span class="s">&#34;Runtime assertion failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_checkActorStateAcquiredFlag</span><span class="p">(</span><span class="nx">expected</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_actorStateAcquired</span> <span class="o">!=</span> <span class="nx">expected</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">_apiError</span><span class="p">(</span><span class="s">&#34;State updates and message sends must be disjoint&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_checkActorStateAcquired</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkActorStateAcquiredFlag</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_checkActorStateNotAcquired</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkActorStateAcquiredFlag</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">Abort</span><span class="p">(</span><span class="nx">errExitCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">errMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">errExitCode</span> <span class="p">=</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nf">EnsureErrorCode</span><span class="p">(</span><span class="nx">errExitCode</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_throwErrorFull</span><span class="p">(</span><span class="nx">errExitCode</span><span class="p">,</span> <span class="nx">errMsg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ImmediateCaller</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_immediateCaller</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">CurrReceiver</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ToplevelBlockWinner</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_toplevelBlockWinner</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValidateImmediateCallerMatches</span><span class="p">(</span>
	<span class="nx">callerExpectedPattern</span> <span class="nx">CallerPattern</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkNumValidateCalls</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">caller</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">callerExpectedPattern</span><span class="p">.</span><span class="nf">Matches</span><span class="p">(</span><span class="nx">caller</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;Method invoked by incorrect caller&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_numValidateCalls</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CallerPattern_MakeAcceptAnyOfTypes</span><span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">,</span> <span class="nx">types</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">)</span> <span class="nx">CallerPattern</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">CallerPattern</span><span class="p">{</span>
		<span class="nx">Matches</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">y</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="nx">codeID</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">GetActorCodeID</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Internal runtime error: actor not found&#34;</span><span class="p">)</span>
			<span class="p">}</span>

			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">type_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">types</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">codeID</span> <span class="o">==</span> <span class="nx">type_</span> <span class="p">{</span>
					<span class="k">return</span> <span class="kc">true</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">},</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">callerExpected</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerMatches</span><span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nf">CallerPattern_MakeSingleton</span><span class="p">(</span><span class="nx">callerExpected</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValidateImmediateCallerInSet</span><span class="p">(</span><span class="nx">callersExpected</span> <span class="p">[]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerMatches</span><span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nf">CallerPattern_MakeSet</span><span class="p">(</span><span class="nx">callersExpected</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">type_</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfTypes</span><span class="p">([]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">{</span><span class="nx">type_</span><span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValidateImmediateCallerAcceptAnyOfTypes</span><span class="p">(</span><span class="nx">types</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerMatches</span><span class="p">(</span><span class="nf">CallerPattern_MakeAcceptAnyOfTypes</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">types</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValidateImmediateCallerAcceptAny</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerMatches</span><span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nf">CallerPattern_MakeAcceptAny</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_checkNumValidateCalls</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_numValidateCalls</span> <span class="o">!=</span> <span class="nx">x</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;Method must validate caller identity exactly once&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_checkRunning</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Internal runtime error: actor API called with no actor code running&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">SuccessReturn</span><span class="p">()</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValueReturn</span><span class="p">(</span><span class="nx">value</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitCode</span> <span class="nx">ExitCode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_throwErrorFull</span><span class="p">(</span><span class="nx">exitCode</span><span class="p">,</span> <span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_throwErrorFull</span><span class="p">(</span><span class="nx">exitCode</span> <span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">errMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="nf">RuntimeError_Make</span><span class="p">(</span><span class="nx">exitCode</span><span class="p">,</span> <span class="nx">errMsg</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_apiError</span><span class="p">(</span><span class="nx">errMsg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_throwErrorFull</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">RuntimeAPIError</span><span class="p">,</span> <span class="nx">errMsg</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_gasAmountAssertValid</span><span class="p">(</span><span class="nx">x</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">x</span><span class="p">.</span><span class="nf">LessThan</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Zero</span><span class="p">())</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Interpreter error: negative gas amount&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Deduct an amount of gas corresponding to cost about to be incurred, but not necessarily
</span><span class="c1">// incurred yet.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_rtAllocGas</span><span class="p">(</span><span class="nx">x</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">_gasAmountAssertValid</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_gasRemaining</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_gasRemaining</span><span class="p">.</span><span class="nf">SubtractIfNonnegative</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">OutOfGas</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_transferFunds</span><span class="p">(</span><span class="nx">from</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">to</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkActorStateNotAcquired</span><span class="p">()</span>

	<span class="nx">newGlobalStatePending</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithFundsTransfer</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span> <span class="p">=</span> <span class="nx">newGlobalStatePending</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">GetActorCodeID</span><span class="p">(</span><span class="nx">actorAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ErrorHandlingSpec</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">PropagateErrors</span> <span class="nx">ErrorHandlingSpec</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="kc">iota</span>
	<span class="nx">CatchErrors</span>
<span class="p">)</span>

<span class="c1">// TODO: This function should be private (not intended to be exposed to actors).
</span><span class="c1">// (merging runtime and interpreter packages should solve this)
</span><span class="c1">// TODO: this should not use the MessageReceipt return type, even though it needs the same triple
</span><span class="c1">// of values. This method cannot compute the total gas cost and the returned receipt will never
</span><span class="c1">// go on chain.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">SendToplevelFromInterpreter</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">)</span> <span class="p">(</span><span class="nx">MessageReceipt</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">_sendInternal</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">CatchErrors</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="k">return</span> <span class="nx">ret</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_catchRuntimeErrors</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">InvocOutput</span><span class="p">)</span> <span class="p">(</span><span class="nx">output</span> <span class="nx">InvocOutput</span><span class="p">,</span> <span class="nx">exitCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="nx">r</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="o">*</span><span class="nx">RuntimeError</span><span class="p">:</span>
				<span class="nx">output</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
				<span class="nx">exitCode</span> <span class="p">=</span> <span class="p">(</span><span class="nx">r</span><span class="p">.(</span><span class="o">*</span><span class="nx">RuntimeError</span><span class="p">).</span><span class="nx">ExitCode</span><span class="p">)</span>
			<span class="k">default</span><span class="p">:</span>
				<span class="nb">panic</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="nx">output</span> <span class="p">=</span> <span class="nf">f</span><span class="p">()</span>
	<span class="nx">exitCode</span> <span class="p">=</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nf">OK</span><span class="p">()</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_invokeMethodInternal</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">,</span>
	<span class="nx">actorCode</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span><span class="p">,</span>
	<span class="nx">method</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span>
	<span class="nx">params</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">ret</span> <span class="nx">InvocOutput</span><span class="p">,</span> <span class="nx">exitCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">internalCallSeqNumFinal</span> <span class="nx">actstate</span><span class="p">.</span><span class="nx">CallSeqNum</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">if</span> <span class="nx">method</span> <span class="o">==</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">MethodSend</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">ret</span><span class="p">,</span> <span class="nx">exitCode</span> <span class="p">=</span> <span class="nf">_catchRuntimeErrors</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
		<span class="nf">IMPL_TODO</span><span class="p">(</span><span class="s">&#34;dispatch to actor code&#34;</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">methodOutput</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span> <span class="c1">// actorCode.InvokeMethod(rt, method, params)
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_actorSubstateUpdated</span> <span class="p">{</span>
			<span class="nx">rt</span><span class="p">.</span><span class="nf">_rtAllocGas</span><span class="p">(</span><span class="nx">gascost</span><span class="p">.</span><span class="nx">UpdateActorSubstate</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkActorStateNotAcquired</span><span class="p">()</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkNumValidateCalls</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">methodOutput</span>
	<span class="p">})</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_running</span> <span class="p">=</span> <span class="kc">false</span>

	<span class="nx">internalCallSeqNumFinal</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_internalCallSeqNum</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rtOuter</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_sendInternal</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">,</span> <span class="nx">errSpec</span> <span class="nx">ErrorHandlingSpec</span><span class="p">)</span> <span class="nx">MessageReceipt</span> <span class="p">{</span>
	<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_checkActorStateNotAcquired</span><span class="p">()</span>

	<span class="nx">initGasRemaining</span> <span class="o">:=</span> <span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_gasRemaining</span>

	<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_rtAllocGas</span><span class="p">(</span><span class="nx">gascost</span><span class="p">.</span><span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Method</span><span class="p">))</span>

	<span class="nx">receiver</span><span class="p">,</span> <span class="nx">receiverAddr</span> <span class="o">:=</span> <span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_resolveReceiver</span><span class="p">(</span><span class="nx">input</span><span class="p">.</span><span class="nx">To</span><span class="p">)</span>
	<span class="nx">receiverCode</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">loadActorCode</span><span class="p">(</span><span class="nx">receiver</span><span class="p">.</span><span class="nf">CodeID</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">ActorCodeNotFound</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_transferFunds</span><span class="p">(</span><span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">,</span> <span class="nx">receiverAddr</span><span class="p">,</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">InsufficientFunds_System</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rtInner</span> <span class="o">:=</span> <span class="nf">VMContext_Make</span><span class="p">(</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_store</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_chain</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_toplevelSender</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_toplevelBlockWinner</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_toplevelMsgCallSeqNum</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_internalCallSeqNum</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">,</span>
		<span class="nx">receiverAddr</span><span class="p">,</span>
		<span class="nx">input</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_gasRemaining</span><span class="p">,</span>
	<span class="p">)</span>

	<span class="nx">invocOutput</span><span class="p">,</span> <span class="nx">exitCode</span><span class="p">,</span> <span class="nx">internalCallSeqNumFinal</span> <span class="o">:=</span> <span class="nf">_invokeMethodInternal</span><span class="p">(</span>
		<span class="nx">rtInner</span><span class="p">,</span>
		<span class="nx">receiverCode</span><span class="p">,</span>
		<span class="nx">input</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span>
		<span class="nx">input</span><span class="p">.</span><span class="nx">Params</span><span class="p">,</span>
	<span class="p">)</span>

	<span class="nf">_gasAmountAssertValid</span><span class="p">(</span><span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_gasRemaining</span><span class="p">.</span><span class="nf">Subtract</span><span class="p">(</span><span class="nx">rtInner</span><span class="p">.</span><span class="nx">_gasRemaining</span><span class="p">))</span>
	<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_gasRemaining</span> <span class="p">=</span> <span class="nx">rtInner</span><span class="p">.</span><span class="nx">_gasRemaining</span>
	<span class="nx">gasUsed</span> <span class="o">:=</span> <span class="nx">initGasRemaining</span><span class="p">.</span><span class="nf">Subtract</span><span class="p">(</span><span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_gasRemaining</span><span class="p">)</span>
	<span class="nf">_gasAmountAssertValid</span><span class="p">(</span><span class="nx">gasUsed</span><span class="p">)</span>

	<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_internalCallSeqNum</span> <span class="p">=</span> <span class="nx">internalCallSeqNumFinal</span>

	<span class="k">if</span> <span class="nx">exitCode</span> <span class="o">==</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">OutOfGas</span> <span class="p">{</span>
		<span class="c1">// OutOfGas error cannot be caught
</span><span class="c1"></span>		<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitCode</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">errSpec</span> <span class="o">==</span> <span class="nx">PropagateErrors</span> <span class="o">&amp;&amp;</span> <span class="nx">exitCode</span><span class="p">.</span><span class="nf">IsError</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">MethodSubcallError</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">exitCode</span><span class="p">.</span><span class="nf">AllowsStateUpdate</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rtOuter</span><span class="p">.</span><span class="nx">_globalStatePending</span> <span class="p">=</span> <span class="nx">rtInner</span><span class="p">.</span><span class="nx">_globalStatePending</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">MessageReceipt_Make</span><span class="p">(</span><span class="nx">invocOutput</span><span class="p">,</span> <span class="nx">exitCode</span><span class="p">,</span> <span class="nx">gasUsed</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Loads a receiving actor state from the state tree, resolving non-ID addresses through the InitActor state.
</span><span class="c1">// If it doesn&#39;t exist, and the message is a simple value send to a pubkey-style address,
</span><span class="c1">// creates the receiver as an account actor in the returned state.
</span><span class="c1">// Aborts otherwise.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_resolveReceiver</span><span class="p">(</span><span class="nx">targetRaw</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span><span class="nx">actstate</span><span class="p">.</span><span class="nx">ActorState</span><span class="p">,</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Resolve the target address via the InitActor, and attempt to load state.
</span><span class="c1"></span>	<span class="nx">initSubState</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">_loadInitActorState</span><span class="p">()</span>
	<span class="nx">targetIdAddr</span> <span class="o">:=</span> <span class="nx">initSubState</span><span class="p">.</span><span class="nf">ResolveAddress</span><span class="p">(</span><span class="nx">targetRaw</span><span class="p">)</span>
	<span class="nx">act</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">targetIdAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">act</span><span class="p">,</span> <span class="nx">targetIdAddr</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">targetRaw</span><span class="p">.</span><span class="nf">Protocol</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">SECP256K1</span> <span class="o">&amp;&amp;</span> <span class="nx">targetRaw</span><span class="p">.</span><span class="nf">Protocol</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">BLS</span> <span class="p">{</span>
		<span class="c1">// Don&#39;t implicitly create an account actor for an address without an associated key.
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">_throwError</span><span class="p">(</span><span class="nx">exitcode</span><span class="p">.</span><span class="nx">ActorNotFound</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Allocate an ID address from the init actor and map the pubkey To address to it.
</span><span class="c1"></span>	<span class="nx">newIdAddr</span> <span class="o">:=</span> <span class="nx">initSubState</span><span class="p">.</span><span class="nf">MapAddressToNewID</span><span class="p">(</span><span class="nx">targetRaw</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_saveInitActorState</span><span class="p">(</span><span class="nx">initSubState</span><span class="p">)</span>

	<span class="c1">// Create new account actor (charges gas).
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">_createActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">AccountActorCodeID</span><span class="p">,</span> <span class="nx">newIdAddr</span><span class="p">)</span>

	<span class="c1">// Initialize account actor substate with it&#39;s pubkey address.
</span><span class="c1"></span>	<span class="nx">substate</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">acctact</span><span class="p">.</span><span class="nx">AccountActorState</span><span class="p">{</span>
		<span class="nx">Address</span><span class="p">:</span> <span class="nx">targetRaw</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_saveAccountActorState</span><span class="p">(</span><span class="nx">newIdAddr</span><span class="p">,</span> <span class="o">*</span><span class="nx">substate</span><span class="p">)</span>
	<span class="nx">act</span><span class="p">,</span> <span class="nx">_</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">newIdAddr</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">act</span><span class="p">,</span> <span class="nx">newIdAddr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_loadInitActorState</span><span class="p">()</span> <span class="nx">initact</span><span class="p">.</span><span class="nx">InitActorState</span> <span class="p">{</span>
	<span class="nx">initState</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">InitActorAddr</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">initSubState</span> <span class="nx">initact</span><span class="p">.</span><span class="nx">InitActorState</span>
	<span class="nx">ok</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">initState</span><span class="p">.</span><span class="nf">State</span><span class="p">()),</span> <span class="o">&amp;</span><span class="nx">initSubState</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">initSubState</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_saveInitActorState</span><span class="p">(</span><span class="nx">state</span> <span class="nx">initact</span><span class="p">.</span><span class="nx">InitActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Gas is charged here separately from _actorSubstateUpdated because this is a different actor
</span><span class="c1"></span>	<span class="c1">// than the receiver.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">_rtAllocGas</span><span class="p">(</span><span class="nx">gascost</span><span class="p">.</span><span class="nx">UpdateActorSubstate</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_updateActorSubstateInternal</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">InitActorAddr</span><span class="p">,</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">state</span><span class="p">)))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_saveAccountActorState</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">state</span> <span class="nx">acctact</span><span class="p">.</span><span class="nx">AccountActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Gas is charged here separately from _actorSubstateUpdated because this is a different actor
</span><span class="c1"></span>	<span class="c1">// than the receiver.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">_rtAllocGas</span><span class="p">(</span><span class="nx">gascost</span><span class="p">.</span><span class="nx">UpdateActorSubstate</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_updateActorSubstateInternal</span><span class="p">(</span><span class="nx">address</span><span class="p">,</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nx">state</span><span class="p">)))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">_sendInternalOutputs</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">,</span> <span class="nx">errSpec</span> <span class="nx">ErrorHandlingSpec</span><span class="p">)</span> <span class="p">(</span><span class="nx">InvocOutput</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">_sendInternal</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">errSpec</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="nx">ret</span><span class="p">.</span><span class="nx">ReturnValue</span><span class="p">),</span> <span class="nx">ret</span><span class="p">.</span><span class="nx">ExitCode</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">Send</span><span class="p">(</span>
	<span class="nx">toAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">methodNum</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SendPropagatingErrors</span><span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nf">InvocInput_Make</span><span class="p">(</span><span class="nx">toAddr</span><span class="p">,</span> <span class="nx">methodNum</span><span class="p">,</span> <span class="nx">params</span><span class="p">,</span> <span class="nx">value</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">SendQuery</span><span class="p">(</span><span class="nx">toAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">methodNum</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Serialization</span> <span class="p">{</span>
	<span class="nx">invocOutput</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">toAddr</span><span class="p">,</span> <span class="nx">methodNum</span><span class="p">,</span> <span class="nx">params</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">invocOutput</span><span class="p">.</span><span class="nx">ReturnValue</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ret</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">SendFunds</span><span class="p">(</span><span class="nx">toAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">value</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span><span class="nx">toAddr</span><span class="p">,</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">MethodSend</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">SendPropagatingErrors</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">ret</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">_sendInternalOutputs</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">PropagateErrors</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">SendCatchingErrors</span><span class="p">(</span><span class="nx">input</span> <span class="nx">InvocInput</span><span class="p">)</span> <span class="p">(</span><span class="nx">InvocOutput</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">CronActorAddr</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">_sendInternalOutputs</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">CatchErrors</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">CurrentBalance</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">ValueReceived</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_valueReceived</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">GetRandomness</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">NewActorAddress</span><span class="p">()</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="nx">addrBuf</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span><span class="p">)</span>

	<span class="nx">senderState</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_toplevelSender</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">aast</span> <span class="nx">acctact</span><span class="p">.</span><span class="nx">AccountActorState</span>
	<span class="nx">ok</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">senderState</span><span class="p">.</span><span class="nf">State</span><span class="p">()),</span> <span class="o">&amp;</span><span class="nx">aast</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">aast</span><span class="p">.</span><span class="nx">Address</span><span class="p">.</span><span class="nf">MarshalCBOR</span><span class="p">(</span><span class="nx">addrBuf</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">addrBuf</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_toplevelMsgCallSeqNum</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="nx">err</span> <span class="p">=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">addrBuf</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_internalCallSeqNum</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="nx">newAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">NewActorAddress</span><span class="p">(</span><span class="nx">addrBuf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">newAddr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">IpldPut</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">Object</span><span class="p">)</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// Serialization
</span><span class="c1"></span>	<span class="nx">serialized</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
	<span class="nx">cid</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_store</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">serialized</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_rtAllocGas</span><span class="p">(</span><span class="nx">gascost</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">serialized</span><span class="p">)))</span>
	<span class="k">return</span> <span class="nx">cid</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">IpldGet</span><span class="p">(</span><span class="nx">c</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span><span class="p">,</span> <span class="nx">o</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">Object</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">serialized</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_store</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">_rtAllocGas</span><span class="p">(</span><span class="nx">gascost</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">serialized</span><span class="p">)))</span>
	<span class="p">}</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// Deserialization into o
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">CurrEpoch</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">CurrIndices</span><span class="p">()</span> <span class="nx">indices</span><span class="p">.</span><span class="nx">Indices</span> <span class="p">{</span>
	<span class="c1">// TODO: compute from state tree (rt._globalStatePending), using individual actor
</span><span class="c1"></span>	<span class="c1">// state helper functions when possible
</span><span class="c1"></span>	<span class="nf">TODO</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">AcquireState</span><span class="p">()</span> <span class="nx">ActorStateHandle</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkRunning</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_checkActorStateNotAcquired</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nx">_actorStateAcquired</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="nx">state</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nx">_globalStatePending</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nx">_actorAddress</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>

	<span class="nx">stateRef</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">State</span><span class="p">().</span><span class="nf">Ref</span><span class="p">()</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">ActorStateHandle_I</span><span class="p">{</span>
		<span class="nx">_initValue</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">stateRef</span><span class="p">,</span>
		<span class="nx">_rt</span><span class="p">:</span>        <span class="nx">rt</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">rt</span> <span class="o">*</span><span class="nx">VMContext</span><span class="p">)</span> <span class="nf">Compute</span><span class="p">(</span><span class="nx">f</span> <span class="nx">ComputeFunctionID</span><span class="p">,</span> <span class="nx">args</span> <span class="p">[]</span><span class="nx">util</span><span class="p">.</span><span class="nx">Any</span><span class="p">)</span> <span class="nx">Any</span> <span class="p">{</span>
	<span class="nx">def</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">_computeFunctionDefs</span><span class="p">[</span><span class="nx">f</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;Function definition in rt.Compute() not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">gasCost</span> <span class="o">:=</span> <span class="nx">def</span><span class="p">.</span><span class="nf">GasCostFn</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">_rtAllocGas</span><span class="p">(</span><span class="nx">gasCost</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">def</span><span class="p">.</span><span class="nf">Body</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>





<h4 id="code-loading">Code Loading</h4>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">impl</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">loadActorCode</span><span class="p">(</span><span class="nx">codeID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="c1">// TODO: resolve circular dependency
</span><span class="c1"></span>
	<span class="c1">// // load the code from StateTree.
</span><span class="c1"></span>	<span class="c1">// // TODO: this is going to be enabled in the future.
</span><span class="c1"></span>	<span class="c1">// // code, err := loadCodeFromStateTree(input.InTree, codeCID)
</span><span class="c1"></span>	<span class="c1">// return staticActorCodeRegistry.LoadActor(codeCID)
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>





<h4 id="exit-codes">Exit codes</h4>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">exitcode</span>

<span class="kd">type</span> <span class="nx">ExitCode</span> <span class="kt">int64</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// TODO: remove once canonical error codes are finalized
</span><span class="c1"></span>	<span class="nx">SystemErrorCode_Placeholder</span>      <span class="p">=</span> <span class="nf">ExitCode</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">))</span>
	<span class="nx">UserDefinedErrorCode_Placeholder</span> <span class="p">=</span> <span class="nf">ExitCode</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">))</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">Ok</span> <span class="p">=</span> <span class="nf">ExitCode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">// TODO: assign all of these.
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// ActorNotFound represents a failure to find an actor.
</span><span class="c1"></span>	<span class="nx">ActorNotFound</span> <span class="p">=</span> <span class="nx">SystemErrorCode_Placeholder</span> <span class="o">+</span> <span class="kc">iota</span>

	<span class="c1">// ActorCodeNotFound represents a failure to find the code for a
</span><span class="c1"></span>	<span class="c1">// particular actor in the VM registry.
</span><span class="c1"></span>	<span class="nx">ActorCodeNotFound</span>

	<span class="c1">// InvalidMethod represents a failure to find a method in
</span><span class="c1"></span>	<span class="c1">// an actor
</span><span class="c1"></span>	<span class="nx">InvalidMethod</span>

	<span class="c1">// InvalidArgumentsSystem indicates that a method was called with the incorrect
</span><span class="c1"></span>	<span class="c1">// number of arguments, or that its arguments did not satisfy its
</span><span class="c1"></span>	<span class="c1">// preconditions
</span><span class="c1"></span>	<span class="nx">InvalidArguments_System</span>

	<span class="c1">// InsufficientFunds represents a failure to apply a message, as
</span><span class="c1"></span>	<span class="c1">// it did not carry sufficient funds for its application.
</span><span class="c1"></span>	<span class="nx">InsufficientFunds_System</span>

	<span class="c1">// InvalidCallSeqNum represents a message invocation out of sequence.
</span><span class="c1"></span>	<span class="c1">// This happens when message.CallSeqNum is not exactly actor.CallSeqNum + 1
</span><span class="c1"></span>	<span class="nx">InvalidCallSeqNum</span>

	<span class="c1">// OutOfGas is returned when the execution of an actor method
</span><span class="c1"></span>	<span class="c1">// (including its subcalls) uses more gas than initially allocated.
</span><span class="c1"></span>	<span class="nx">OutOfGas</span>

	<span class="c1">// RuntimeAPIError is returned when an actor method invocation makes a call
</span><span class="c1"></span>	<span class="c1">// to the runtime that does not satisfy its preconditions.
</span><span class="c1"></span>	<span class="nx">RuntimeAPIError</span>

	<span class="c1">// RuntimeAssertFailure is returned when an actor method invocation calls
</span><span class="c1"></span>	<span class="c1">// rt.Assert with a false condition.
</span><span class="c1"></span>	<span class="nx">RuntimeAssertFailure</span>

	<span class="c1">// MethodSubcallError is returned when an actor method&#39;s Send call has
</span><span class="c1"></span>	<span class="c1">// returned with a failure error code (and the Send call did not specify
</span><span class="c1"></span>	<span class="c1">// to ignore errors).
</span><span class="c1"></span>	<span class="nx">MethodSubcallError</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">InsufficientFunds_User</span> <span class="p">=</span> <span class="nx">UserDefinedErrorCode_Placeholder</span> <span class="o">+</span> <span class="kc">iota</span>
	<span class="nx">InvalidArguments_User</span>
	<span class="nx">InconsistentState_User</span>

	<span class="nx">InvalidSectorPacking</span>
	<span class="nx">SealVerificationFailed</span>
	<span class="nx">PoStVerificationFailed</span>
	<span class="nx">DeadlineExceeded</span>
	<span class="nx">InsufficientPledgeCollateral</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">ExitCode</span><span class="p">)</span> <span class="nf">IsSuccess</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">==</span> <span class="nx">Ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">ExitCode</span><span class="p">)</span> <span class="nf">IsError</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">!</span><span class="nx">x</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="nx">ExitCode</span><span class="p">)</span> <span class="nf">AllowsStateUpdate</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nf">IsSuccess</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">OK</span><span class="p">()</span> <span class="nx">ExitCode</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">Ok</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">EnsureErrorCode</span><span class="p">(</span><span class="nx">x</span> <span class="nx">ExitCode</span><span class="p">)</span> <span class="nx">ExitCode</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">x</span><span class="p">.</span><span class="nf">IsError</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Throwing an error with a non-error exit code is itself an error
</span><span class="c1"></span>		<span class="nx">x</span> <span class="p">=</span> <span class="p">(</span><span class="nx">RuntimeAPIError</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">x</span>
<span class="p">}</span>
</code></pre></div>







</div>


  

  
    








<div id="systems__filecoin_vm__runtime__gascost">

<h4 class="section-header">
  VM Gas Cost Constants
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">runtime</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Bytes</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>

<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">TODO</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="c1">// TODO: assign all of these.
</span><span class="c1"></span>	<span class="nx">GasAmountPlaceholder</span>                 <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_FromInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">GasAmountPlaceholder_UpdateStateTree</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="c1">///////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>	<span class="c1">// System operations
</span><span class="c1"></span>	<span class="c1">///////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
	<span class="c1">// Gas cost charged to the originator of an on-chain message (regardless of
</span><span class="c1"></span>	<span class="c1">// whether it succeeds or fails in application) is given by:
</span><span class="c1"></span>	<span class="c1">//   OnChainMessageBase + len(serialized message)*OnChainMessagePerByte
</span><span class="c1"></span>	<span class="c1">// Together, these account for the cost of message propagation and validation,
</span><span class="c1"></span>	<span class="c1">// up to but excluding any actual processing by the VM.
</span><span class="c1"></span>	<span class="c1">// This is the cost a block producer burns when including an invalid message.
</span><span class="c1"></span>	<span class="nx">OnChainMessageBase</span>    <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>
	<span class="nx">OnChainMessagePerByte</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>

	<span class="c1">// Gas cost charged to the originator of a non-nil return value produced
</span><span class="c1"></span>	<span class="c1">// by an on-chain message is given by:
</span><span class="c1"></span>	<span class="c1">//   len(return value)*OnChainReturnValuePerByte
</span><span class="c1"></span>	<span class="nx">OnChainReturnValuePerByte</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>

	<span class="c1">// Gas cost for any message send execution(including the top-level one
</span><span class="c1"></span>	<span class="c1">// initiated by an on-chain message).
</span><span class="c1"></span>	<span class="c1">// This accounts for the cost of loading sender and receiver actors and
</span><span class="c1"></span>	<span class="c1">// (for top-level messages) incrementing the sender&#39;s sequence number.
</span><span class="c1"></span>	<span class="c1">// Load and store of actor sub-state is charged separately.
</span><span class="c1"></span>	<span class="nx">SendBase</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>

	<span class="c1">// Gas cost charged, in addition to SendBase, if a message send
</span><span class="c1"></span>	<span class="c1">// is accompanied by any nonzero currency amount.
</span><span class="c1"></span>	<span class="c1">// Accounts for writing receiver&#39;s new balance (the sender&#39;s state is
</span><span class="c1"></span>	<span class="c1">// already accounted for).
</span><span class="c1"></span>	<span class="nx">SendTransferFunds</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>

	<span class="c1">// Gas cost charged, in addition to SendBase, if a message invokes
</span><span class="c1"></span>	<span class="c1">// a method on the receiver.
</span><span class="c1"></span>	<span class="c1">// Accounts for the cost of loading receiver code and method dispatch.
</span><span class="c1"></span>	<span class="nx">SendInvokeMethod</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>

	<span class="c1">// Gas cost (Base + len*PerByte) for any Get operation to the IPLD store
</span><span class="c1"></span>	<span class="c1">// in the runtime VM context.
</span><span class="c1"></span>	<span class="nx">IpldGetBase</span>    <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>
	<span class="nx">IpldGetPerByte</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>

	<span class="c1">// Gas cost (Base + len*PerByte) for any Put operation to the IPLD store
</span><span class="c1"></span>	<span class="c1">// in the runtime VM context.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Note: these costs should be significantly higher than the costs for Get
</span><span class="c1"></span>	<span class="c1">// operations, since they reflect not only serialization/deserialization
</span><span class="c1"></span>	<span class="c1">// but also persistent storage of chain data.
</span><span class="c1"></span>	<span class="nx">IpldPutBase</span>    <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>
	<span class="nx">IpldPutPerByte</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>

	<span class="c1">// Gas cost for updating an actor&#39;s substate (i.e., UpdateRelease).
</span><span class="c1"></span>	<span class="c1">// This is in addition to a per-byte fee for the state as for IPLD Get/Put.
</span><span class="c1"></span>	<span class="nx">UpdateActorSubstate</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder_UpdateStateTree</span>

	<span class="c1">// Gas cost for creating a new actor (via InitActor&#39;s Exec method).
</span><span class="c1"></span>	<span class="c1">// Actor sub-state is charged separately.
</span><span class="c1"></span>	<span class="nx">ExecNewActor</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>

	<span class="c1">// Gas cost for deleting an actor.
</span><span class="c1"></span>	<span class="nx">DeleteActor</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>

	<span class="c1">///////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>	<span class="c1">// Pure functions (VM ABI)
</span><span class="c1"></span>	<span class="c1">///////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
	<span class="c1">// Gas cost charged per public-key cryptography operation (e.g., signature
</span><span class="c1"></span>	<span class="c1">// verification).
</span><span class="c1"></span>	<span class="nx">PublicKeyCryptoOp</span> <span class="p">=</span> <span class="nx">GasAmountPlaceholder</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">OnChainMessage</span><span class="p">(</span><span class="nx">onChainMessageLen</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Affine</span><span class="p">(</span><span class="nx">OnChainMessageBase</span><span class="p">,</span> <span class="nx">onChainMessageLen</span><span class="p">,</span> <span class="nx">OnChainMessagePerByte</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">OnChainReturnValue</span><span class="p">(</span><span class="nx">returnValue</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="nx">retLen</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="nx">returnValue</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">retLen</span> <span class="p">=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">returnValue</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Affine</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Zero</span><span class="p">(),</span> <span class="nx">retLen</span><span class="p">,</span> <span class="nx">OnChainReturnValuePerByte</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">IpldGet</span><span class="p">(</span><span class="nx">dataSize</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Affine</span><span class="p">(</span><span class="nx">IpldGetBase</span><span class="p">,</span> <span class="nx">dataSize</span><span class="p">,</span> <span class="nx">IpldGetPerByte</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">IpldPut</span><span class="p">(</span><span class="nx">dataSize</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Affine</span><span class="p">(</span><span class="nx">IpldPutBase</span><span class="p">,</span> <span class="nx">dataSize</span><span class="p">,</span> <span class="nx">IpldPutPerByte</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">InvokeMethod</span><span class="p">(</span><span class="nx">value</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">method</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">SendBase</span>
	<span class="k">if</span> <span class="nx">value</span> <span class="o">!=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nx">ret</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">SendTransferFunds</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">method</span> <span class="o">!=</span> <span class="nx">actor</span><span class="p">.</span><span class="nx">MethodSend</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nx">ret</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">SendInvokeMethod</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm__sysactors">

<h3 class="section-header">
  System Actors
</h3>

<div class="section-content">




































<ul>
<li>There are two system actors required for VM processing:
<ul>
<li><a href="#systems__filecoin_vm__sysactors__init_actor">InitActor</a> - initializes new actors, records the network name</li>
<li><a href="#systems__filecoin_vm__sysactors__cron_actor">CronActor</a> - runs critical functions at every epoch</li>
</ul>
</li>
<li>There are two more VM level actors:
<ul>
<li><a href="#systems__filecoin_vm__sysactors__account_actor">AccountActor</a> - for user accounts (non-singleton).</li>
<li><a href="#systems__filecoin_vm__sysactors__reward_actor">RewardActor</a> - for block reward and token vesting (singleton).</li>
</ul>
</li>
</ul>


</div>


  
    








<div id="systems__filecoin_vm__sysactors__init_actor">

<h4 class="section-header">
  InitActor
</h4>

<div class="section-content">






















































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">init</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>

	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
	<span class="nx">autil</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="kd">type</span> <span class="nx">Runtime</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span>
<span class="kd">type</span> <span class="nx">Bytes</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Bytes</span>

<span class="kd">var</span> <span class="nx">AssertMsg</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">AssertMsg</span>

<span class="kd">type</span> <span class="nx">InitActorState</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// responsible for create new actors
</span><span class="c1"></span>	<span class="nx">AddressMap</span>  <span class="kd">map</span><span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">ActorID</span>
	<span class="nx">NextID</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorID</span>
	<span class="nx">NetworkName</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">InitActorState</span><span class="p">)</span> <span class="nf">ResolveAddress</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="nx">actorID</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">AddressMap</span><span class="p">[</span><span class="nx">address</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">idAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">NewIDAddress</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">actorID</span><span class="p">))</span>
		<span class="nx">autil</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">idAddr</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">address</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">InitActorState</span><span class="p">)</span> <span class="nf">MapAddressToNewID</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="nx">actorID</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">NextID</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">NextID</span><span class="o">++</span>
	<span class="nx">s</span><span class="p">.</span><span class="nx">AddressMap</span><span class="p">[</span><span class="nx">address</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actorID</span>
	<span class="nx">idAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">NewIDAddress</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">actorID</span><span class="p">))</span>
	<span class="nx">autil</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">idAddr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">InitActorState</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">InitActor</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">InitActor</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">InitActorState</span><span class="p">{</span>
		<span class="nx">AddressMap</span><span class="p">:</span>  <span class="kd">map</span><span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">{},</span> <span class="c1">// TODO: HAMT
</span><span class="c1"></span>		<span class="nx">NextID</span><span class="p">:</span>      <span class="nx">abi</span><span class="p">.</span><span class="nf">ActorID</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">FirstNonSingletonActorId</span><span class="p">),</span>
		<span class="nx">NetworkName</span><span class="p">:</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">NetworkName</span><span class="p">(),</span>
	<span class="p">}</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReturn</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">InitActor</span><span class="p">)</span> <span class="nf">Exec</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">execCodeID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span> <span class="nx">constructorParams</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodParams</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAny</span><span class="p">()</span>
	<span class="nx">callerCodeID</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">GetActorCodeID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">())</span>
	<span class="nf">AssertMsg</span><span class="p">(</span><span class="nx">ok</span><span class="p">,</span> <span class="s">&#34;no code for actor at %s&#34;</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">())</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">_codeIDSupportsExec</span><span class="p">(</span><span class="nx">callerCodeID</span><span class="p">,</span> <span class="nx">execCodeID</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Caller type cannot create an actor of requested type&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Compute a re-org-stable address.
</span><span class="c1"></span>	<span class="c1">// This address exists for use by messages coming from outside the system, in order to
</span><span class="c1"></span>	<span class="c1">// stably address the newly created actor even if a chain re-org causes it to end up with
</span><span class="c1"></span>	<span class="c1">// a different ID.
</span><span class="c1"></span>	<span class="nx">newAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">NewActorAddress</span><span class="p">()</span>

	<span class="c1">// Allocate an ID for this actor.
</span><span class="c1"></span>	<span class="c1">// Store mapping of pubkey or actor address to actor ID
</span><span class="c1"></span>	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nf">_loadState</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">idAddr</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">MapAddressToNewID</span><span class="p">(</span><span class="nx">newAddr</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Create an empty actor.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">CreateActor</span><span class="p">(</span><span class="nx">execCodeID</span><span class="p">,</span> <span class="nx">idAddr</span><span class="p">)</span>

	<span class="c1">// Invoke constructor. If construction fails, the error should propagate and cause
</span><span class="c1"></span>	<span class="c1">// Exec to fail too.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendPropagatingErrors</span><span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">{</span>
		<span class="nx">To</span><span class="p">:</span>     <span class="nx">idAddr</span><span class="p">,</span>
		<span class="nx">Method</span><span class="p">:</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">MethodConstructor</span><span class="p">,</span>
		<span class="nx">Params</span><span class="p">:</span> <span class="nx">constructorParams</span><span class="p">,</span>
		<span class="nx">Value</span><span class="p">:</span>  <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReceived</span><span class="p">(),</span>
	<span class="p">})</span>

	<span class="kd">var</span> <span class="nx">addrBuf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">idAddr</span><span class="p">.</span><span class="nf">MarshalCBOR</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">addrBuf</span><span class="p">)</span>
	<span class="nx">autil</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReturn</span><span class="p">(</span><span class="nx">addrBuf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
<span class="p">}</span>

<span class="c1">// This method is disabled until proven necessary.
</span><span class="c1">//func (a *InitActorCode_I) GetActorIDForAddress(rt Runtime, address addr.Address) InvocOutput {
</span><span class="c1">//	h, st := _loadState(rt)
</span><span class="c1">//	actorID := st.AddressMap[address]
</span><span class="c1">//	Release(rt, h, st)
</span><span class="c1">//	return rt.ValueReturn(Bytes(addr.Serialize_ActorID(actorID)))
</span><span class="c1">//}
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">_codeIDSupportsExec</span><span class="p">(</span><span class="nx">callerCodeID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span> <span class="nx">execCodeID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">execCodeID</span> <span class="o">==</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">AccountActorCodeID</span> <span class="p">{</span>
		<span class="c1">// Special case: account actors must be created implicitly by sending value;
</span><span class="c1"></span>		<span class="c1">// cannot be created via exec.
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">execCodeID</span> <span class="o">==</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">PaymentChannelActorCodeID</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">execCodeID</span> <span class="o">==</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">callerCodeID</span> <span class="o">==</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorCodeID</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">///// Boilerplate /////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">_loadState</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">InitActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">())</span>
	<span class="kd">var</span> <span class="nx">state</span> <span class="nx">InitActorState</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;state not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">InitActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">checkCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">st</span><span class="p">))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">checkCID</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">InitActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">st</span><span class="p">))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newCID</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__sysactors__cron_actor">

<h4 class="section-header">
  CronActor
</h4>

<div class="section-content">






















































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">cron</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">CronActorState</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">CronActor</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// TODO move Entries into the CronActorState struct
</span><span class="c1"></span>	<span class="nx">Entries</span> <span class="p">[]</span><span class="nx">CronTableEntry</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CronTableEntry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ToAddr</span>    <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">MethodNum</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">CronActor</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="c1">// Nothing. intentionally left blank.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">CronActor</span><span class="p">)</span> <span class="nf">EpochTick</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>

	<span class="c1">// a.Entries is basically a static registry for now, loaded
</span><span class="c1"></span>	<span class="c1">// in the interpreter static registry.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">entry</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Entries</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">SendCatchingErrors</span><span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">{</span>
			<span class="nx">To</span><span class="p">:</span>     <span class="nx">entry</span><span class="p">.</span><span class="nx">ToAddr</span><span class="p">,</span>
			<span class="nx">Method</span><span class="p">:</span> <span class="nx">entry</span><span class="p">.</span><span class="nx">MethodNum</span><span class="p">,</span>
			<span class="nx">Params</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
			<span class="nx">Value</span><span class="p">:</span>  <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__sysactors__account_actor">

<h4 class="section-header">
  AccountActor
</h4>

<div class="section-content">






















































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">account</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span>

<span class="kd">type</span> <span class="nx">AccountActor</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">AccountActor</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="c1">// Nothing. intentionally left blank.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SuccessReturn</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">AccountActorState</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">AccountActorState</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_vm__sysactors__reward_actor">

<h4 class="section-header">
  RewardActor
</h4>

<div class="section-content">




































<p>RewardActor is where unminted Filecoin tokens are kept. RewardActor contains a <code>RewardMap</code> which is a mapping from owner addresses to <code>Reward</code> structs.</p>
<p><code>Reward</code> struct is created to preserve the flexibility of introducing block reward vesting into the protocol. <code>MintReward</code> creates a new <code>Reward</code> struct and adds it to the <code>RewardMap</code>.</p>
<p>A <code>Reward</code> struct contains a <code>StartEpoch</code> that keeps track of when this <code>Reward</code> is created, <code>Value</code> that represents the total number of tokens rewarded, and <code>EndEpoch</code> which is when the reward will be fully vested. <code>VestingFunction</code> is currently an enum to represent the flexibility of different vesting functions. <code>AmountWithdrawn</code> records how many tokens have been withdrawn from a <code>Reward</code> struct so far. Owner addresses can call <code>WithdrawReward</code> which will withdraw all vested tokens that the investor address has from the RewardMap so far. When <code>AmountWithdrawn</code> equals <code>Value</code> in a <code>Reward</code> struct, the <code>Reward</code> struct will be removed from the <code>RewardMap</code>.</p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">reward</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math&#34;</span>

	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
	<span class="nx">serde</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/serde&#34;</span>
	<span class="nx">autil</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="kd">type</span> <span class="nx">Runtime</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span>

<span class="kd">var</span> <span class="nx">IMPL_FINISH</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">IMPL_FINISH</span>
<span class="kd">var</span> <span class="nx">IMPL_TODO</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">IMPL_TODO</span>
<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">TODO</span>

<span class="kd">type</span> <span class="nx">VestingFunction</span> <span class="kt">int64</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">None</span> <span class="nx">VestingFunction</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">Linear</span>
	<span class="c1">// TODO: potential options
</span><span class="c1"></span>	<span class="c1">// PieceWise
</span><span class="c1"></span>	<span class="c1">// Quadratic
</span><span class="c1"></span>	<span class="c1">// Exponential
</span><span class="c1"></span><span class="p">)</span>

<span class="kd">type</span> <span class="nx">Reward</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">VestingFunction</span>
	<span class="nx">StartEpoch</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nx">EndEpoch</span>        <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nx">Value</span>           <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">AmountWithdrawn</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">Reward</span><span class="p">)</span> <span class="nf">AmountVested</span><span class="p">(</span><span class="nx">elapsedEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">r</span><span class="p">.</span><span class="nx">VestingFunction</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Value</span>
	<span class="k">case</span> <span class="nx">Linear</span><span class="p">:</span>
		<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// BigInt
</span><span class="c1"></span>		<span class="nx">vestedProportion</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">elapsedEpoch</span><span class="p">)</span><span class="o">/</span><span class="nb">float64</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="o">-</span><span class="nx">r</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">))</span>
		<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span> <span class="o">*</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">vestedProportion</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ownerAddr to a collection of Reward
</span><span class="c1">// TODO: AMT
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">RewardBalanceAMT</span> <span class="kd">map</span><span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">][]</span><span class="nx">Reward</span>

<span class="kd">type</span> <span class="nx">RewardActorState</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">RewardMap</span> <span class="nx">RewardBalanceAMT</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">RewardActorState</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">RewardActorState</span><span class="p">)</span> <span class="nf">_withdrawReward</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">ownerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nx">rewards</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">RewardMap</span><span class="p">[</span><span class="nx">ownerAddr</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;ra._withdrawReward: ownerAddr not found in RewardMap.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rewardToWithdrawTotal</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">indicesToRemove</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">rewards</span><span class="p">))</span>

	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">r</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">rewards</span> <span class="p">{</span>
		<span class="nx">elapsedEpoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">StartEpoch</span>
		<span class="nx">unlockedReward</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nf">AmountVested</span><span class="p">(</span><span class="nx">elapsedEpoch</span><span class="p">)</span>
		<span class="nx">withdrawableReward</span> <span class="o">:=</span> <span class="nx">unlockedReward</span> <span class="o">-</span> <span class="nx">r</span><span class="p">.</span><span class="nx">AmountWithdrawn</span>

		<span class="k">if</span> <span class="nx">withdrawableReward</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;ra._withdrawReward: negative withdrawableReward.&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">r</span><span class="p">.</span><span class="nx">AmountWithdrawn</span> <span class="p">=</span> <span class="nx">unlockedReward</span> <span class="c1">// modify rewards in place
</span><span class="c1"></span>		<span class="nx">rewardToWithdrawTotal</span> <span class="o">+=</span> <span class="nx">withdrawableReward</span>

		<span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">AmountWithdrawn</span> <span class="o">==</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Value</span> <span class="p">{</span>
			<span class="nx">indicesToRemove</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">indicesToRemove</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">updatedRewards</span> <span class="o">:=</span> <span class="nf">removeIndices</span><span class="p">(</span><span class="nx">rewards</span><span class="p">,</span> <span class="nx">indicesToRemove</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">RewardMap</span><span class="p">[</span><span class="nx">ownerAddr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">updatedRewards</span>

	<span class="k">return</span> <span class="nx">rewardToWithdrawTotal</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RewardActor</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">RewardActor</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span> <span class="nx">InvocOutput</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="c1">// initialize Reward Map with investor accounts
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">RewardActor</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">RewardActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">())</span>
	<span class="kd">var</span> <span class="nx">state</span> <span class="nx">RewardActorState</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;state not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">RewardActor</span><span class="p">)</span> <span class="nf">WithdrawReward</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">vmr</span><span class="p">.</span><span class="nf">RT_ValidateImmediateCallerIsSignable</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">ownerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// withdraw available funds from RewardMap
</span><span class="c1"></span>	<span class="nx">withdrawableReward</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_withdrawReward</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">ownerAddr</span><span class="p">)</span>
	<span class="nf">UpdateReleaseRewardActorState</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">ownerAddr</span><span class="p">,</span> <span class="nx">withdrawableReward</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">RewardActor</span><span class="p">)</span> <span class="nf">AwardBlockReward</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span>
	<span class="nx">miner</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">penalty</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
	<span class="nx">minerNominalPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span>
	<span class="nx">currPledge</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
<span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>

	<span class="nx">inds</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrIndices</span><span class="p">()</span>
	<span class="nx">pledgeReq</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">PledgeCollateralReq</span><span class="p">(</span><span class="nx">minerNominalPower</span><span class="p">)</span>
	<span class="nx">currReward</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">GetCurrBlockRewardForMiner</span><span class="p">(</span><span class="nx">minerNominalPower</span><span class="p">,</span> <span class="nx">currPledge</span><span class="p">)</span>
	<span class="nf">TODO</span><span class="p">()</span>                                                                              <span class="c1">// BigInt
</span><span class="c1"></span>	<span class="nx">underPledge</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">pledgeReq</span><span class="o">-</span><span class="nx">currPledge</span><span class="p">))</span> <span class="c1">// 0 if over collateralized
</span><span class="c1"></span>	<span class="nx">rewardToGarnish</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">currReward</span><span class="p">),</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">underPledge</span><span class="p">))</span>

	<span class="nf">TODO</span><span class="p">()</span>
	<span class="c1">// handle penalty here
</span><span class="c1"></span>	<span class="c1">// also handle penalty greater than reward
</span><span class="c1"></span>	<span class="nx">actualReward</span> <span class="o">:=</span> <span class="nx">currReward</span> <span class="o">-</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nx">rewardToGarnish</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">rewardToGarnish</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Send fund to SPA for collateral
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_AddBalance</span><span class="p">,</span>
			<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span><span class="nx">miner</span><span class="p">),</span>
			<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nx">rewardToGarnish</span><span class="p">),</span>
		<span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">actualReward</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// put Reward into RewardMap
</span><span class="c1"></span>		<span class="nx">newReward</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Reward</span><span class="p">{</span>
			<span class="nx">StartEpoch</span><span class="p">:</span>      <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">(),</span>
			<span class="nx">EndEpoch</span><span class="p">:</span>        <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">(),</span>
			<span class="nx">Value</span><span class="p">:</span>           <span class="nx">actualReward</span><span class="p">,</span>
			<span class="nx">AmountWithdrawn</span><span class="p">:</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			<span class="nx">VestingFunction</span><span class="p">:</span> <span class="nx">None</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nx">rewards</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">RewardMap</span><span class="p">[</span><span class="nx">miner</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="nx">rewards</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Reward</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">rewards</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">rewards</span><span class="p">,</span> <span class="o">*</span><span class="nx">newReward</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">RewardMap</span><span class="p">[</span><span class="nx">miner</span><span class="p">]</span> <span class="p">=</span> <span class="nx">rewards</span>
	<span class="p">}</span>
	<span class="nf">UpdateReleaseRewardActorState</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">UpdateReleaseRewardActorState</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">RewardActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">st</span><span class="p">))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newCID</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">removeIndices</span><span class="p">(</span><span class="nx">rewards</span> <span class="p">[]</span><span class="nx">Reward</span><span class="p">,</span> <span class="nx">indices</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">Reward</span> <span class="p">{</span>
	<span class="c1">// remove fully paid out Rewards by indices
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_vm__interpreter">

<h3 class="section-header">
  VM Interpreter - Message Invocation (Outside VM)
</h3>

<div class="section-content">




































<div id="systems__filecoin_vm__interpreter__vm_interpreter"></div>
<p>The VM interpreter orchestrates the execution of messages from a tipset on that tipset&rsquo;s parent state,
producing a new state and a sequence of message receipts. The CIDs of this new state and of the receipt
collection are included in blocks from the subsequent epoch, which must agree about those CIDs
in order to form a new tipset.</p>
<p>Every state change is driven by the execution of a message.
The messages from all the blocks in a tipset must be executed in order to produce a next state.
All messages from the first block are executed before those of second and subsequent blocks in the
tipset. For each block, BLS-aggregated messages are executed first, then SECP signed messages.</p>
<h4 id="implicit-messages">Implicit messages</h4>
<p>In addition to the messages explicitly included in each block, a few state changes at each epoch
are made by implicit messages. Implicit messages are not transmitted between nodes, but constructed
by the interpreter at evaluation time.</p>
<p>For each block in a tipset, an implicit message:</p>
<ul>
<li>invokes the block producer&rsquo;s miner actor to process the (already-validated) election PoSt submission,
as the first message in the block;</li>
<li>invokes the reward actor to pay the block reward to the miner&rsquo;s owner account, as the final message in the block;</li>
</ul>
<p>For each tipset, an implicit message:</p>
<ul>
<li>invokes the cron actor to process automated checks and payments, as the final message in the tipset.</li>
</ul>
<p>All implicit messages are constructed with a <code>From</code> address being the distinguished system account actor.
They specify a gas price of zero, but must be included in the computation.
They must succeed (have an exit code of zero) in order for the new state to be computed.
Receipts for implicit messages are not included in the receipt list; only explicit messages have an
explicit receipt.</p>
<h4 id="gas-payments">Gas payments</h4>
<p>In most cases, the sender of a message pays the miner which produced the block including that message
a gas fee for its execution.</p>
<p>The gas payments for each message execution are paid to the miner owner account immediately after
that message is executed. There are no encumbrances to either the block reward or gas fees earned:
both may be spent immediately.</p>
<h4 id="duplicate-messages">Duplicate messages</h4>
<p>Since different miners produce blocks in the same epoch, multiple blocks in a single tipset may
include the same message (identified by the same CID).
When this happens, the message is processed only the first time it is encountered in the tipset&rsquo;s
canonical order. Subsequent instances of the message are ignored and do not result in any
state mutation, produce a receipt, or pay gas to the block producer.</p>
<p>The sequence of executions for a tipset is thus summarised:</p>
<ul>
<li>pay reward for first block</li>
<li>process election post for first block</li>
<li>messages for first block (BLS before SECP)</li>
<li>pay reward for second block</li>
<li>process election post for second block</li>
<li>messages for second block (BLS before SECP, skipping any already encountered)</li>
<li>[&hellip; subsequent blocks &hellip;]</li>
<li>cron tick</li>
</ul>
<h4 id="message-validity-and-failure">Message validity and failure</h4>
<p>Every message in a valid block can be processed and produce a receipt (note that block validity
implies all messages are syntactically valid &ndash; see <a href="./#systems__filecoin_vm__message__message_syntax">Message Syntax</a> &ndash; and correctly signed).
However, execution may or may not succeed, depending on the state to which the message is applied. If the execution
of a message fails, the corresponding receipt will carry a non-zero exit code.</p>
<p>If a message fails due to a reason that can reasonably be attributed to the miner including a
message that could never have succeeded in the parent state, or because the sender lacks funds
to cover the maximum message cost, then the miner pays a penalty by burning the gas fee
(rather than the sender paying fees to the block miner).</p>
<p>The only state changes resulting from a message failure are either:</p>
<ul>
<li>incrementing of the sending actor&rsquo;s <code>CallSeqNum</code>, and payment of gas fees from the sender to the owner of the miner of the block including the message; or</li>
<li>a penalty equivalent to the gas fee for the failed message, burnt by the miner (sender&rsquo;s <code>CallSeqNum</code> unchanged).</li>
</ul>
<p>A message execution will fail if, in the immediately preceding state:</p>
<ul>
<li>the <code>From</code> actor does not exist in the state (miner penalized),</li>
<li>the <code>From</code> actor is not an account actor (miner penalized),</li>
<li>the <code>CallSeqNum</code> of the message does not match the <code>CallSeqNum</code> of the <code>From</code> actor (miner penalized),</li>
<li>the <code>From</code> actor does not have sufficient balance to cover the sum of the message <code>Value</code> plus the
maximum gas cost, <code>GasLimit * GasPrice</code> (miner penalized),</li>
<li>the <code>To</code> actor does not exist in state and the <code>To</code> address is not a pubkey-style address,</li>
<li>the <code>To</code> actor exists (or is implicitly created as an account) but does not have a method corresponding to the non-zero <code>MethodNum</code>,</li>
<li>deserialized <code>Params</code> is not an array of length matching the arity of the <code>To</code> actor&rsquo;s <code>MethodNum</code> method,</li>
<li>deserialized <code>Params</code> are not valid for the types specified by the <code>To</code> actor&rsquo;s <code>MethodNum</code> method,</li>
<li>the invoked method consumes more gas than the <code>GasLimit</code> allows,</li>
<li>the invoked method exits with a non-zero code (via <code>Runtime.Abort()</code>), or</li>
<li>any inner message sent by the receiver fails for any of the above reasons.</li>
</ul>
<p>Note that if the <code>To</code> actor does not exist in state and the address is a valid <code>H(pubkey)</code> address,
it will be created as an account actor.</p>
<p>(You can see the <em>old</em> VM interpreter <a href="docs/systems/filecoin_vm/vm_interpreter_old">here</a> )</p>
<h4 id="vminterpreter-interface"><code>vm/interpreter</code> interface</h4>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">vmri</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/impl&#34;</span>
<span class="kn">import</span> <span class="nx">node_base</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/node_base&#34;</span>
<span class="kn">import</span> <span class="nx">chain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/chain&#34;</span>
<span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>

<span class="kd">type</span> <span class="nx">UInt64</span> <span class="nx">UInt</span>

<span class="c1">// The messages from one block in a tipset.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">BlockMessages</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BLSMessages</span>   <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span><span class="p">]</span>
    <span class="nx">SECPMessages</span>  <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">SignedMessage</span><span class="p">]</span>
    <span class="nx">Miner</span>         <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>  <span class="c1">// The block miner&#39;s actor address
</span><span class="c1"></span>    <span class="nx">PoStProof</span>     <span class="nx">Bytes</span>  <span class="c1">// The miner&#39;s Election PoSt proof output
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// The messages from a tipset, grouped by block.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TipSetMessages</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Blocks</span>  <span class="p">[</span><span class="nx">BlockMessages</span><span class="p">]</span>
    <span class="nx">Epoch</span>   <span class="nx">UInt64</span>  <span class="c1">// The chain epoch of the blocks
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">VMInterpreter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Node</span> <span class="nx">node_base</span><span class="p">.</span><span class="nx">FilecoinNode</span>
    <span class="nf">ApplyTipSetMessages</span><span class="p">(</span>
        <span class="nx">inTree</span>  <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
        <span class="nx">tipset</span>  <span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span>
        <span class="nx">msgs</span>    <span class="nx">TipSetMessages</span>
    <span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">ret</span> <span class="p">[</span><span class="nx">vmri</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">]}</span>

    <span class="nf">ApplyMessage</span><span class="p">(</span>
        <span class="nx">inTree</span>          <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
        <span class="nx">chain</span>           <span class="nx">chain</span><span class="p">.</span><span class="nx">Chain</span>
        <span class="nx">msg</span>             <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span>
        <span class="nx">onChainMsgSize</span>  <span class="kt">int</span>
        <span class="nx">minerAddr</span>       <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">outTree</span>          <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
        <span class="nx">ret</span>              <span class="nx">vmri</span><span class="p">.</span><span class="nx">MessageReceipt</span>
        <span class="nx">retMinerPenalty</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>





<h4 id="vminterpreter-implementation"><code>vm/interpreter</code> implementation</h4>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">interpreter</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">initact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/init&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
	<span class="nx">exitcode</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/exitcode&#34;</span>
	<span class="nx">indices</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&#34;</span>
	<span class="nx">serde</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/serde&#34;</span>
	<span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
	<span class="nx">chain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/chain&#34;</span>
	<span class="nx">actstate</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/actor&#34;</span>
	<span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
	<span class="nx">gascost</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/gascost&#34;</span>
	<span class="nx">vmri</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/runtime/impl&#34;</span>
	<span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Bytes</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>

<span class="kd">var</span> <span class="nx">Assert</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Assert</span>
<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">TODO</span>
<span class="kd">var</span> <span class="nx">IMPL_FINISH</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">IMPL_FINISH</span>

<span class="kd">type</span> <span class="nx">SenderResolveSpec</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">SenderResolveSpec_OK</span> <span class="nx">SenderResolveSpec</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="kc">iota</span>
	<span class="nx">SenderResolveSpec_Invalid</span>
<span class="p">)</span>

<span class="c1">// Applies all the message in a tipset, along with implicit block- and tipset-specific state
</span><span class="c1">// transitions.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">vmi</span> <span class="o">*</span><span class="nx">VMInterpreter_I</span><span class="p">)</span> <span class="nf">ApplyTipSetMessages</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">tipset</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">,</span> <span class="nx">msgs</span> <span class="nx">TipSetMessages</span><span class="p">)</span> <span class="p">(</span><span class="nx">outTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">receipts</span> <span class="p">[]</span><span class="nx">vmri</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">outTree</span> <span class="p">=</span> <span class="nx">inTree</span>
	<span class="nx">seenMsgs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span><span class="p">]</span><span class="kd">struct</span><span class="p">{})</span> <span class="c1">// CIDs of messages already seen once.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">receipt</span> <span class="nx">vmri</span><span class="p">.</span><span class="nx">MessageReceipt</span>
	<span class="nx">store</span> <span class="o">:=</span> <span class="nx">vmi</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">StateStore</span><span class="p">()</span>
	<span class="c1">// get chain from Tipset
</span><span class="c1"></span>	<span class="nx">chainRand</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Chain_I</span><span class="p">{</span>
		<span class="nx">HeadTipset_</span><span class="p">:</span> <span class="nx">tipset</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">blk</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">msgs</span><span class="p">.</span><span class="nf">Blocks</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">Miner</span><span class="p">()</span>
		<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">.</span><span class="nf">Protocol</span><span class="p">()</span> <span class="o">==</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span> <span class="c1">// Block syntactic validation requires this.
</span><span class="c1"></span>
		<span class="c1">// Process block miner&#39;s Election PoSt.
</span><span class="c1"></span>		<span class="nx">epostMessage</span> <span class="o">:=</span> <span class="nf">_makeElectionPoStMessage</span><span class="p">(</span><span class="nx">outTree</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
		<span class="nx">outTree</span> <span class="p">=</span> <span class="nf">_applyMessageBuiltinAssert</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">outTree</span><span class="p">,</span> <span class="nx">chainRand</span><span class="p">,</span> <span class="nx">epostMessage</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>

		<span class="nx">minerPenaltyTotal</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">minerPenaltyCurr</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>

		<span class="nx">minerGasRewardTotal</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="kd">var</span> <span class="nx">minerGasRewardCurr</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>

		<span class="c1">// Process BLS messages from the block.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">m</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">BLSMessages</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">seenMsgs</span><span class="p">[</span><span class="nf">_msgCID</span><span class="p">(</span><span class="nx">m</span><span class="p">)]</span>
			<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">onChainMessageLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nf">Serialize_UnsignedMessage</span><span class="p">(</span><span class="nx">m</span><span class="p">))</span>
			<span class="nx">outTree</span><span class="p">,</span> <span class="nx">receipt</span><span class="p">,</span> <span class="nx">minerPenaltyCurr</span><span class="p">,</span> <span class="nx">minerGasRewardCurr</span> <span class="p">=</span> <span class="nx">vmi</span><span class="p">.</span><span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">outTree</span><span class="p">,</span> <span class="nx">chainRand</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">onChainMessageLen</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
			<span class="nx">minerPenaltyTotal</span> <span class="o">+=</span> <span class="nx">minerPenaltyCurr</span>
			<span class="nx">minerGasRewardTotal</span> <span class="o">+=</span> <span class="nx">minerGasRewardCurr</span>

			<span class="nx">receipts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">receipts</span><span class="p">,</span> <span class="nx">receipt</span><span class="p">)</span>
			<span class="nx">seenMsgs</span><span class="p">[</span><span class="nf">_msgCID</span><span class="p">(</span><span class="nx">m</span><span class="p">)]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}</span>

		<span class="c1">// Process SECP messages from the block.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sm</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">blk</span><span class="p">.</span><span class="nf">SECPMessages</span><span class="p">()</span> <span class="p">{</span>
			<span class="nx">m</span> <span class="o">:=</span> <span class="nx">sm</span><span class="p">.</span><span class="nf">Message</span><span class="p">()</span>
			<span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">seenMsgs</span><span class="p">[</span><span class="nf">_msgCID</span><span class="p">(</span><span class="nx">m</span><span class="p">)]</span>
			<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">onChainMessageLen</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nf">Serialize_SignedMessage</span><span class="p">(</span><span class="nx">sm</span><span class="p">))</span>
			<span class="nx">outTree</span><span class="p">,</span> <span class="nx">receipt</span><span class="p">,</span> <span class="nx">minerPenaltyCurr</span><span class="p">,</span> <span class="nx">minerGasRewardCurr</span> <span class="p">=</span> <span class="nx">vmi</span><span class="p">.</span><span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">outTree</span><span class="p">,</span> <span class="nx">chainRand</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">onChainMessageLen</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
			<span class="nx">minerPenaltyTotal</span> <span class="o">+=</span> <span class="nx">minerPenaltyCurr</span>
			<span class="nx">minerGasRewardTotal</span> <span class="o">+=</span> <span class="nx">minerGasRewardCurr</span>

			<span class="nx">receipts</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">receipts</span><span class="p">,</span> <span class="nx">receipt</span><span class="p">)</span>
			<span class="nx">seenMsgs</span><span class="p">[</span><span class="nf">_msgCID</span><span class="p">(</span><span class="nx">m</span><span class="p">)]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{}{}</span>
		<span class="p">}</span>

		<span class="c1">// transfer gas reward from BurntFundsActor to RewardActor
</span><span class="c1"></span>		<span class="nf">_withTransferFundsAssert</span><span class="p">(</span><span class="nx">outTree</span><span class="p">,</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">RewardActorAddr</span><span class="p">,</span> <span class="nx">minerGasRewardTotal</span><span class="p">)</span>

		<span class="c1">// Pay block reward.
</span><span class="c1"></span>		<span class="nx">rewardMessage</span> <span class="o">:=</span> <span class="nf">_makeBlockRewardMessage</span><span class="p">(</span><span class="nx">outTree</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">minerPenaltyTotal</span><span class="p">,</span> <span class="nx">minerGasRewardTotal</span><span class="p">)</span>
		<span class="nx">outTree</span> <span class="p">=</span> <span class="nf">_applyMessageBuiltinAssert</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">outTree</span><span class="p">,</span> <span class="nx">chainRand</span><span class="p">,</span> <span class="nx">rewardMessage</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Invoke cron tick.
</span><span class="c1"></span>	<span class="c1">// Since this is outside any block, the top level block winner is declared as the system actor.
</span><span class="c1"></span>	<span class="nx">cronMessage</span> <span class="o">:=</span> <span class="nf">_makeCronTickMessage</span><span class="p">(</span><span class="nx">outTree</span><span class="p">)</span>
	<span class="nx">outTree</span> <span class="p">=</span> <span class="nf">_applyMessageBuiltinAssert</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">outTree</span><span class="p">,</span> <span class="nx">chainRand</span><span class="p">,</span> <span class="nx">cronMessage</span><span class="p">,</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">vmi</span> <span class="o">*</span><span class="nx">VMInterpreter_I</span><span class="p">)</span> <span class="nf">ApplyMessage</span><span class="p">(</span><span class="nx">inTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">chain</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">message</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span><span class="p">,</span> <span class="nx">onChainMessageSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">retTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">retReceipt</span> <span class="nx">vmri</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">,</span> <span class="nx">retMinerPenalty</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">retMinerGasReward</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">store</span> <span class="o">:=</span> <span class="nx">vmi</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">StateStore</span><span class="p">()</span>
	<span class="nx">senderAddr</span> <span class="o">:=</span> <span class="nf">_resolveSender</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">inTree</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">From</span><span class="p">())</span>

	<span class="nx">vmiGasRemaining</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">()</span>
	<span class="nx">vmiGasUsed</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Zero</span><span class="p">()</span>

	<span class="nx">_applyReturn</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span>
		<span class="nx">tree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">invocOutput</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span><span class="p">,</span> <span class="nx">exitCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">,</span>
		<span class="nx">senderResolveSpec</span> <span class="nx">SenderResolveSpec</span><span class="p">)</span> <span class="p">{</span>

		<span class="nx">vmiGasRemainingFIL</span> <span class="o">:=</span> <span class="nf">_gasToFIL</span><span class="p">(</span><span class="nx">vmiGasRemaining</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">())</span>
		<span class="nx">vmiGasUsedFIL</span> <span class="o">:=</span> <span class="nf">_gasToFIL</span><span class="p">(</span><span class="nx">vmiGasUsed</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">())</span>

		<span class="k">switch</span> <span class="nx">senderResolveSpec</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">SenderResolveSpec_OK</span><span class="p">:</span>
			<span class="c1">// In this case, the sender is valid and has already transferred funds to the burnt funds actor
</span><span class="c1"></span>			<span class="c1">// sufficient for the gas limit. Thus, we may refund the unused gas funds to the sender here.
</span><span class="c1"></span>			<span class="nf">Assert</span><span class="p">(!</span><span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">().</span><span class="nf">LessThan</span><span class="p">(</span><span class="nx">vmiGasUsed</span><span class="p">))</span>
			<span class="nf">Assert</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">().</span><span class="nf">Equals</span><span class="p">(</span><span class="nx">vmiGasUsed</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">vmiGasRemaining</span><span class="p">)))</span>
			<span class="nx">tree</span> <span class="p">=</span> <span class="nf">_withTransferFundsAssert</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">senderAddr</span><span class="p">,</span> <span class="nx">vmiGasRemainingFIL</span><span class="p">)</span>
			<span class="nx">retMinerGasReward</span> <span class="p">=</span> <span class="nx">vmiGasUsedFIL</span>
			<span class="nx">retMinerPenalty</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

		<span class="k">case</span> <span class="nx">SenderResolveSpec_Invalid</span><span class="p">:</span>
			<span class="nx">retMinerPenalty</span> <span class="p">=</span> <span class="nx">vmiGasUsedFIL</span>
			<span class="nx">retMinerGasReward</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

		<span class="k">default</span><span class="p">:</span>
			<span class="nf">Assert</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nx">retTree</span> <span class="p">=</span> <span class="nx">tree</span>
		<span class="nx">retReceipt</span> <span class="p">=</span> <span class="nx">vmri</span><span class="p">.</span><span class="nf">MessageReceipt_Make</span><span class="p">(</span><span class="nx">invocOutput</span><span class="p">,</span> <span class="nx">exitCode</span><span class="p">,</span> <span class="nx">vmiGasUsed</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// TODO move this to a package with a less redundant name
</span><span class="c1"></span>	<span class="nx">_applyError</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">tree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">errExitCode</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">senderResolveSpec</span> <span class="nx">SenderResolveSpec</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">_applyReturn</span><span class="p">(</span><span class="nx">tree</span><span class="p">,</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="nx">errExitCode</span><span class="p">,</span> <span class="nx">senderResolveSpec</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Deduct an amount of gas corresponding to cost about to be incurred, but not necessarily
</span><span class="c1"></span>	<span class="c1">// incurred yet.
</span><span class="c1"></span>	<span class="nx">_vmiAllocGas</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">amount</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmiAllocGasOK</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">vmiGasRemaining</span><span class="p">,</span> <span class="nx">vmiAllocGasOK</span> <span class="p">=</span> <span class="nx">vmiGasRemaining</span><span class="p">.</span><span class="nf">SubtractIfNonnegative</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
		<span class="nx">vmiGasUsed</span> <span class="p">=</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">().</span><span class="nf">Subtract</span><span class="p">(</span><span class="nx">vmiGasRemaining</span><span class="p">)</span>
		<span class="nf">Assert</span><span class="p">(!</span><span class="nx">vmiGasRemaining</span><span class="p">.</span><span class="nf">LessThan</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Zero</span><span class="p">()))</span>
		<span class="nf">Assert</span><span class="p">(!</span><span class="nx">vmiGasUsed</span><span class="p">.</span><span class="nf">LessThan</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Zero</span><span class="p">()))</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Deduct an amount of gas corresponding to costs already incurred, and for which the
</span><span class="c1"></span>	<span class="c1">// gas cost must be paid even if it would cause the gas used to exceed the limit.
</span><span class="c1"></span>	<span class="nx">_vmiBurnGas</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">amount</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmiBurnGasOK</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">vmiGasUsedPre</span> <span class="o">:=</span> <span class="nx">vmiGasUsed</span>
		<span class="nx">vmiBurnGasOK</span> <span class="p">=</span> <span class="nf">_vmiAllocGas</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">vmiBurnGasOK</span> <span class="p">{</span>
			<span class="nx">vmiGasRemaining</span> <span class="p">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_Zero</span><span class="p">()</span>
			<span class="nx">vmiGasUsed</span> <span class="p">=</span> <span class="nx">vmiGasUsedPre</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">amount</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">ok</span> <span class="o">:=</span> <span class="nf">_vmiBurnGas</span><span class="p">(</span><span class="nx">gascost</span><span class="p">.</span><span class="nf">OnChainMessage</span><span class="p">(</span><span class="nx">onChainMessageSize</span><span class="p">))</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// Invalid message; insufficient gas limit to pay for the on-chain message size.
</span><span class="c1"></span>		<span class="nf">_applyError</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">OutOfGas</span><span class="p">,</span> <span class="nx">SenderResolveSpec_Invalid</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">fromActor</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">inTree</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">senderAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// Execution error; sender does not exist at time of message execution.
</span><span class="c1"></span>		<span class="nf">_applyError</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">ActorNotFound</span><span class="p">,</span> <span class="nx">SenderResolveSpec_Invalid</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// make sure this is the right message order for fromActor
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">message</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">fromActor</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">_applyError</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">InvalidCallSeqNum</span><span class="p">,</span> <span class="nx">SenderResolveSpec_Invalid</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Check sender balance.
</span><span class="c1"></span>	<span class="nx">gasLimitCost</span> <span class="o">:=</span> <span class="nf">_gasToFIL</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">(),</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasPrice</span><span class="p">())</span>
	<span class="nx">tidx</span> <span class="o">:=</span> <span class="nf">indicesFromStateTree</span><span class="p">(</span><span class="nx">inTree</span><span class="p">)</span>
	<span class="nx">networkTxnFee</span> <span class="o">:=</span> <span class="nx">tidx</span><span class="p">.</span><span class="nf">NetworkTransactionFee</span><span class="p">(</span>
		<span class="nx">inTree</span><span class="p">.</span><span class="nf">GetActorCodeID_Assert</span><span class="p">(</span><span class="nx">message</span><span class="p">.</span><span class="nf">To</span><span class="p">()),</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Method</span><span class="p">())</span>
	<span class="nx">totalCost</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Value</span><span class="p">()</span> <span class="o">+</span> <span class="nx">gasLimitCost</span> <span class="o">+</span> <span class="nx">networkTxnFee</span>
	<span class="k">if</span> <span class="nx">fromActor</span><span class="p">.</span><span class="nf">Balance</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">totalCost</span> <span class="p">{</span>
		<span class="c1">// Execution error; sender does not have sufficient funds to pay for the gas limit.
</span><span class="c1"></span>		<span class="nf">_applyError</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">InsufficientFunds_System</span><span class="p">,</span> <span class="nx">SenderResolveSpec_Invalid</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// At this point, construct compTreePreSend as a state snapshot which includes
</span><span class="c1"></span>	<span class="c1">// the sender paying gas, and the sender&#39;s CallSeqNum being incremented;
</span><span class="c1"></span>	<span class="c1">// at least that much state change will be persisted even if the
</span><span class="c1"></span>	<span class="c1">// method invocation subsequently fails.
</span><span class="c1"></span>	<span class="nx">compTreePreSend</span> <span class="o">:=</span> <span class="nf">_withTransferFundsAssert</span><span class="p">(</span><span class="nx">inTree</span><span class="p">,</span> <span class="nx">senderAddr</span><span class="p">,</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">gasLimitCost</span><span class="o">+</span><span class="nx">networkTxnFee</span><span class="p">)</span>
	<span class="nx">compTreePreSend</span> <span class="p">=</span> <span class="nx">compTreePreSend</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithIncrementedCallSeqNum_Assert</span><span class="p">(</span><span class="nx">senderAddr</span><span class="p">)</span>

	<span class="nx">invoc</span> <span class="o">:=</span> <span class="nf">_makeInvocInput</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
	<span class="nx">sendRet</span><span class="p">,</span> <span class="nx">compTreePostSend</span> <span class="o">:=</span> <span class="nf">_applyMessageInternal</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">compTreePreSend</span><span class="p">,</span> <span class="nx">chain</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">(),</span> <span class="nx">senderAddr</span><span class="p">,</span> <span class="nx">invoc</span><span class="p">,</span> <span class="nx">vmiGasRemaining</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>

	<span class="nx">ok</span> <span class="p">=</span> <span class="nf">_vmiBurnGas</span><span class="p">(</span><span class="nx">sendRet</span><span class="p">.</span><span class="nx">GasUsed</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Interpreter error: runtime execution used more gas than provided&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">ok</span> <span class="p">=</span> <span class="nf">_vmiAllocGas</span><span class="p">(</span><span class="nx">gascost</span><span class="p">.</span><span class="nf">OnChainReturnValue</span><span class="p">(</span><span class="nx">sendRet</span><span class="p">.</span><span class="nx">ReturnValue</span><span class="p">))</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// Insufficient gas remaining to cover the on-chain return value; proceed as in the case
</span><span class="c1"></span>		<span class="c1">// of method execution failure.
</span><span class="c1"></span>		<span class="nf">_applyError</span><span class="p">(</span><span class="nx">compTreePreSend</span><span class="p">,</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nx">OutOfGas</span><span class="p">,</span> <span class="nx">SenderResolveSpec_OK</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">compTreeRet</span> <span class="o">:=</span> <span class="nx">compTreePreSend</span>
	<span class="k">if</span> <span class="nx">sendRet</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">.</span><span class="nf">AllowsStateUpdate</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">compTreeRet</span> <span class="p">=</span> <span class="nx">compTreePostSend</span>
	<span class="p">}</span>

	<span class="nf">_applyReturn</span><span class="p">(</span>
		<span class="nx">compTreeRet</span><span class="p">,</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">InvocOutput_Make</span><span class="p">(</span><span class="nx">sendRet</span><span class="p">.</span><span class="nx">ReturnValue</span><span class="p">),</span> <span class="nx">sendRet</span><span class="p">.</span><span class="nx">ExitCode</span><span class="p">,</span> <span class="nx">SenderResolveSpec_OK</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Resolves an address through the InitActor&#39;s map.
</span><span class="c1">// Returns the resolved address (which will be an ID address) if found, else the original address.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">_resolveSender</span><span class="p">(</span><span class="nx">store</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">GraphStore</span><span class="p">,</span> <span class="nx">tree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="nx">initState</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">InitActorAddr</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">serialized</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">store</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">initState</span><span class="p">.</span><span class="nf">State</span><span class="p">()))</span>
	<span class="kd">var</span> <span class="nx">initSubState</span> <span class="nx">initact</span><span class="p">.</span><span class="nx">InitActorState</span>
	<span class="nx">serde</span><span class="p">.</span><span class="nf">MustDeserialize</span><span class="p">(</span><span class="nx">serialized</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">initSubState</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">initSubState</span><span class="p">.</span><span class="nf">ResolveAddress</span><span class="p">(</span><span class="nx">address</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_applyMessageBuiltinAssert</span><span class="p">(</span><span class="nx">store</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">GraphStore</span><span class="p">,</span> <span class="nx">tree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">chain</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">message</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span> <span class="p">{</span>
	<span class="nx">senderAddr</span> <span class="o">:=</span> <span class="nx">message</span><span class="p">.</span><span class="nf">From</span><span class="p">()</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">senderAddr</span> <span class="o">==</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">senderAddr</span><span class="p">.</span><span class="nf">Protocol</span><span class="p">()</span> <span class="o">==</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span>
	<span class="c1">// Note: this message CallSeqNum is never checked (b/c it&#39;s created in this file), but probably should be.
</span><span class="c1"></span>	<span class="c1">// Since it changes state, we should be sure about the state transition.
</span><span class="c1"></span>	<span class="c1">// Alternatively we could special-case the system actor and declare that its CallSeqNumber
</span><span class="c1"></span>	<span class="c1">// never changes (saving us the state-change overhead).
</span><span class="c1"></span>	<span class="nx">tree</span> <span class="p">=</span> <span class="nx">tree</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithIncrementedCallSeqNum_Assert</span><span class="p">(</span><span class="nx">senderAddr</span><span class="p">)</span>

	<span class="nx">invoc</span> <span class="o">:=</span> <span class="nf">_makeInvocInput</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span>
	<span class="nx">retReceipt</span><span class="p">,</span> <span class="nx">retTree</span> <span class="o">:=</span> <span class="nf">_applyMessageInternal</span><span class="p">(</span><span class="nx">store</span><span class="p">,</span> <span class="nx">tree</span><span class="p">,</span> <span class="nx">chain</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">(),</span> <span class="nx">senderAddr</span><span class="p">,</span> <span class="nx">invoc</span><span class="p">,</span> <span class="nx">message</span><span class="p">.</span><span class="nf">GasLimit</span><span class="p">(),</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">retReceipt</span><span class="p">.</span><span class="nx">ExitCode</span> <span class="o">!=</span> <span class="nx">exitcode</span><span class="p">.</span><span class="nf">OK</span><span class="p">()</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;internal message application failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">retTree</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_applyMessageInternal</span><span class="p">(</span><span class="nx">store</span> <span class="nx">ipld</span><span class="p">.</span><span class="nx">GraphStore</span><span class="p">,</span> <span class="nx">tree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">chain</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">Chain</span><span class="p">,</span> <span class="nx">messageCallSequenceNumber</span> <span class="nx">actstate</span><span class="p">.</span><span class="nx">CallSeqNum</span><span class="p">,</span> <span class="nx">senderAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">invoc</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">,</span>
	<span class="nx">gasRemainingInit</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">,</span> <span class="nx">topLevelBlockWinner</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmri</span><span class="p">.</span><span class="nx">MessageReceipt</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">rt</span> <span class="o">:=</span> <span class="nx">vmri</span><span class="p">.</span><span class="nf">VMContext_Make</span><span class="p">(</span>
		<span class="nx">store</span><span class="p">,</span>
		<span class="nx">chain</span><span class="p">,</span>
		<span class="nx">senderAddr</span><span class="p">,</span>
		<span class="nx">topLevelBlockWinner</span><span class="p">,</span>
		<span class="nx">messageCallSequenceNumber</span><span class="p">,</span>
		<span class="nx">actstate</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">tree</span><span class="p">,</span>
		<span class="nx">senderAddr</span><span class="p">,</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">gasRemainingInit</span><span class="p">,</span>
	<span class="p">)</span>

	<span class="k">return</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SendToplevelFromInterpreter</span><span class="p">(</span><span class="nx">invoc</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_withTransferFundsAssert</span><span class="p">(</span><span class="nx">tree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">from</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">to</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span> <span class="p">{</span>
	<span class="c1">// TODO: assert amount nonnegative
</span><span class="c1"></span>	<span class="nx">retTree</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tree</span><span class="p">.</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">WithFundsTransfer</span><span class="p">(</span><span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Interpreter error: insufficient funds (or transfer error) despite checks&#34;</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">retTree</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">indicesFromStateTree</span><span class="p">(</span><span class="nx">st</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="nx">indices</span><span class="p">.</span><span class="nx">Indices</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_gasToFIL</span><span class="p">(</span><span class="nx">gas</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">,</span> <span class="nx">price</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="c1">// return abi.TokenAmount(util.UVarint(gas) * util.UVarint(price))
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">_makeInvocInput</span><span class="p">(</span><span class="nx">message</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span><span class="p">)</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocInput</span><span class="p">{</span>
		<span class="nx">To</span><span class="p">:</span>     <span class="nx">message</span><span class="p">.</span><span class="nf">To</span><span class="p">(),</span> <span class="c1">// Receiver address is resolved during execution.
</span><span class="c1"></span>		<span class="nx">Method</span><span class="p">:</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Method</span><span class="p">(),</span>
		<span class="nx">Params</span><span class="p">:</span> <span class="nx">message</span><span class="p">.</span><span class="nf">Params</span><span class="p">(),</span>
		<span class="nx">Value</span><span class="p">:</span>  <span class="nx">message</span><span class="p">.</span><span class="nf">Value</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Builds a message for paying block reward to a miner&#39;s owner.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">_makeBlockRewardMessage</span><span class="p">(</span><span class="nx">state</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">penalty</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">gasReward</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span> <span class="p">{</span>
	<span class="nx">params</span> <span class="o">:=</span> <span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">penalty</span><span class="p">)</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// serialize other inputs to BlockRewardMessage or get this from query in RewardActor
</span><span class="c1"></span>
	<span class="nx">sysActor</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage_I</span><span class="p">{</span>
		<span class="nx">From_</span><span class="p">:</span>       <span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">,</span>
		<span class="nx">To_</span><span class="p">:</span>         <span class="nx">builtin</span><span class="p">.</span><span class="nx">RewardActorAddr</span><span class="p">,</span>
		<span class="nx">Method_</span><span class="p">:</span>     <span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_RewardActor_AwardBlockReward</span><span class="p">,</span>
		<span class="nx">Params_</span><span class="p">:</span>     <span class="nx">params</span><span class="p">,</span>
		<span class="nx">CallSeqNum_</span><span class="p">:</span> <span class="nx">sysActor</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">(),</span>
		<span class="nx">Value_</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>
		<span class="nx">GasPrice_</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>
		<span class="nx">GasLimit_</span><span class="p">:</span>   <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_SentinelUnlimited</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Builds a message for submitting ElectionPost on behalf of a miner actor.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">_makeElectionPoStMessage</span><span class="p">(</span><span class="nx">state</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">minerActorAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span> <span class="p">{</span>
	<span class="nx">sysActor</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage_I</span><span class="p">{</span>
		<span class="nx">From_</span><span class="p">:</span>       <span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">,</span>
		<span class="nx">To_</span><span class="p">:</span>         <span class="nx">minerActorAddr</span><span class="p">,</span>
		<span class="nx">Method_</span><span class="p">:</span>     <span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMinerActor_OnVerifiedElectionPoSt</span><span class="p">,</span>
		<span class="nx">Params_</span><span class="p">:</span>     <span class="kc">nil</span><span class="p">,</span>
		<span class="nx">CallSeqNum_</span><span class="p">:</span> <span class="nx">sysActor</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">(),</span>
		<span class="nx">Value_</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>
		<span class="nx">GasPrice_</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>
		<span class="nx">GasLimit_</span><span class="p">:</span>   <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_SentinelUnlimited</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Builds a message for invoking the cron actor tick.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">_makeCronTickMessage</span><span class="p">(</span><span class="nx">state</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span> <span class="p">{</span>
	<span class="nx">sysActor</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage_I</span><span class="p">{</span>
		<span class="nx">From_</span><span class="p">:</span>       <span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">,</span>
		<span class="nx">To_</span><span class="p">:</span>         <span class="nx">builtin</span><span class="p">.</span><span class="nx">CronActorAddr</span><span class="p">,</span>
		<span class="nx">Method_</span><span class="p">:</span>     <span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_CronActor_EpochTick</span><span class="p">,</span>
		<span class="nx">Params_</span><span class="p">:</span>     <span class="kc">nil</span><span class="p">,</span>
		<span class="nx">CallSeqNum_</span><span class="p">:</span> <span class="nx">sysActor</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">(),</span>
		<span class="nx">Value_</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>
		<span class="nx">GasPrice_</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>
		<span class="nx">GasLimit_</span><span class="p">:</span>   <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_SentinelUnlimited</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_msgCID</span><span class="p">(</span><span class="nx">msg</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span><span class="p">)</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>





<h4 id="vminterpreterregistry"><code>vm/interpreter/registry</code></h4>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">interpreter</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;errors&#34;</span>

	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">accact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/account&#34;</span>
	<span class="nx">cronact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/cron&#34;</span>
	<span class="nx">initact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/init&#34;</span>
	<span class="nx">smarkact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_market&#34;</span>
	<span class="nx">spowact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_power&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">ErrActorNotFound</span> <span class="p">=</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Actor Not Found&#34;</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">staticActorCodeRegistry</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">actorCodeRegistry</span><span class="p">{}</span>

<span class="kd">type</span> <span class="nx">actorCodeRegistry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">code</span> <span class="kd">map</span><span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">]</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">actorCodeRegistry</span><span class="p">)</span> <span class="nf">_registerActor</span><span class="p">(</span><span class="nx">id</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span> <span class="nx">actor</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">code</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actor</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">actorCodeRegistry</span><span class="p">)</span> <span class="nf">_loadActor</span><span class="p">(</span><span class="nx">id</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">a</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">code</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrActorNotFound</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">a</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">id</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">,</span> <span class="nx">actor</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">staticActorCodeRegistry</span><span class="p">.</span><span class="nf">_registerActor</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">actor</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">LoadActor</span><span class="p">(</span><span class="nx">id</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorCodeID</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorCode</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">staticActorCodeRegistry</span><span class="p">.</span><span class="nf">_loadActor</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// init is called in Go during initialization of a program.
</span><span class="c1">// this is an idiomatic way to do this. Implementations should approach this
</span><span class="c1">// however they wish. The point is to initialize a static registry with
</span><span class="c1">// built in pure types that have the code for each actor. Once we have
</span><span class="c1">// a way to load code from the StateTree, use that instead.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="nf">_registerBuiltinActors</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_registerBuiltinActors</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// TODO
</span><span class="c1"></span>
	<span class="nx">cron</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">cronact</span><span class="p">.</span><span class="nx">CronActor</span><span class="p">{}</span>

	<span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">InitActorCodeID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">initact</span><span class="p">.</span><span class="nx">InitActor</span><span class="p">{})</span>
	<span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">CronActorCodeID</span><span class="p">,</span> <span class="nx">cron</span><span class="p">)</span>
	<span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">AccountActorCodeID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">accact</span><span class="p">.</span><span class="nx">AccountActor</span><span class="p">{})</span>
	<span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorCodeID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">spowact</span><span class="p">.</span><span class="nx">StoragePowerActor</span><span class="p">{})</span>
	<span class="nf">RegisterActor</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMarketActorCodeID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageMarketActor</span><span class="p">{})</span>

	<span class="c1">// wire in CRON actions.
</span><span class="c1"></span>	<span class="c1">// TODO: move this to CronActor&#39;s constructor method
</span><span class="c1"></span>	<span class="nx">cron</span><span class="p">.</span><span class="nx">Entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cron</span><span class="p">.</span><span class="nx">Entries</span><span class="p">,</span> <span class="nx">cronact</span><span class="p">.</span><span class="nx">CronTableEntry</span><span class="p">{</span>
		<span class="nx">ToAddr</span><span class="p">:</span>    <span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
		<span class="nx">MethodNum</span><span class="p">:</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_OnEpochTickEnd</span><span class="p">,</span>
	<span class="p">})</span>

	<span class="nx">cron</span><span class="p">.</span><span class="nx">Entries</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">cron</span><span class="p">.</span><span class="nx">Entries</span><span class="p">,</span> <span class="nx">cronact</span><span class="p">.</span><span class="nx">CronTableEntry</span><span class="p">{</span>
		<span class="nx">ToAddr</span><span class="p">:</span>    <span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMarketActorAddr</span><span class="p">,</span>
		<span class="nx">MethodNum</span><span class="p">:</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMarketActor_OnEpochTickEnd</span><span class="p">,</span>
	<span class="p">})</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain">

<h2 class="section-header">
  <strong>Blockchain</strong>
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain">
        

        <strong>Blockchain</strong>

        
            <br /><br /><i class="menuIcon">üì¶</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct">
        
            <i class="statusIcon">‚úÖ</i>
        

        Blocks

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__block">
        

        Block

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__tipset">
        

        Tipset

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__chain">
        

        Chain

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__chain_manager">
        

        Chain Manager

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__struct__block_producer">
        

        Block Producer

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool">
        
            <i class="statusIcon">üõë</i>
        

        Message Pool

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool__message_syncer">
        

        Message Syncer

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__message_pool__message_storage">
        

        Message Storage

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__chainsync">
        
            <i class="statusIcon">‚úÖ</i>
        

        ChainSync

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__storage_power_consensus">
        
            <i class="statusIcon">‚úÖ</i>
        

        Storage Power Consensus

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor">
        

        Storage Power Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>

<p>The Filecoin Blockchain is a distributed virtual machine that achieves consensus, processes messages, accounts for storage, and maintains security in the Filecoin Protocol. It is the main interface linking various actors in the Filecoin system.</p>
<p>It includes:</p>
<ul>
<li>A <a href="./#systems__filecoin_blockchain__message_pool___index">Message Pool</a> subsystem that nodes use to track and propagate messages related to the storage market throughout a gossip network.</li>
<li>A <a href="./#systems__filecoin_vm">VM - Virtual Machine</a> subsystem used to interpret and execute messages in order to update system state.</li>
<li>A <a href="./#systems__filecoin_vm__state_tree___index"></a> subsystem which manages the creation and maintenance of state trees (the system state) deterministically generated by the vm from a given subchain.</li>
<li>A <a href="./#systems__filecoin_blockchain__chainsync">ChainSync - synchronizing the Blockchain</a> susbystem that tracks and propagates validated message blocks, maintaining sets of candidate chains on which the miner may mine and running syntactic validation on incoming blocks.</li>
<li>A <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem which tracks <a href="./#systems__filecoin_mining__storage_mining">storage</a> state for a given chain and helps the blockchain system choose subchains to extend and blocks to include in them.</li>
</ul>
<p>And also:</p>
<ul>
<li>A {{ <!-- raw HTML omitted --> }} &ndash; which maintains a given chain&rsquo;s state, providing facilities to other blockchain subsystems which will query state about the latest chain in order to run, and ensuring incoming blocks are semantically validated before inclusion into the chain.</li>
<li>A {{ <!-- raw HTML omitted --> }} &ndash; which is called in the event of a successful leader election in order to produce a new block that will extend the current heaviest chain before forwarding it to the syncer for propagation.</li>
</ul>
<p>At a high-level, the Filecoin blockchain grows through successive rounds of leader election in which a number of miners are elected to generate a block, whose inclusion in the chain will earn them block rewards.
Filecoin&rsquo;s blockchain runs on storage power. That is, its consensus algorithm by which miners agree on which subchain to mine is predicated on the amount of storage backing that subchain. At a high-level, the <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem maintains a <em>Power Table</em> that tracks the amount of storage <a href="./#systems__filecoin_mining__storage_mining">storage miner actors</a> have contributed to the network through <em>Sector commitments</em> and <em>Proofs of Spacetime</em>.</p>
<p>Most of the functions of the Filecoin blockchain system are detailed in the code below.</p>


</div>


  
    








<div id="systems__filecoin_blockchain__struct">

<h3 class="section-header">
  Blocks
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_blockchain__struct__block">

<h4 class="section-header">
  Block
</h4>

<div class="section-content">




































<div id="systems__filecoin_blockchain__struct__block__block"></div>
<h5 id="block">Block</h5>
<p>The Block is a unit of the Filecoin blockchain.</p>
<p>A block header contains information relevant to a particular point in time over which the network may achieve consensus.</p>
<!-- raw HTML omitted -->



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>

<span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="kd">type</span> <span class="nx">ChainWeight</span> <span class="nx">UVarint</span>
<span class="kd">type</span> <span class="nx">MessageReceipt</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>

<span class="c1">// On-chain representation of a block header.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">BlockHeader</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Chain linking
</span><span class="c1"></span>    <span class="nx">Parents</span>                <span class="p">[</span><span class="o">&amp;</span><span class="nx">BlockHeader</span><span class="p">]</span>
    <span class="nx">ParentWeight</span>           <span class="nx">ChainWeight</span>
    <span class="c1">// State
</span><span class="c1"></span>    <span class="nx">ParentState</span>            <span class="o">&amp;</span><span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
    <span class="nx">ParentMessageReceipts</span>  <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">MessageReceipt</span><span class="p">]</span>  <span class="c1">// array-mapped trie ref
</span><span class="c1"></span>
    <span class="c1">// Consensus things
</span><span class="c1"></span>    <span class="nx">Epoch</span>                  <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">Timestamp</span>              <span class="nx">clock</span><span class="p">.</span><span class="nx">UnixTime</span>
    <span class="nx">Ticket</span>

    <span class="nx">Miner</span>                  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">ElectionPoStOutput</span>     <span class="nx">ElectionPoStVerifyInfo</span>

    <span class="c1">// Fork Signal bitfield with bits used to advertise support for
</span><span class="c1"></span>    <span class="c1">// proposed forks and reset if fork is executed.
</span><span class="c1"></span>    <span class="nx">ForkSignal</span>             <span class="kt">uint64</span>

    <span class="c1">// Proposed update
</span><span class="c1"></span>    <span class="nx">Messages</span>               <span class="o">&amp;</span><span class="nx">TxMeta</span>
    <span class="nx">BLSAggregate</span>           <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>

    <span class="c1">// Signatures
</span><span class="c1"></span>    <span class="nx">Signature</span>              <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>

    <span class="c1">//	SerializeSigned()            []byte
</span><span class="c1"></span>    <span class="c1">//	ComputeUnsignedFingerprint() []
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">TxMeta</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BLSMessages</span>   <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span><span class="p">]</span>  <span class="c1">// array-mapped trie
</span><span class="c1"></span>    <span class="nx">SECPMessages</span>  <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">SignedMessage</span><span class="p">]</span>  <span class="c1">// array-mapped trie
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Internal representation of a full block, with all messages.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Header</span>        <span class="nx">BlockHeader</span>
    <span class="nx">BLSMessages</span>   <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage</span><span class="p">]</span>
    <span class="nx">SECPMessages</span>  <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">SignedMessage</span><span class="p">]</span>
<span class="p">}</span>

<span class="c1">// HACK: All of the below was duplicated from posting.id
</span><span class="c1">// in order to get spec to compile. Check the actual source for details
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ElectionPoStVerifyInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Candidates</span>  <span class="p">[</span><span class="nx">PoStCandidate</span><span class="p">]</span>
    <span class="nx">Proof</span>       <span class="nx">PoStProof</span>
    <span class="nx">Randomness</span>  <span class="nx">PoStRandomness</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ChallengeTicketsCommitment</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// see sector
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PoStCandidate</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// see sector
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PoStRandomness</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// see sector
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PoStProof</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>

<span class="kd">type</span> <span class="nx">Ticket</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">VRFResult</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFResult</span>

    <span class="nx">Output</span>     <span class="nx">Bytes</span>                <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nf">DrawRandomness</span><span class="p">(</span><span class="nx">round</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Bytes</span>
    <span class="nf">ValidateSyntax</span><span class="p">()</span> <span class="kt">bool</span>
    <span class="nf">Verify</span><span class="p">(</span>
        <span class="nx">input</span>           <span class="nx">Bytes</span>
        <span class="nx">pk</span>              <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFPublicKey</span>
        <span class="nx">minerActorAddr</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div>





<h5 id="block-syntax-validation">Block syntax validation</h5>
<p>Syntax validation refers to validation that may be performed on a block and its messages
without reference to outside information such as the parent state tree.</p>
<p>An invalid block must not be transmitted or referenced as a parent.</p>
<p>A syntactically valid block header must decode into fields matching the type definition below.</p>
<p>A syntactically valid header must have:</p>
<ul>
<li>between 1 and <code>5*ec.ExpectedLeaders</code> <code>Parents</code> CIDs if <code>Epoch</code> is greater than zero (else empty <code>Parents</code>),</li>
<li>a non-negative <code>ParentWeight</code>,</li>
<li>a <code>Miner</code> address which is an ID-address,</li>
<li>a non-negative <code>Epoch</code>,</li>
<li>a positive <code>Timestamp</code>,</li>
<li>a <code>Ticket</code> with non-empty <code>VRFResult</code>,</li>
<li><code>ElectionPoStOutput</code> containing:
<ul>
<li>a <code>Candidates</code> array with between 1 and <code>EC.ExpectedLeaders</code> values (inclusive),</li>
<li>a non-empty <code>PoStRandomness</code> field,</li>
<li>a non-empty <code>Proof</code> field,</li>
</ul>
</li>
<li>a non-empty <code>ForkSignal</code> field.</li>
</ul>
<p>A syntactically valid full block must have:</p>
<ul>
<li>all referenced messages syntactically valid,</li>
<li>all referenced parent receipts syntactically valid,</li>
<li>the sum of the serialized sizes of the block header and included messages is no greater than <code>block.BlockMaxSize</code>,</li>
<li>the sum of the gas limit of all explicit messages is no greater than <code>block.BlockGasLimit</code>.</li>
</ul>
<p>Note that validation of the block signature requires access to the miner worker address and
public key from the parent tipset state, so signature validation forms part of semantic validation.
Similarly, message signature validation requires lookup of the public key associated with
each message&rsquo;s <code>From</code> account actor in the block&rsquo;s parent state.</p>
<h5 id="block-semantic-validation">Block semantic validation</h5>
<p>Semantic validation refers to validation that requires reference to information outside the block
header and messages themselves, in particular the parent tipset and state on which the block is built.</p>
<p>A semantically valid block must have:</p>
<ul>
<li><code>Parents</code> listed in lexicographic order of their header&rsquo;s <code>Ticket</code>,</li>
<li><code>Parents</code> all reference valid blocks and form a valid <a href="./#systems__filecoin_blockchain__struct__tipset___index"></a>,</li>
<li><code>ParentState</code> matching the state tree produced by executing the parent tipset&rsquo;s messages (as defined by the VM interpreter) against that tipset&rsquo;s parent state,</li>
<li><code>ParentMessageReceipts</code> identifying the receipt list produced by parent tipset execution, with one receipt for each unique message from the parent tipset,</li>
<li><code>ParentWeight</code> matching the weight of the chain up to and including the parent tipset,</li>
<li><code>Epoch</code> greater than that of its parents, and
<ul>
<li>not in the future according to the node&rsquo;s local clock reading of the current epoch,
<ul>
<li>blocks with future epochs should not be rejected, but should not be evaluated (validated or included in a tipset) until the appropriate epoch</li>
</ul>
</li>
<li>not farther in the past than the soft finality as defined by SPC $<a href="./#algorithms__expected_consensus__finality">EC Finality</a>,
<ul>
<li>this rule only applied when receiving new gossip blocks (i.e. from the current chain head), not when syncing to the chain for the first time (e.g.)</li>
</ul>
</li>
</ul>
</li>
<li><code>Miner</code> that is active in the storage power table in the parent tipset state,</li>
<li>a <code>Ticket</code> derived from the minimum ticket from the parent tipset&rsquo;s block headers,
<ul>
<li><code>Ticket.VRFResult</code> validly signed by the <code>Miner</code> actor&rsquo;s worker account public key,</li>
</ul>
</li>
<li><code>ElectionPoStOutput</code> yielding winning partial tickets that were generated validly,
<ul>
<li><code>ElectionPoSt.Randomness</code> is well formed and appropriately drawn from a past tipset according to the PoStLookback,</li>
<li><code>ElectionPoSt.Proof</code> is a valid proof verifying the generation of the <code>ElectionPoSt.Candidates</code> from the <code>Miner</code>'s eligible sectors,</li>
<li><code>ElectionPoSt.Candidates</code> contains well formed <code>PoStCandidate</code>s each of which has a <code>PartialTicket</code> yielding a winning <code>ChallengeTicket</code> in Expected Consensus.</li>
</ul>
</li>
<li>a <code>Timestamp</code> in seconds lying within the quantized epoch window implied by the genesis block&rsquo;s timestamp and the block&rsquo;s <code>Epoch</code>,</li>
<li>all SECP messages correctly signed by their sending actor&rsquo;s worker account key,</li>
<li>a <code>BLSAggregate</code> signature that signs the array of CIDs of the BLS messages referenced by the block
with their sending actor&rsquo;s key.</li>
<li>a valid <code>Signature</code> over the block header&rsquo;s fields from the block&rsquo;s <code>Miner</code> actor&rsquo;s worker account public key.</li>
</ul>
<p>There is no semantic validation of the messages included in a block beyond validation of their signatures.
If all messages included in a block are syntactically valid then they may be executed and produce a receipt.</p>
<p>A chain sync system may perform syntactic and semantic validation in stages in order to minimize unnecessary resource expenditure.</p>


</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__struct__tipset">

<h4 class="section-header">
  Tipset
</h4>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__struct__tipset__tipset"></div>
Expected Consensus probabilistically elects multiple leaders in each epoch meaning a Filecoin chain may contain zero or multiple blocks at each epoch (one per elected miner). Blocks from the same epoch are assembled into tipsets. The <a href="./#systems__filecoin_vm__interpreter___index"></a> modifies the Filecoin state tree by executing all messages in a tipset (after de-duplication of identical messages included in more than one block).</p>
<p>Each block references a parent tipset and validates <em>that tipset&rsquo;s state</em>, while proposing messages to be included for the current epoch. The state to which a new block&rsquo;s messages apply cannot be known until that block is incorporated into a tipset. It is thus not meaningful to execute the messages from a single block in isolation: a new state tree is only known once all messages in that block&rsquo;s tipset are executed.</p>
<p>A valid tipset contains a non-empty collection of blocks that have distinct miners and all specify identical:</p>
<ul>
<li><code>Epoch</code></li>
<li><code>Parents</code></li>
<li><code>ParentWeight</code></li>
<li><code>StateRoot</code></li>
<li><code>ReceiptsRoot</code></li>
</ul>
<p>The blocks in a tipset are canonically ordered by the lexicographic ordering of the bytes in each block&rsquo;s ticket, breaking ties with the bytes of the CID of the block itself.</p>
<p>Due to network propagation delay, it is possible for a miner in epoch N+1 to omit valid blocks mined at epoch N from their parent tipset. This does not make the newly generated block invalid, it does however reduce its weight and chances of being part of the canonical chain in the protocol as defined by EC&rsquo;s <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a> function.</p>
<p>Block producers are expected to coordinate how they select messages for inclusion in blocks in order to avoid duplicates and thus maximize their expected earnings from transaction fees (see <a href="./#systems__filecoin_blockchain__message_pool___index">Message Pool</a>).</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">clock</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/clock&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>

<span class="kd">type</span> <span class="nx">Tipset</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BlockCIDs</span>           <span class="p">[</span><span class="o">&amp;</span><span class="nx">block</span><span class="p">.</span><span class="nx">BlockHeader</span><span class="p">]</span>
    <span class="nx">Blocks</span>              <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">BlockHeader</span><span class="p">]</span>

    <span class="nf">Has</span><span class="p">(</span><span class="nx">b</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span>  <span class="kt">bool</span>                  <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">Parents</span>             <span class="nx">Tipset</span>                <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">StateTree</span>           <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>          <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">Weight</span>              <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span>     <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nx">Epoch</span>               <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>        <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>

    <span class="c1">// Returns the largest timestamp fom the tipset&#39;s blocks.
</span><span class="c1"></span>    <span class="nf">LatestTimestamp</span><span class="p">()</span>   <span class="nx">clock</span><span class="p">.</span><span class="nx">UnixTime</span>        <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="c1">// Returns the lexicographically smallest ticket from the tipset&#39;s blocks.
</span><span class="c1"></span>    <span class="nf">MinTicket</span><span class="p">()</span>         <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span>          <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__struct__chain">

<h4 class="section-header">
  Chain
</h4>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__struct__chain__chain"></div>
A Chain is a sequence of tipsets, linked together. It is a single history of execution in the Filecoin blockchain. Randomness is drawn from the chain, as mentioned in <a href="./#systems__filecoin_blockchain__storage_power_consensus__ticket_chain">Ticket Chain</a>.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>

<span class="kd">type</span> <span class="nx">Chain</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">HeadTipset</span> <span class="nx">Tipset</span>

    <span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Tipset</span>
    <span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span>

    <span class="c1">// call by StorageMiningSubsystem during block production
</span><span class="c1"></span>    <span class="nf">GetTicketProductionRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span>

    <span class="c1">// call by StorageMiningSubsystem in sealing sector
</span><span class="c1"></span>    <span class="nf">GetSealRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span>

    <span class="c1">// call by StorageMiningSubsystem after sealing
</span><span class="c1"></span>    <span class="nf">GetPoStChallengeRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span>
<span class="p">}</span>

<span class="c1">// Checkpoint represents a particular block to use as a trust anchor
</span><span class="c1">// in Consensus and ChainSync
</span><span class="c1">//
</span><span class="c1">// Note: a Block uniquely identifies a tipset (the parents)
</span><span class="c1">// from here, we may consider many tipsets that _include_ Block
</span><span class="c1">// but we must indeed include t and not consider tipsets that
</span><span class="c1">// fork from Block.Parents, but do not include Block.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Checkpoint</span> <span class="o">&amp;</span><span class="nx">block</span><span class="p">.</span><span class="nx">BlockHeader</span>

<span class="c1">// SoftCheckpoint is a checkpoint that Filecoin nodes may use as they
</span><span class="c1">// gain confidence in the blockchain. It is a unilateral checkpoint,
</span><span class="c1">// and derived algorithmically from notions of probabilistic consensus
</span><span class="c1">// and finality.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SoftCheckpoint</span> <span class="nx">Checkpoint</span>

<span class="c1">// TrustedCheckpoint is a Checkpoint that is trusted by the broader
</span><span class="c1">// Filecoin Network. These TrustedCheckpoints are arrived at through
</span><span class="c1">// the higher level economic consensus that surrounds Filecoin.
</span><span class="c1">// TrustedCheckpoints:
</span><span class="c1">// - MUST be at least 200,000 blocks old (&gt;1mo)
</span><span class="c1">// - MUST be at least
</span><span class="c1">// - MUST be widely known and accepted
</span><span class="c1">// - MAY ship with Filecoin software implementations
</span><span class="c1">// - MAY be propagated through other side-channel systems
</span><span class="c1">// For more, see the Checkpoints section.
</span><span class="c1">// TODO: consider renaming as EconomicCheckpoint
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">TrustedCheckpoint</span> <span class="nx">Checkpoint</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">chain</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">node_base</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/node_base&#34;</span>
<span class="p">)</span>

<span class="c1">// Returns the tipset at or immediately prior to `epoch`.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Tipset</span> <span class="p">{</span>
	<span class="nx">current</span> <span class="o">:=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">HeadTipset</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">current</span><span class="p">.</span><span class="nf">Epoch</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">epoch</span> <span class="p">{</span>
		<span class="nx">current</span> <span class="p">=</span> <span class="nx">current</span><span class="p">.</span><span class="nf">Parents</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">current</span>
<span class="p">}</span>

<span class="c1">// Draws randomness from the tipset at or immediately prior to `epoch`.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="nx">ts</span> <span class="o">:=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ts</span><span class="p">.</span><span class="nf">MinTicket</span><span class="p">().</span><span class="nf">DrawRandomness</span><span class="p">(</span><span class="nx">epoch</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">GetTicketProductionRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="o">-</span> <span class="nx">node_base</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_TICKET</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">GetSealRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="o">-</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_SEAL</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">GetPoStChallengeRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="o">-</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_POST</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__struct__chain_manager">

<h4 class="section-header">
  Chain Manager
</h4>

<div class="section-content">




































<p>The <em>Chain Manager</em> is a central component in the blockchain system. It tracks and updates competing subchains received by a given node in order to select the appropriate blockchain head: the latest block of the heaviest subchain it is aware of in the system.</p>
<p>In so doing, the <em>chain manager</em> is the central subsystem that handles bookkeeping for numerous other systems in a Filecoin node and exposes convenience methods for use by those systems, enabling systems to sample randomness from the chain for instance, or to see which block has been finalized most recently.</p>
<p>The chain manager interfaces and functions are included here, but we expand on important details below for clarity.</p>
<h5 id="chain-expansion">Chain Expansion</h5>
<h6 id="incoming-block-reception">Incoming block reception</h6>
<p>Once a block has been received and passes syntactic and semantic validation it must be added to the local datastore, regardless whether it is understood as the best tip at this point. Future blocks from other miners may be mined on top of it and in that case we will want to have it around to avoid refetching.</p>
<!-- raw HTML omitted -->
<p>Chain selection is a crucial component of how the Filecoin blockchain works. Every chain has an associated weight accounting for the number of blocks mined on it and so the power (storage) they track. It is always preferable to mine atop a heavier Tipset rather than a lighter one. While a miner may be foregoing block rewards earned in the past, this lighter chain is likely to be abandoned by other miners forfeiting any block reward earned as miners converge on a final chain. For more on this, see <a href="expected-consensus.md#chain-selection">chain selection</a> in the Expected Consensus spec.</p>
<p>However, ahead of finality, a given subchain may be abandoned in order of another, heavier one mined in a given round. In order to rapidly adapt to this, the chain manager must maintain and update all subchains being considered up to finality.</p>
<p>That is, for every incoming block, even if the incoming block is not added to the current heaviest tipset, the chain manager should add it to the appropriate subchain it is tracking, or keep track of it independently until either:</p>
<ul>
<li>it is able to do so, through the reception of another block in that subchain</li>
<li>it is able to discard it, as that block was mined before finality</li>
</ul>
<p>We give an example of how this could work in the block reception algorithm.</p>
<h6 id="chaintipsmanager">ChainTipsManager</h6>
<p>The Chain Tips Manager is a subcomponent of Filecoin consensus that is technically up to the implementer, but since the pseudocode in previous sections reference it, it is documented here for clarity.</p>
<p>The Chain Tips Manager is responsible for tracking all live tips of the Filecoin blockchain, and tracking what the current &lsquo;best&rsquo; tipset is.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Returns the ticket that is at round &#39;r&#39; in the chain behind &#39;head&#39;
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TicketFromRound</span><span class="p">(</span><span class="nx">head</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">Round</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// Returns the tipset that contains round r (Note: multiple rounds&#39; worth of tickets may exist within a single block due to losing tickets being added to the eventually successfully generated block)
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">TipsetFromRound</span><span class="p">(</span><span class="nx">head</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">r</span> <span class="nx">Round</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// GetBestTipset returns the best known tipset. If the &#39;best&#39; tipset hasn&#39;t changed, then this
</span><span class="c1">// will return the previous best tipset.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">GetBestTipset</span><span class="p">()</span>

<span class="c1">// Adds the losing ticket to the chaintips manager so that blocks can be mined on top of it
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">AddLosingTicket</span><span class="p">(</span><span class="nx">parent</span> <span class="nx">Tipset</span><span class="p">,</span> <span class="nx">t</span> <span class="nx">Ticket</span><span class="p">)</span>
</code></pre></div>

</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__struct__block_producer">

<h4 class="section-header">
  Block Producer
</h4>

<div class="section-content">




































<div id="systems__filecoin_blockchain__struct__block_producer__block_producer"></div>
<h5 id="mining-blocks">Mining Blocks</h5>
<p>A miner registered with the storage power actor may begin generating and checking election tickets if it has proven storage meeting the <a href="./#systems__filecoin_blockchain__storage_power_consensus__min_miner_size">Minimum Miner Size</a> threshold requirement.</p>
<p>In order to do so, the miner must be running chain validation, and be keeping track of the most recent blocks received. A miner&rsquo;s new block will be based on parents from the previous epoch.</p>
<h6 id="block-creation">Block Creation</h6>
<p>Producing a block for epoch <code>H</code> requires computing a tipset for epoch <code>H-1</code> (or possibly a prior epoch,
if no blocks were received for that epoch). Using the state produced by this tipset, a miner can
scratch winning ElectionPoSt ticket(s).
Armed with the requisite <code>ElectionPoStOutput</code>, as well as a new randomness ticket generated in this epoch, a miner can produce a new block.</p>
<p>See <a href="./#systems__filecoin_vm__interpreter">VM Interpreter - Message Invocation (Outside VM)</a> for details of parent tipset evaluation, and <a href="./#systems__filecoin_blockchain__struct__block___index">Block</a> for constraints
on valid block header values.</p>
<p>To create a block, the eligible miner must compute a few fields:</p>
<ul>
<li><code>Parents</code> - the CIDs of the parent tipset&rsquo;s blocks.</li>
<li><code>ParentWeight</code> - the parent chain&rsquo;s weight (see <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a>).</li>
<li><code>ParentState</code> - the CID of the state root from the parent tipset state evaluation (see the <a href="./#systems__filecoin_vm__interpreter">VM Interpreter - Message Invocation (Outside VM)</a>).</li>
<li><code>ParentMessageReceipts</code> - the CID of the root of an AMT containing receipts produced while computing <code>ParentState</code>.</li>
<li><code>Epoch</code> - the block&rsquo;s epoch, derived from the <code>Parents</code> epoch and the number of epochs it took to generate this block.</li>
<li><code>Timestamp</code> - a Unix timestamp, in seconds, generated at block creation.</li>
<li><code>Ticket</code> - a new ticket generated from that in the prior epoch (see <a href="./#systems__filecoin_blockchain__storage_power_consensus__ticket_generation">Ticket Generation</a>).</li>
<li><code>Miner</code> - the block producer&rsquo;s miner actor address.</li>
<li><code>ElectionPoStVerifyInfo</code> - The byproduct of running an ElectionPoSt yielding requisite on-chain information (see <a href="./#algorithms__post__election_post">Election PoSt</a>), namely:
<ul>
<li>An array of <code>PoStCandidate</code> objects, all of which include a winning partial ticket used to run leader election.</li>
<li><code>PoStRandomness</code> used to challenge the miner&rsquo;s sectors and generate the partial tickets.</li>
<li>A <code>PoStProof</code> snark output to prove that the partial tickets were correctly generated.</li>
</ul>
</li>
<li><code>Messages</code> - The CID of a <code>TxMeta</code> object containing message proposed for inclusion in the new block:
<ul>
<li>Select a set of messages from the mempool to include in the block, satisfying block size and gas limits</li>
<li>Separate the messages into BLS signed messages and secpk signed messages</li>
<li><code>TxMeta.BLSMessages</code>: The CID of the root of an AMT comprising the bare <code>UnsignedMessage</code>s</li>
<li><code>TxMeta.SECPMessages</code>: the CID of the root of an AMT comprising the <code>SignedMessage</code>s</li>
</ul>
</li>
<li><code>BLSAggregate</code> - The aggregated signature of all messages in the block that used BLS signing.</li>
<li><code>Signature</code> - A signature with the miner&rsquo;s worker account private key (must also match the ticket signature) over the the block header&rsquo;s serialized representation (with empty signature).</li>
</ul>
<p>Note that the messages to be included in a block need not be evaluated in order to produce a valid block.
A miner may wish to speculatively evaluate the messages anyway in order to optimize for including
messages which will succeed in execution and pay the most gas.</p>
<p>The block reward is not evaluated when producing a block. It is paid when the block is included in a tipset in the following epoch.</p>
<p>The block&rsquo;s signature ensures integrity of the block after propagation, since unlike many PoW blockchains,
a winning ticket is found independently of block generation.</p>
<h6 id="block-broadcast">Block Broadcast</h6>
<p>An eligible miner broadcasts the completed block to the network and, assuming everything was done correctly,
the network will accept it and other miners will mine on top of it, earning the miner a block reward!</p>
<p>Miners should output their valid block as soon as it is produced, otherwise they risk other miners receiving the block after the EPOCH_CUTOFF and not including them.</p>
<h5 id="block-rewards">Block Rewards</h5>
<p>TODO: Rework this.</p>
<p>Over the entire lifetime of the protocol, 1,400,000,000 FIL (<code>TotalIssuance</code>) will be given out to miners. Each of the miners who produced a block in a tipset will receive a block reward.</p>
<p>Note: Due to jitter in EC, and the gregorian calendar, there may be some error in the issuance schedule over time. This is expected to be small enough that it&rsquo;s not worth correcting for. Additionally, since the payout mechanism is transferring from the network account to the miner, there is no risk of minting <em>too much</em> FIL.</p>
<p>TODO: Ensure that if a miner earns a block reward while undercollateralized, then <code>min(blockReward, requiredCollateral-availableBalance)</code> is garnished (transfered to the miner actor instead of the owner).</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain__message_pool">

<h3 class="section-header">
  Message Pool
</h3>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__message_pool__message_pool"></div>
The Message Pool is a subsystem in the Filecoin blockchain system. The message pool is acts as the interface between Filecoin nodes and a peer-to-peer network used for off-chain message transmission. It is used by nodes to maintain a set of messages to transmit to the Filecoin VM (for &ldquo;on-chain&rdquo; execution).</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>

<span class="kd">type</span> <span class="nx">MessagePoolSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// needs access to:
</span><span class="c1"></span>    <span class="c1">// - BlockchainSubsystem
</span><span class="c1"></span>    <span class="c1">//   - needs access to StateTree
</span><span class="c1"></span>    <span class="c1">//   - needs access to Messages mined into blocks (probably past finality)
</span><span class="c1"></span>    <span class="c1">//     to remove from the MessagePool
</span><span class="c1"></span>    <span class="c1">// - NetworkSubsystem
</span><span class="c1"></span>    <span class="c1">//   - needs access to MessagePubsub
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Important remaining questions:
</span><span class="c1"></span>    <span class="c1">// - how does BlockchainSubsystem.BlockReceiver handle asking for messages?
</span><span class="c1"></span>    <span class="c1">// - how do we note messages are now part of the blockchain
</span><span class="c1"></span>    <span class="c1">//   - how are they cleared from the mempool
</span><span class="c1"></span>    <span class="c1">// - do we need to have some sort of purge?
</span><span class="c1"></span>
    <span class="c1">// Stats returns information about the MessagePool contents.
</span><span class="c1"></span>    <span class="nf">Stats</span><span class="p">()</span> <span class="nx">MessagePoolStats</span>

    <span class="c1">// FindMessage receives a descriptor query q, and returns a set of
</span><span class="c1"></span>    <span class="c1">// messages currently in the mempool that match the Query constraints.
</span><span class="c1"></span>    <span class="c1">// q may have all, any, or no constraints specified.
</span><span class="c1"></span>    <span class="c1">// FindMessage(q MessageQuery) union {
</span><span class="c1"></span>    <span class="c1">//  [base.Message],
</span><span class="c1"></span>    <span class="c1">//  Error
</span><span class="c1"></span>    <span class="c1">// }
</span><span class="c1"></span>
    <span class="c1">// MostProfitableMessages returns messages that are most profitable
</span><span class="c1"></span>    <span class="c1">// to mine for this miner.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Note: This is where algorithms about chosing best messages given
</span><span class="c1"></span>    <span class="c1">//       many leaders should go.
</span><span class="c1"></span>    <span class="nf">GetMostProfitableMessages</span><span class="p">(</span><span class="nx">miner</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">SignedMessage</span><span class="p">]</span>

    <span class="c1">// messageSyncer to manager incoming and outgoing messages
</span><span class="c1"></span>    <span class="nx">Syncer</span> <span class="nx">MessageSyncer</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MessagePoolStats</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Size is the amount of messages in the MessagePool
</span><span class="c1"></span>    <span class="nx">Size</span> <span class="nx">UInt</span>
<span class="p">}</span>

<span class="c1">// MessageQuery is a descriptor used to find messages matching one or more
</span><span class="c1">// of the constraints specified.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MessageQuery</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="cm">/*
</span><span class="cm">  From   base.Address
</span><span class="cm">  To     base.Address
</span><span class="cm">  Method ActorMethodId
</span><span class="cm">  Params ActorMethodParams
</span><span class="cm">
</span><span class="cm">  ValueMin    TokenAmount
</span><span class="cm">  ValueMax    TokenAmount
</span><span class="cm">  GasPriceMin TokenAmount
</span><span class="cm">  GasPriceMax TokenAmount
</span><span class="cm">  GasLimitMin TokenAmount
</span><span class="cm">  GasLimitMax TokenAmount
</span><span class="cm">  */</span>
<span class="p">}</span>
</code></pre></div>





<p>Clients that use a message pool include:</p>
<ul>
<li>storage market provider and client nodes - for transmission of deals on chain</li>
<li>storage miner nodes - for transmission of PoSts, sector commitments, deals, and other operations tracked on chain</li>
<li>verifier nodes - for transmission of potential faults on chain</li>
<li>relayer nodes - for forwarding and discarding messages appropriately.</li>
</ul>
<p>The message pool subsystem is made of two components:</p>
<ul>
<li>The <a href="./#systems__filecoin_blockchain__message_pool__message_syncer">Message Syncer</a> &ndash; which receives and propagates messages.</li>
<li><a href="./#systems__filecoin_blockchain__message_pool__message_storage">Message Storage</a> &ndash; which caches messages according to a given policy.</li>
</ul>
<p>TODOs:</p>
<ul>
<li>discuss how messages are meant to propagate slowly/async</li>
<li>explain algorithms for choosing profitable txns</li>
</ul>


</div>


  
    








<div id="systems__filecoin_blockchain__message_pool__message_syncer">

<h4 class="section-header">
  Message Syncer
</h4>

<div class="section-content">




































<div id="systems__filecoin_blockchain__message_pool__message_syncer__message_syncer"></div>
<p>TODO:</p>
<ul>
<li>explain message syncer works</li>
<li>include the message syncer code</li>
</ul>
<h5 id="message-propagation">Message Propagation</h5>
<p>Messages are propagated over the libp2p pubsub channel <code>/fil/messages</code>. On this channel, every serialised <code>SignedMessage</code> is announced (see <a href="./#systems__filecoin_vm__message___index">Message</a>).</p>
<p>Upon receiving the message, its validity must be checked: the signature must be valid, and the account in question must have enough funds to cover the actions specified. If the message is not valid it should be dropped and must not be forwarded.</p>
<!-- raw HTML omitted -->


</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__message_pool__message_storage">

<h4 class="section-header">
  Message Storage
</h4>

<div class="section-content">




































<div id="systems__filecoin_blockchain__message_pool__message_storage__message_storage"></div>
<p>TODO:</p>
<ul>
<li>give sample algorithm for miner message selection in block production (to avoid dups)</li>
<li>give sample algorithm for message storage caching/purging policies.</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_blockchain__chainsync">

<h3 class="section-header">
  ChainSync - synchronizing the Blockchain
</h3>

<div class="section-content">




































<div id="systems__filecoin_blockchain__chainsync__chain_sync"></div>
<h4 id="what-is-blockchain-synchronization">What is blockchain synchronization?</h4>
<p>Blockchain synchronization (&ldquo;sync&rdquo;) is a key part of a blockchain system.
It handles retrieval and propagation of blocks and transactions (messages), and
thus in charge of distributed state replication.
<strong>This process is security critical &ndash; problems here can be catastrophic to the
operation of a blockchain.</strong></p>
<h4 id="what-is-chainsync">What is ChainSync?</h4>
<p><code>ChainSync</code> is the protocol Filecoin uses to synchronize its blockchain. It is
specific to Filecoin&rsquo;s choices in state representation and consensus rules,
but is general enough that it can serve other blockchains. <code>ChainSync</code> is a
group of smaller protocols, which handle different parts of the sync process.</p>
<h4 id="terms-and-concepts">Terms and Concepts</h4>
<ul>
<li><code>LastCheckpoint</code> the last hard social-consensus oriented checkpoint that <code>ChainSync</code> is aware of.
This consensus checkpoint defines the minimum finality, and a minimum of history to build on.
<code>ChainSync</code> takes <code>LastCheckpoint</code> on faith, and builds on it, never switching away from its history.</li>
<li><code>TargetHeads</code> a list of <code>BlockCIDs</code> that represent blocks at the fringe of block production.
These are the newest and best blocks <code>ChainSync</code> knows about. They are &ldquo;target&rdquo; heads because
<code>ChainSync</code> will try to sync to them. This list is sorted by &ldquo;likelihood of being the best chain&rdquo; (eg for now, simply <code>ChainWeight</code>)</li>
<li><code>BestTargetHead</code> the single best chain head <code>BlockCID</code> to try to sync to.
This is the first element of <code>TargetHeads</code></li>
</ul>
<h4 id="chainsync-summary">ChainSync Summary</h4>
<p>At a high level, <code>ChainSync</code> does the following:</p>
<ul>
<li><strong>Part 1: Verify internal state (<code>INIT</code> state below)</strong>
<ul>
<li>SHOULD verify data structures and validate local chain</li>
<li>Resource expensive verification MAY be skipped at nodes&rsquo; own risk</li>
</ul>
</li>
<li><strong>Part 2: Bootstrap to the network (<code>BOOTSTRAP</code>)</strong>
<ul>
<li>Step 1. Bootstrap to the network, and acquire a &ldquo;secure enough&rdquo; set of peers (more details below)</li>
<li>Step 2. Bootstrap to the <code>BlockPubsub</code> channels</li>
<li>Step 3. Listen and serve on Graphsync</li>
</ul>
</li>
<li><strong>Part 3: Synchronize trusted checkpoint state (<code>SYNC_CHECKPOINT</code>)</strong>
<ul>
<li>Step 1. Start with a <code>TrustedCheckpoint</code> (defaults to <code>GenesisCheckpoint</code>).</li>
<li>Step 2. Get the block it points to, and that block&rsquo;s parents</li>
<li>Step 3. Graphsync the <code>StateTree</code></li>
</ul>
</li>
<li><strong>Part 4: Catch up to the chain  (<code>CHAIN_CATCHUP</code>)</strong>
<ul>
<li>Step 1. Maintain a set of <code>TargetHeads</code> (<code>BlockCIDs</code>), and select the <code>BestTargetHead</code> from it</li>
<li>Step 2. Synchronize to the latest heads observed, validating blocks towards them (requesting intermediate points)</li>
<li>Step 3. As validation progresses, <code>TargetHeads</code> and <code>BestTargetHead</code> will likely change, as new blocks at the production fringe will arrive,
and some target heads or paths to them may fail to validate.</li>
<li>Step 4. Finish when node has &ldquo;caught up&rdquo; with <code>BestTargetHead</code> (retrieved all the state, linked to local chain, validated all the blocks, etc).</li>
</ul>
</li>
<li><strong>Part 5: Stay in sync, and participate in block propagation (<code>CHAIN_FOLLOW</code>)</strong>
<ul>
<li>Step 1. If security conditions change, go back to Part 4 (<code>CHAIN_CATCHUP</code>)</li>
<li>Step 2. Receive, validate, and propagate received <code>Blocks</code></li>
<li>Step 3. Now with greater certainty of having the best chain, finalize Tipsets, and advance chain state.</li>
</ul>
</li>
</ul>
<h4 id="libp2p-network-protocols">libp2p Network Protocols</h4>
<p>As a networking-heavy protocol, <code>ChainSync</code> makes heavy use of <code>libp2p</code>. In particular, we use three sets of protocols:</p>
<ul>
<li><strong><code>libp2p.PubSub</code> a family of publish/subscribe protocols to propagate recent <code>Blocks</code>.</strong>
The concrete protocol choice impacts <code>ChainSync</code>'s effectiveness, efficiency, and security dramatically.
For Filecoin v1.0 we will use <code>libp2p.Gossipsub</code>, a recent <code>libp2p</code> protocol that combines features and learnings
from many excellent PubSub systems. In the future, Filecoin may use other <code>PubSub</code> protocols. <em>Important Note:</em> is entirely
possible for Filecoin Nodes to run multiple versions simultaneously. That said, this specification <em>requires</em> that filecoin
nodes <code>MUST</code> connect and participate in the main channel, using <code>libp2p.Gossipsub</code>.</li>
<li><strong><code>libp2p.PeerDiscovery</code> a family of discovery protocols, to learn about peers in the network.</strong>
This is especially important for security because network &ldquo;Bootstrap&rdquo; is a difficult problem in peer-to-peer networks.
The set of peers we initially connect to may completely dominate our awareness of other peers, and therefore all state.
We use a union of <code>PeerDiscovery</code> protocols as each by itself is not secure or appropriate for users&rsquo; threat models.
The union of these provides a pragmatic and effective solution.
Discovery protocols marked as <strong>required</strong> MUST be included in implementations and will be provided by implementation teams.  Protocols marked as <strong>optional</strong> MAY be provided by implementation teams but can be built independently by third parties to augment bootstrap security.</li>
<li><strong><code>libp2p.DataTransfer</code> a family of protocols for transfering data</strong>
Filecoin Nodes must run <code>libp2p.Graphsync</code>.</li>
</ul>
<p>More concretely, we use these protocols:</p>
<ul>
<li><strong><code>libp2p.PeerDiscovery</code></strong>
<ul>
<li><strong>(required)</strong> <code>libp2p.BootstrapList</code> a protocol that uses a persistent and user-configurable list of semi-trusted
bootstrap peers. The default list includes a set of peers semi-trusted by the Filecoin Community.</li>
<li><strong>(optional)</strong> <code>libp2p.KademliaDHT</code> a dht protocol that enables random queries across the entire network</li>
<li><strong>(required)</strong> <code>libp2p.Gossipsub</code> a pub/sub protocol that includes &ldquo;prune peer exchange&rdquo; by default, disseminating peer info as part of operation</li>
<li><strong>(optional)</strong> <code>libp2p.PersistentPeerstore</code> a connectivity component that keeps persistent information about peers
observed in the network throughout the lifetime of the node. This is useful because we resume and continually
improve Bootstrap security.</li>
<li><strong>(optional)</strong> <code>libp2p.DNSDiscovery</code> to learn about peers via DNS lookups to semi-trusted peer aggregators</li>
<li><strong>(optional)</strong> <code>libp2p.HTTPDiscovery</code> to learn about peers via HTTP lookups to semi-trusted peer aggregators</li>
<li><strong>(optional)</strong> <code>libp2p.PEX</code> a general use peer exchange protocol distinct from pubsub peer exchange for 1:1 adhoc peer exchange</li>
</ul>
</li>
<li><strong><code>libp2p.PubSub</code></strong>
<ul>
<li><strong>(required)</strong> <code>libp2p.Gossipsub</code> the concrete <code>libp2p.PubSub</code> protocol <code>ChainSync</code> uses</li>
</ul>
</li>
<li><strong><code>libp2p.DataTransfer</code></strong>
<ul>
<li><strong>(required)</strong> <code>libp2p.Graphsync</code> the data transfer protocol nodes must support for providing blockchain and user data</li>
<li><strong>(optional)</strong> <code>BlockSync</code> a blockchain data transfer protocol that can be used by some nodes</li>
</ul>
</li>
</ul>
<h4 id="subcomponents">Subcomponents</h4>
<p>Aside from <code>libp2p</code>, <code>ChainSync</code> uses or relies on the following components:</p>
<ul>
<li>Libraries:
<ul>
<li><code>ipld</code> data structures, selectors, and protocols
<ul>
<li><code>ipld.GraphStore</code> local persistent storage for <code>chain</code> datastructures</li>
<li><code>ipld.Selector</code> a way to express requests for chain data structures</li>
<li><code>ipfs.GraphSync</code> a general-purpose <code>ipld</code> datastructure syncing protocol</li>
</ul>
</li>
</ul>
</li>
<li>Data Structures:
<ul>
<li>Data structures in the <code>chain</code> package: <code>Block, Tipset, Chain, Checkpoint ...</code></li>
<li><code>chainsync.BlockCache</code> a temporary cache of blocks, to constrain resource expended</li>
<li><code>chainsync.AncestryGraph</code> a datastructure to efficiently link <code>Blocks</code>, <code>Tipsets</code>, and <code>PartialChains</code></li>
<li><code>chainsync.ValidationGraph</code> a datastructure for efficient and secure validation of <code>Blocks</code> and <code>Tipsets</code></li>
</ul>
</li>
</ul>
<h5 id="graphsync-in-chainsync">Graphsync in ChainSync</h5>
<p><code>ChainSync</code> is written in terms of <code>Graphsync</code>. <code>ChainSync</code> adds blockchain and filecoin-specific
synchronization functionality that is critical for Filecoin security.</p>
<h6 id="rate-limiting-graphsync-responses-should">Rate Limiting Graphsync responses (SHOULD)</h6>
<p>When running Graphsync, Filecoin nodes must respond to graphsync queries. Filecoin requires nodes
to provide critical data structures to others, otherwise the network will not function. During
ChainSync, it is in operators&rsquo; interests to provide data structures critical to validating,
following, and participating in the blockchain they are on. However, this has limitations, and
some level of rate limiting is critical for maintaining security in the presence of attackers
who might issue large Graphsync requests to cause DOS.</p>
<p>We recommend the following:</p>
<ul>
<li><strong>Set and enforce batch size rate limits.</strong>
Force selectors to be shaped like: <code>LimitedBlockIpldSelector(blockCID, BatchSize)</code> for a single
constant <code>BatchSize = 1000</code>.
Nodes may push for this equilibrium by only providing <code>BatchSize</code> objects in responses,
even for pulls much larger than <code>BatchSize</code>. This forces subsequent pulls to be run, re-rooted
appropriately, and hints at other parties that they should be requesting with that <code>BatchSize</code>.</li>
<li><strong>Force all Graphsync queries for blocks to be aligned along cacheable bounderies.</strong>
In conjunction with a <code>BatchSize</code>, implementations should aim to cache the results of Graphsync
queries, so that they may propagate them to others very efficiently. Aligning on certain boundaries
(eg specific <code>ChainEpoch</code> limits) increases the likelihood many parties in the network will request
the same batches of content.
Another good cacheable boundary is the entire contents of a <code>Block</code> (<code>BlockHeader</code>, <code>Messages</code>,
<code>Signatures</code>, etc).</li>
<li><strong>Maintain per-peer rate-limits.</strong>
Use bandwidth usage to decide whether to respond and how much on a per-peer basis. Libp2p already
tracks bandwidth usage in each connection. This information can be used to impose rate limits in
Graphsync and other Filecoin protocols.</li>
<li><strong>Detect and react to  DOS: restrict operation.</strong>
The safest implementations will likely detect and react to DOS attacks. Reactions could include:
<ul>
<li>Smaller <code>Graphsync.BatchSize</code> limits</li>
<li>Fewer connections to other peers</li>
<li>Rate limit total Graphsync bandwidth</li>
<li>Assign Graphsync bandwidth based on a peer priority queue</li>
<li>Disconnect from and do not accept connections from unknown peers</li>
<li>Introspect Graphsync requests and filter/deny/rate limit suspicious ones</li>
</ul>
</li>
</ul>
<h5 id="previous-blocksync-protocol">Previous BlockSync protocol</h5>
<p>Prior versions of this spec recommended a <code>BlockSync</code> protocol. This protocol definition is
<a href="https://github.com/filecoin-project/specs/blob/prevspec/network-protocols.md#blocksync">available here</a>.
Filecoin nodes are libp2p nodes, and therefore may run a variety
of other protocols, including this <code>BlockSync</code> protocol. As with anything else in Filecoin, nodes
MAY opt to use additional protocols to achieve the results.
That said, Nodes MUST implement the version of <code>ChainSync</code> as described in this spec in order to
be considered implementations of Filecoin. Test suites will assume this protocol.</p>
<h4 id="chainsync-state-machine">ChainSync State Machine</h4>
<p><code>ChainSync</code> uses the following <em>conceptual</em> state machine. Since this is a <em>conceptual</em> state machine,
implementations MAY deviate from implementing precisely these states, or dividing them strictly.
Implementations MAY blur the lines between the states. If so, implementations MUST ensure security
of the altered protocol.</p>
<p>State Machine:</p>












<div class="diagram">

<span class="diagram-title">ChainSync State Machine</span>




(<a href="docs/systems/filecoin_blockchain/chainsync/chainsync_fsm.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_blockchain/chainsync/chainsync_fsm.dot.svg" />




</div>

<h5 id="chainsync-fsm-init">ChainSync FSM: <code>INIT</code></h5>
<ul>
<li>beginning state. no network connections, not synchronizing.</li>
<li>local state is loaded: internal data structures (eg chain, cache) are loaded</li>
<li><code>LastTrustedCheckpoint</code> is set the latest network-wide accepted <code>TrustedCheckpoint</code></li>
<li><code>FinalityTipset</code> is set to finality achieved in a prior protocol run.
<ul>
<li>Default: If no later <code>FinalityTipset</code> has been achieved, set <code>FinalityTipset</code> to <code>LastTrustedCheckpoint</code></li>
</ul>
</li>
<li><strong>Chain State and Finality</strong>:
<ul>
<li>In this state, the <strong>chain MUST NOT advance</strong> beyond whatever the node already has.</li>
<li>No new blocks are reported to consumers.</li>
<li>The chain state provided is whatever was loaded from prior executions (worst case is <code>LastTrustedCheckpoint</code>)</li>
</ul>
</li>
<li><strong>security conditions to transition out:</strong>
<ul>
<li>local state and data structures SHOULD be verified to be correct
<ul>
<li>this means validating any parts of the chain or <code>StateTree</code> the node has, from <code>LastTrustedCheckpoint</code> on.</li>
</ul>
</li>
<li><code>LastTrustedCheckpoint</code> is well-known across the Filecoin Network to be a true <code>TrustedCheckpoint</code>
<ul>
<li>this SHOULD NOT be verified in software, it SHOULD be verified by operators</li>
<li>Note: we ALWAYS have at least one <code>TrustedCheckpoint</code>, the <code>GenesisCheckpoint</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>transitions out:</strong>
<ul>
<li>once done verifying things: move to <code>BOOTSTRAP</code></li>
</ul>
</li>
</ul>
<h5 id="chainsync-fsm-bootstrap">ChainSync FSM: <code>BOOTSTRAP</code></h5>
<ul>
<li><code>network.Bootstrap()</code>: establish connections to peers until we satisfy security requirement
<ul>
<li>for better security, use many different <code>libp2p.PeerDiscovery</code> protocols</li>
</ul>
</li>
<li><code>BlockPubsub.Bootstrap()</code>: establish connections to <code>BlockPubsub</code> peers
<ul>
<li>The subscription is for both peer discovery and to start selecting best heads.
Listing on pubsub from the start keeps the node informed about potential head changes.</li>
</ul>
</li>
<li><code>Graphsync.Serve()</code>: set up a Graphsync service, that responds to others&rsquo; queries</li>
<li><strong>Chain State and Finality</strong>:
<ul>
<li>In this state, the <strong>chain MUST NOT advance</strong> beyond whatever the node already has.</li>
<li>No new blocks are reported to consumers.</li>
<li>The chain state provided is whatever was loaded from prior executions (worst case is <code>LastTrustedCheckpoint</code>).</li>
</ul>
</li>
<li><strong>security conditions to transition out:</strong>
<ul>
<li><code>Network</code> connectivity MUST have reached the security level acceptable for <code>ChainSync</code></li>
<li><code>BlockPubsub</code> connectivity MUST have reached the security level acceptable for <code>ChainSync</code></li>
<li>&ldquo;on time&rdquo; blocks MUST be arriving through <code>BlockPubsub</code></li>
</ul>
</li>
<li><strong>transitions out:</strong>
<ul>
<li>once bootstrap is deemed secure enough:
<ul>
<li>if node does not have the <code>Blocks</code> or <code>StateTree</code> corresponding to <code>LastTrustedCheckpoint</code>: move to <code>SYNC_CHECKPOINT</code></li>
<li>otherwise: move to <code>CHAIN_CATCHUP</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="chainsync-fsm-sync_checkpoint">ChainSync FSM: <code>SYNC_CHECKPOINT</code></h5>
<ul>
<li>While in this state:
<ul>
<li><code>ChainSync</code> is well-bootstrapped, but does not yet have the <code>Blocks</code> or <code>StateTree</code> for <code>LastTrustedCheckpoint</code></li>
<li><code>ChainSync</code> issues <code>Graphsync</code> requests to its peers randomly for the <code>Blocks</code> and <code>StateTree</code> for <code>LastTrustedCheckpoint</code>:
<ul>
<li><code>ChainSync</code>'s counterparts in other peers MUST provide the state tree.</li>
<li>It is only semi-rational to do so, so <code>ChainSync</code> may have to try many peers.</li>
<li>Some of these requests MAY fail.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Chain State and Finality</strong>:
<ul>
<li>In this state, the <strong>chain MUST NOT advance</strong> beyond whatever the node already has.</li>
<li>No new blocks are reported to consumers.</li>
<li>The chain state provided is the available <code>Blocks</code> and <code>StateTree</code> for <code>LastTrustedCheckpoint</code>.</li>
</ul>
</li>
<li><strong>Important Notes:</strong>
<ul>
<li><code>ChainSync</code> needs to fetch several blocks: the <code>Block</code> pointed at by <code>LastTrustedCheckpoint</code>, and its direct <code>Block.Parents</code>.</li>
<li>Nodes only need hashing to validate these <code>Blocks</code> and <code>StateTrees</code> &ndash; no block validation or state machine computation is needed.</li>
<li>The initial value of <code>LastTrustedCheckpoint</code> is <code>GenesisCheckpoint</code>, but it MAY be a value later in Chain history.</li>
<li><code>LastTrustedCheckpoint</code> enables efficient syncing by making the implicit economic consensus of chain history explicit.</li>
<li>By allowing fetching of the <code>StateTree</code> of <code>LastTrustedCheckpoint</code> via <code>Graphsync</code>, <code>ChainSync</code> can yield much more
efficient syncing than comparable blockchain synchronization protocols, as syncing and validation can start there.</li>
<li>Nodes DO NOT need to validate the chain from <code>GenesisCheckpoint</code>. <code>LastTrustedCheckpoint</code> MAY be a value later in Chain history.</li>
<li>Nodes DO NOT need to but MAY sync earlier <code>StateTrees</code> than <code>LastTrustedCheckpoint</code> as well.</li>
</ul>
</li>
<li>Pseudocode 1: a basic version of <code>SYNC_CHECKPOINT</code>:
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ChainSync</span><span class="p">)</span> <span class="nf">SyncCheckpoint</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">while</span> <span class="p">!</span><span class="nx">c</span><span class="p">.</span><span class="nf">HasCompleteStateTreeFor</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">LastTrustedCheckpoint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">selector</span> <span class="o">:=</span> <span class="nx">ipldselector</span><span class="p">.</span><span class="nf">SelectAll</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">LastTrustedCheckpoint</span><span class="p">)</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">Graphsync</span><span class="p">.</span><span class="nf">Pull</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Peers</span><span class="p">,</span> <span class="nx">sel</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">IpldStore</span><span class="p">)</span>
        <span class="c1">// Pull SHOULD NOT pull what c.IpldStore already has (check first)
</span><span class="c1"></span>        <span class="c1">// Pull SHOULD pull from different peers simultaneously
</span><span class="c1"></span>        <span class="c1">// Pull SHOULD be efficient (try different parts of the tree from many peers)
</span><span class="c1"></span>        <span class="c1">// Graphsync implementations may not offer these features. These features
</span><span class="c1"></span>        <span class="c1">// can be implemented on top of a graphsync that only pulls from a single
</span><span class="c1"></span>        <span class="c1">// peer and does not check local store first.
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="nx">c</span><span class="p">.</span><span class="nf">ChainCatchup</span><span class="p">()</span> <span class="c1">// on to CHAIN_CATCHUP
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div></li>
<li><strong>security conditions to transition out:</strong>
<ul>
<li><code>StateTree</code> for <code>LastTrustedCheckpoint</code> MUST be stored locally and verified (hashing is enough)</li>
</ul>
</li>
<li><strong>transitions out:</strong>
<ul>
<li>once node receives and verifies complete <code>StateTree</code> for <code>LastTrustedCheckpoint</code>: move to <code>CHAIN_CATCHUP</code></li>
</ul>
</li>
</ul>
<h5 id="chainsync-fsm-chain_catchup">ChainSync FSM: <code>CHAIN_CATCHUP</code></h5>
<ul>
<li>While in this state:
<ul>
<li><code>ChainSync</code> is well-bootstrapped, and has an initial <strong>trusted</strong> <code>StateTree</code> to start from.</li>
<li><code>ChainSync</code> is receiving latest <code>Blocks</code> from <code>BlockPubsub</code></li>
<li><code>ChainSync</code> starts fetching and validating blocks</li>
<li><code>ChainSync</code> has unvalidated blocks between <code>ChainSync.FinalityTipset</code> and <code>ChainSync.TargetHeads</code></li>
</ul>
</li>
<li><strong>Chain State and Finality</strong>:
<ul>
<li>In this state, the <strong>chain MUST NOT advance</strong> beyond whatever the node already has:
<ul>
<li><code>FinalityTipset</code> does not change.</li>
<li>No new blocks are reported to consumers/users of <code>ChainSync</code> yet.</li>
<li>The chain state provided is the available <code>Blocks</code> and <code>StateTree</code> for all available epochs,
specially the <code>FinalityTipset</code>.</li>
<li>finality must not move forward here because there are serious attack vectors where a node can be forced to end up on the wrong fork if finality advances before validation is complete up to the block production fringe.</li>
</ul>
</li>
<li>Validation must advance, all the way to the block production fringe:
<ul>
<li>Validate the whole chain, from <code>FinalityTipset</code> to <code>BestTargetHead</code></li>
<li>The node can reach <code>BestTargetHead</code> only to find out it was invalid, then has to update <code>BestTargetHead</code> with next best one, and sync to it
(without having advanced <code>FinalityTipset</code> yet, as otherwise we may end up on the wrong fork)</li>
</ul>
</li>
</ul>
</li>
<li><strong>security conditions to transition out:</strong>
<ul>
<li>Gaps between <code>ChainSync.FinalityTipset ... ChainSync.BestTargetHead</code> have been closed:
<ul>
<li>All <code>Blocks</code> and their content MUST be fetched, stored, linked, and validated locally.
This includes <code>BlockHeaders</code>, <code>Messages</code>, etc.</li>
<li>Bad heads have been expunged from <code>ChainSync.TargetHeads</code>. Bad heads include heads that initially
seemed good but turned out invalid, or heads that <code>ChainSync</code> has failed to connect (ie. cannot
fetch ancestors connecting back to <code>ChainSync.FinalityTipset</code> within a reasonable amount of time).</li>
<li>All blocks between <code>ChainSync.FinalityTipset ... ChainSync.TargetHeads</code> have been validated
This means all blocks <em>before</em> the best heads.</li>
</ul>
</li>
<li>Not under a temporary network partition</li>
</ul>
</li>
<li><strong>transitions out:</strong>
<ul>
<li>once gaps between <code>ChainSync.FinalityTipset ... ChainSync.TargetHeads</code> are closed: move to <code>CHAIN_FOLLOW</code></li>
<li>(Perhaps moving to <code>CHAIN_FOLLOW</code> when 1-2 blocks back in validation may be ok.
<ul>
<li>we dont know we have the right head until we validate it, so if other heads of similar height are right/better, we wont know till then.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="chainsync-fsm-chain_follow">ChainSync FSM: <code>CHAIN_FOLLOW</code></h5>
<ul>
<li>While in this state:
<ul>
<li><code>ChainSync</code> is well-bootstrapped, and has an initial <strong>trusted</strong> <code>StateTree</code> to start from.</li>
<li><code>ChainSync</code> fetches and validates blocks.</li>
<li><code>ChainSync</code> is receiving and validating latest <code>Blocks</code> from <code>BlockPubsub</code></li>
<li><code>ChainSync</code> DOES NOT have unvalidated blocks between <code>ChainSync.FinalityTipset</code> and <code>ChainSync.TargetHeads</code></li>
<li><code>ChainSync</code> MUST drop back to another state if security conditions change.</li>
<li>Keep a set of gap measures:
<ul>
<li><code>BlockGap</code> is the number of remaining blocks to validate between the Validated blocks and <code>BestTargetHead</code>.
<ul>
<li>(ie how many epochs do we need to validate to have validated <code>BestTargetHead</code>. does not include null blocks)</li>
</ul>
</li>
<li><code>EpochGap</code> is the number of epochs between the latest validated block, and <code>BestTargetHead</code> (includes null blocks).</li>
<li><code>MaxBlockGap = 2</code>, which means how many blocks may <code>ChainSync</code> fall behind on before switching back to <code>CHAIN_CATCHUP</code> (does not include null blocks)</li>
<li><code>MaxEpochGap = 10</code>, which means how many epochs may <code>ChainSync</code> fall behind on before switching back to <code>CHAIN_CATCHUP</code> (includes null blocks)</li>
</ul>
</li>
</ul>
</li>
<li><strong>Chain State and Finality</strong>:
<ul>
<li>In this state, the <strong>chain MUST advance</strong> as all the blocks up to <code>BestTargetHead</code> are validated.</li>
<li>New blocks are finalized as they cross the finality threshold (<code>ValidG.Heads[0].ChainEpoch - FinalityLookback</code>)</li>
<li>New finalized blocks are reported to consumers.</li>
<li>The chain state provided includes the <code>Blocks</code> and <code>StateTree</code> for the <code>Finality</code> epoch, as well as
candidate <code>Blocks</code> and <code>StateTrees</code> for unfinalized epochs.</li>
</ul>
</li>
<li><strong>security conditions to transition out:</strong>
<ul>
<li>Temporary network partitions (see <em>Detecting Network Partitions</em>).</li>
<li>Encounter gaps of <code>&gt;MaxBlockGap</code> or <code>&gt;MaxEpochGap</code> between Validated set and a new <code>ChainSync.BestTargetHead</code></li>
</ul>
</li>
<li><strong>transitions out:</strong>
<ul>
<li>if a temporary network partition is detected: move to <code>CHAIN_CATCHUP</code></li>
<li>if <code>BlockGap &gt; MaxBlockGap</code>: move to <code>CHAIN_CATCHUP</code></li>
<li>if <code>EpochGap &gt; MaxEpochGap</code>: move to <code>CHAIN_CATCHUP</code></li>
<li>if node is shut down: move to <code>INIT</code></li>
</ul>
</li>
</ul>
<h4 id="block-fetching-validation-and-propagation">Block Fetching, Validation, and Propagation</h4>
<h5 id="notes-on-changing-targetheads-while-syncing">Notes on changing <code>TargetHeads</code> while syncing</h5>
<ul>
<li><code>TargetHeads</code> is changing, as <code>ChainSync</code> must be aware of the best heads at any time. reorgs happen, and our first set of peers could&rsquo;ve been bad, we keep discovering others.
<ul>
<li>Hello protocol is good, but it&rsquo;s polling. unless node is constantly polllng, wont see all the heads.</li>
<li><code>BlockPubsub</code> gives us the realtime view into what&rsquo;s actually going on.</li>
<li>weight can also be close between 2+ possible chains (long-forked), and <code>ChainSync</code> must select the right one (which, we may not be able to distinguish until validating all the way)</li>
</ul>
</li>
<li>fetching + validation are strictly faster per round on average than blocks produced/block time (if they&rsquo;re not, will always fall behind), so we definitely catch up eventually (and even quickly). the last couple rounds can be close (&ldquo;almost got it, almost got it, there&rdquo;).</li>
</ul>
<h5 id="general-notes-on-fetching-blocks">General notes on fetching Blocks</h5>
<ul>
<li><code>ChainSync</code> selects and maintains a set of the most likely heads to be correct from among those received
via <code>BlockPubsub</code>. As more blocks are received, the set of <code>TargetHeads</code> is reevaluated.</li>
<li><code>ChainSync</code> fetches <code>Blocks</code>, <code>Messages</code>, and <code>StateTree</code> through the <code>Graphsync</code> protocol.</li>
<li><code>ChainSync</code> maintains sets of <code>Blocks/Tipsets</code> in <code>Graphs</code> (see <code>ChainSync.id</code>)</li>
<li><code>ChainSync</code> gathers a list of <code>TargetHeads</code> from <code>BlockPubsub</code>, sorted by likelihood of being the best chain (see below).</li>
<li><code>ChainSync</code> makes requests for chains of <code>BlockHeaders</code> to close gaps between  <code>TargetHeads</code></li>
<li><code>ChainSync</code> forms partial unvalidated chains of <code>BlockHeaders</code>, from those received via <code>BlockPubsub</code>, and those requested via <code>Graphsync</code>.</li>
<li><code>ChainSync</code> attempts to form fully connected chains of <code>BlockHeaders</code>, parting from <code>StateTree</code>, toward observed <code>Heads</code></li>
<li><code>ChainSync</code> minimizes resource expenditures to fetch and validate blocks, to protect against DOS attack vectors.
<code>ChainSync</code> employs <strong>Progressive Block Validation</strong>, validating different facets at different stages of syncing.</li>
<li><code>ChainSync</code> delays syncing <code>Messages</code> until they are needed. Much of the structure of the partial chains can
be checked and used to make syncing decisions without fetching the <code>Messages</code>.</li>
</ul>
<h5 id="progressive-block-validation">Progressive Block Validation</h5>
<ul>
<li>
<p><a href="./#systems__filecoin_blockchain__struct__block___index">Blocks</a> may be validated in progressive stages, in order to minimize resource expenditure.</p>
</li>
<li>
<p>Validation computation is considerable, and a serious DOS attack vector.</p>
</li>
<li>
<p>Secure implementations must carefully schedule validation and minimize the work done by pruning blocks without validating them fully.</p>
</li>
<li>
<p><code>ChainSync</code> SHOULD keep a cache of unvalidated blocks (ideally sorted by likelihood of belonging to the chain), and delete unvalidated blocks when they are passed by <code>FinalityTipset</code>, or when <code>ChainSync</code> is under significant resource load.</p>
</li>
<li>
<p>These stages can be used partially across many blocks in a candidate chain, in order to prune out clearly bad blocks long before actually doing the expensive validation work.</p>
</li>
<li>
<p><strong>Progressive Stages of Block Validation</strong></p>
<ul>
<li><strong>BV0 - Syntax</strong>: Serialization, typing, value ranges.</li>
<li><strong>BV1 - Plausible Consensus</strong>: Plausible miner, weight, and epoch values (e.g from chain state at <code>b.ChainEpoch - consensus.LookbackParameter</code>).</li>
<li><strong>BV2 - Block Signature</strong></li>
<li><strong>BV3 - ElectionPoSt</strong>: Correct PoSt with a winning ticket.</li>
<li><strong>BV4 - Chain ancestry and finality</strong>: Verify block links back to trusted chain, not prior to finality.</li>
<li><strong>BV4 - Message Signatures</strong>:</li>
<li><strong>BV5 - State tree</strong>: Parent tipset message execution produces the claimed state tree root and receipts.</li>
</ul>
</li>
</ul>
<p>Notes:</p>
<ul>
<li>in <code>CHAIN_CATCHUP</code>, if a node is receiving/fetching hundreds/thousands of <code>BlockHeaders</code>, validating signatures can be very expensive, and can be deferred in favor of other validation. (ie lots of BlockHeaders coming in through network pipe, dont want to bound on sig verification, other checks can help dump blocks on the floor faster (BV0, BV2)</li>
<li>in <code>CHAIN_FOLLOW</code>, we&rsquo;re not receiving thousands, we&rsquo;re receiving maybe a dozen or 2 dozen packets in a few seconds. We receive cid w/ Sig and addr first (ideally fits in 1 packet), and can afford to (a) check if we already have the cid (if so done, cheap), or (b) if not, check if sig is correct before fetching header (expensive computation, but checking 1 sig is way faster than checking a ton). In practice likely that which one to do is dependent on miner tradeoffs. we&rsquo;ll recommend something but let miners decide, because one strat or the other may be much more effective depending on their hardware, on their bandwidth limitations, or their propensity to getting DOSed</li>
</ul>
<h5 id="progressive-block-propagation-or-blocksend">Progressive Block Propagation (or BlockSend)</h5>
<ul>
<li>In order to make Block propagation more efficient, we trade off network round trips for bandwidth usage.</li>
<li><strong>Motivating observations:</strong>
<ul>
<li>Block propagation is one of the most security critical points of the whole protocol.</li>
<li>Bandwidth usage during Block propagation is the biggest rate limiter for network scalability.</li>
<li>The time it takes for a Block to propagate to the whole network is a critical factor in determining a secure <code>BlockTime</code></li>
<li>Blocks propagating through the network should take as few <em>sequential</em> roundtrips as possible, as these roundtrips impose serious block time delays. However, interleaved roundtrips may be fine. Meaning that <code>block.CIDs</code> may be propagated on their own, without the header, then the header without the messages, then the messages.</li>
<li><code>Blocks</code> will propagate over a <code>libp2p.PubSub</code>. <code>libp2p.PubSub.Messages</code> will most likely arrive multiple times at a node. Therefore, using only the <code>block.CID</code> here could make this very cheap in bandwidth (more expensive in round trips)</li>
<li><code>Blocks</code> in a single epoch may include the same <code>Messages</code>, and duplicate transfers can be avoided</li>
<li><code>Messages</code> propagate through their own <code>MessagePubsub</code>, and nodes have a significant probability of already having a large fraction of the messages in a block. Since messages are the <em>bulk</em> of the size of a <code>Block</code>, this can present great bandwidth savings.</li>
</ul>
</li>
<li><strong>Progressive Steps of Block Propagation</strong>
<ul>
<li><strong>IMPORTANT NOTES</strong>:
<ul>
<li>these can be effectively pipelined. The <code>receiver</code> is in control of what to pull, and when. It is up them to decide when to trade-off RTTs for Bandwidth.</li>
<li>If the <code>sender</code> is propagating the block at all to <code>receiver</code>, it is in their interest to provide the full content to <code>receiver</code> when asked. Otherwise the block may not get included at all.</li>
<li>Lots of security assumptions here &ndash; this needs to be hyper verified, in both spec and code.</li>
<li><code>sender</code> is a filecoin node running <code>ChainSync</code>, propagating a block via Gossipsub
(as the originator, as another peer in the network, or just a Gossipsub router).</li>
<li><code>receiver</code> is the local filecoin node running <code>ChainSync</code>, trying to get the blocks.</li>
<li>for <code>receiver</code> to <code>Pull</code> things from <code>sender</code>, <code>receiver</code>must conntect to <code>sender</code>. Usually <code>sender</code> is sending to <code>receiver</code> because of the Gossipsub propagation rules. <code>receiver</code> could choose to <code>Pull</code> from any other node they are connected to, but it is most likely <code>sender</code> will have the needed information. They usually may be more well-connected in the network.</li>
</ul>
</li>
<li><strong>Step 1. (sender) <code>Push BlockHeader</code></strong>:
<ul>
<li><code>sender</code> sends <code>block.BlockHeader</code> to <code>receiver</code> via Gossipsub:
<ul>
<li><code>bh := Gossipsub.Send(h block.BlockHeader)</code></li>
<li>This is a light-ish object (&lt;4KB).</li>
</ul>
</li>
<li><code>receiver</code> receives <code>bh</code>.
<ul>
<li>This has many fields that can be validated before pulling the messages. (See <strong>Progressive Block Validation</strong>).</li>
<li><strong>BV0</strong>, <strong>BV1</strong>, <strong>BV2</strong>, and <strong>BV3</strong> validation takes place before propagating <code>bh</code> to other nodes.</li>
<li><code>receiver</code> MAY receive many advertisements for each winning block in an epoch in quick succession. this is because (a) many want propagation as fast as possible, (b) many want to make those network advertisements as light as reasonable, (c) we want to enable <code>receiver</code> to choose who to ask it from (usually the first party to advertise it, and that&rsquo;s what spec will recommend), and (d) want to be able to fall back to asking others if that fails (fail = dont get it in 1s or so)</li>
</ul>
</li>
</ul>
</li>
<li><strong>Step 2. (receiver) <code>Pull MessageCids</code></strong>:
<ul>
<li>upon receiving <code>bh</code>, <code>receiver</code> checks whether it already has the full block for <code>bh.BlockCID</code>. if not:
<ul>
<li><code>receiver</code> requests <code>bh.MessageCids</code> from <code>sender</code>:
<ul>
<li><code>bm := Graphsync.Pull(sender, SelectAMTCIDs(b.Messages))</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Step 3. (receiver) <code>Pull Messages</code></strong>:
<ul>
<li>if <code>receiver</code> <strong>DOES NOT</strong> already have the all messages for <code>b.BlockCID</code>, then:
<ul>
<li>if <code>receiver</code> has <em>some</em> of the messages:
<ul>
<li><code>receiver</code> requests missing <code>Messages</code> from <code>sender</code>:
<ul>
<li><code>Graphsync.Pull(sender, SelectAll(bm[3], bm[10], bm[50], ...))</code> or</li>
<li>
<pre><code>for m in bm {
  Graphsync.Pull(sender, SelectAll(m))
}
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li>if <code>receiver</code> does not have any of the messages (default safe but expensive thing to do):
<ul>
<li><code>receiver</code> requests all <code>Messages</code> from <code>sender</code>:
<ul>
<li><code>Graphsync.Pull(sender, SelectAll(bh.Messages))</code></li>
</ul>
</li>
</ul>
</li>
<li>(This is the largest amount of stuff)</li>
</ul>
</li>
</ul>
</li>
<li><strong>Step 4. (receiver) <code>Validate Block</code></strong>:
<ul>
<li>the only remaining thing to do is to complete Block Validation.</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="calculations">Calculations</h4>
<h5 id="security-parameters">Security Parameters</h5>
<ul>
<li><code>Peers</code> &gt;= 32 &ndash; direct connections
<ul>
<li>ideally <code>Peers</code> &gt;= {64, 128}</li>
</ul>
</li>
<li></li>
</ul>
<h5 id="pubsub-bandwidth">Pubsub Bandwidth</h5>
<p>These bandwidth calculations are used to motivate choices in <code>ChainSync</code>.</p>
<p>If you imagine that you will receive the header once per gossipsub peer (or if lucky, half of them), and that there is EC.E_LEADERS=10 blocks per round, then we&rsquo;re talking the difference between:</p>
<pre><code>16 peers, 1 pkt  -- 1 * 16 * 10 = 160 dup pkts (256KB) in &lt;5s
16 peers, 4 pkts -- 4 * 16 * 10 = 640 dup pkts (1MB)   in &lt;5s

32 peers, 1 pkt  -- 1 * 32 * 10 =   320 dup pkts (512KB) in &lt;5s
32 peers, 4 pkts -- 4 * 32 * 10 = 1,280 dup pkts (2MB)   in &lt;5s

64 peers, 1 pkt  -- 1 * 32 * 10 =   320 dup pkts (1MB) in &lt;5s
64 peers, 4 pkts -- 4 * 32 * 10 = 1,280 dup pkts (4MB)   in &lt;5s
</code></pre><p>2MB in &lt;5s may not be worth saving&ndash; and maybe gossipsub can be much better about supressing dups.</p>
<h4 id="notes-todo-move-elsewhere">Notes (TODO: move elsewhere)</h4>
<h5 id="checkpoints">Checkpoints</h5>
<ul>
<li>A checkpoint is the CID of a block (not a tipset list of CIDs, or StateTree)</li>
<li>The reason a block is OK is that it uniquely identifies a tipset.</li>
<li>using tipsets directly would make Checkpoints harder to communicate. we want to make checkpoints a single hash, as short as we can have it. They will be shared in tweets, URLs, emails, printed into newspapers, etc. Compactness, ease of copy-paste, etc matters.</li>
<li>we&rsquo;ll make human readable lists of checkpoints, and making &ldquo;lists of lists&rdquo; is more annoying.</li>
<li>When we have <code>EC.E_PARENTS &gt; 5</code> or <code>= 10</code>, tipsets will get annoyingly large.</li>
<li>the big quirk/weirdness with blocks it that it also must be in the chain. (if you relaxed that constraint you could end up in a weird case where a checkpoint isnt in the chain and that&rsquo;s weird/violates assumptions).</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/138401/67015561-8c929000-f0ab-11e9-847a-ec42f23b14da.png" alt=""></p>
<h5 id="bootstrap-chain-stub">Bootstrap chain stub</h5>
<ul>
<li>the mainnet filecoin chain will need to start with a small chain stub of blocks.</li>
<li>we must include some data in different blocks.</li>
<li>we do need a genesis block &ndash; we derive randomness from the ticket there. Rather than special casing, it is easier/less complex to ensure a well-formed chain always, including at the beginning</li>
<li>A lot of code expects lookbacks, especially actor code. Rather than introducing a bunch of special case logic for what happens ostensibly once in network history (special case logic which adds complexity and likelihood of problems), it is easiest to assume the chain is always at least X blocks long, and the system lookback parameters are all fine and dont need to be scaled in the beginning of network&rsquo;s history.</li>
</ul>
<h5 id="partialgraph">PartialGraph</h5>
<p>The <code>PartialGraph</code> of blocks.</p>
<blockquote>
<p>Is a graph necessarily connected, or is this just a bag of blocks, with each disconnected subgraph being reported in heads/tails?</p>
</blockquote>
<p>The latter.  the partial graph is a DAG fragment&ndash; including disconnected components.
here&rsquo;s a visual example, 4 example PartialGraphs, with Heads and Tails. (note they aren&rsquo;t tipsets)</p>
<p><img src="https://user-images.githubusercontent.com/138401/67014349-90bdae00-f0a9-11e9-9f29-bdca6c673c4b.png" alt=""></p>


</div>



</div>

  

  
    








<div id="systems__filecoin_blockchain__storage_power_consensus">

<h3 class="section-header">
  Storage Power Consensus
</h3>

<div class="section-content">




































<p><div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_consensus"></div>
The Storage Power Consensus subsystem is the main interface which enables Filecoin nodes to agree on the state of the system. SPC accounts for individual storage miners&rsquo; effective power over consensus in given chains in its <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table">Power Table</a>. It also runs <a href="./#algorithms__expected_consensus___index">Expected Consensus</a> (the underlying consensus algorithm in use by Filecoin), enabling storage miners to run leader election and generate new blocks updating the state of the Filecoin system.</p>
<p>Succinctly, the SPC subsystem offers the following services:</p>
<ul>
<li>
<p>Access to the <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table">Power Table</a> for every subchain, accounting for individual storage miner power and total power on-chain.</p>
</li>
<li>
<p>Access to <a href="./#algorithms__expected_consensus___index">Expected Consensus</a> for individual storage miners, enabling:</p>
<ul>
<li>Access to verifiable randomness <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Tickets</a> as needed in the rest of the protocol.</li>
<li>Running  <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> to produce new blocks.</li>
<li>Running <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a> across subchains using EC&rsquo;s weighting function.</li>
<li>Identification of <a href="./#algorithms__expected_consensus__finality">the most recently finalized tipset</a>, for use by all protocol participants.</li>
</ul>
</li>
</ul>
<p>Much of the Storage Power Consensus&rsquo; subsystem functionality is detailed in the code below but we touch upon some of its behaviors in more detail.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">chain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/chain&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">blockchain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain&#34;</span>
<span class="kn">import</span> <span class="nx">spowact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_power&#34;</span>
<span class="kn">import</span> <span class="nx">node_base</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/node_base&#34;</span>

<span class="kd">type</span> <span class="nx">StoragePowerConsensusSubsystem</span> <span class="kd">struct</span> <span class="p">{</span><span class="c1">//(@mutable)
</span><span class="c1"></span>    <span class="nf">ChooseTipsetToMine</span><span class="p">(</span><span class="nx">tipsets</span> <span class="p">[</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">])</span> <span class="p">[</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">]</span>

    <span class="nx">node</span>        <span class="nx">node_base</span><span class="p">.</span><span class="nx">FilecoinNode</span>
    <span class="nx">ec</span>          <span class="nx">ExpectedConsensus</span>
    <span class="nx">blockchain</span>  <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainSubsystem</span>

    <span class="c1">// call by BlockchainSubsystem during block reception
</span><span class="c1"></span>    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span> <span class="kt">error</span>

    <span class="nf">IsWinningPartialTicket</span><span class="p">(</span>
        <span class="nx">st</span>                 <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
        <span class="nx">partialTicket</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">PartialTicket</span>
        <span class="nx">sectorUtilization</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span>
        <span class="nx">numSectors</span>         <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">_getStoragePowerActorState</span><span class="p">(</span><span class="nx">stateTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="nx">spowact</span><span class="p">.</span><span class="nx">StoragePowerActorState</span>

    <span class="nf">validateTicket</span><span class="p">(</span>
        <span class="nx">tix</span>             <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span>
        <span class="nx">pk</span>              <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFPublicKey</span>
        <span class="nx">minerActorAddr</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">computeChainWeight</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span>

    <span class="nf">StoragePowerConsensusError</span><span class="p">()</span> <span class="nx">StoragePowerConsensusError</span>

    <span class="nf">GetFinalizedEpoch</span><span class="p">(</span><span class="nx">currentEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StoragePowerConsensusError</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>





<h5 id="distinguishing-between-storage-miners-and-block-miners">Distinguishing between storage miners and block miners</h5>
<p>There are two ways to earn Filecoin tokens in the Filecoin network:</p>
<ul>
<li>By participating in the <a href="./#systems__filecoin_markets__storage_market___index">Storage Market</a> as a storage provider and being paid by clients for file storage deals.</li>
<li>By mining new blocks on the network, helping modify system state and secure the Filecoin consensus mechanism.</li>
</ul>
<p>We must distinguish between both types of &ldquo;miners&rdquo; (storage and block miners). <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> in Filecoin is predicated on a miner&rsquo;s storage power. Thus, while all block miners will be storage miners, the reverse is not necessarily true.</p>
<p>However, given Filecoin&rsquo;s &ldquo;useful Proof-of-Work&rdquo; is achieved through file storage (PoRep and PoSt), there is little overhead cost for storage miners to participate in leader election. Such a <a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor">Storage Miner Actor</a> need only register with the <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor">Storage Power Actor</a> in order to participate in Expected Consensus and mine blocks.</p>
<div id="systems__filecoin_blockchain__storage_power_consensus__storage_power"></div>
<h5 id="on-power">On Power</h5>
<p>Claimed power is assigned to every sector as a static function of its <code>SectorStorageWeightDesc</code> which includes <code>SectorSize</code>, <code>Duration</code>, and <code>DealWeight</code>. DealWeight is a measure that maps size and duration of active deals in a sector during its lifetime to its impact on power and reward distribution. A CommittedCapacity Sector (see <a href="./#systems__filecoin_mining__storage_mining">Sector Types</a>) will have a DealWeight of zero but all sectors have an explicit Duration which is defined from the ChainEpoch that the sector comes online in a ProveCommit message to the Expiration ChainEpoch of the sector. In principle, power is the number of votes a miner has in leader election and it is a point in time concept of storage. However, the exact function that maps <code>SectorStorageWeightDesc</code> to claimed <code>StoragePower</code> and <code>BlockReward</code> will be announced soon.</p>
<p>More precisely,</p>
<ul>
<li>Claimed power = power from ProveCommit sectors minus sectors in TemporaryFault effective duration.</li>
<li>Nominal power = claimed power, unless the miner is in DetectedFault or Challenged state. Nominal power is used to determine total network storage power for purposes of consensus minimum.</li>
<li>Consensus power = nominal power, unless the miner fails to meet consensus minimum, or is undercollateralized.</li>
</ul>
<div id="systems__filecoin_blockchain__storage_power_consensus__tickets"></div>
<h5 id="tickets">Tickets</h5>
<p>Tickets are used across the Filecoin protocol as sources of randomness:</p>
<ul>
<li>The <a href="./#systems__filecoin_mining__storage_proving__sector_sealer">Sector Sealer</a> uses tickets as SealSeeds to bind sector commitments to a given subchain.</li>
<li>The <a href="./#systems__filecoin_mining__storage_mining">Storage Miner</a> likewise uses tickets as PoStChallenges to prove sectors remain committed as of a given block.</li>
<li>They are drawn by the Storage Power subsystem as randomness in <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> to determine their eligibility to mine a block</li>
<li>They are drawn by the Storage Power subsystem in order to generate new tickets for future use.</li>
</ul>
<p>Each of these ticket uses may require drawing tickets at different chain epochs, according to the security requirements of the particular protocol making use of tickets. Specifically, the ticket output (which is a SHA256 output) is used for randomness.</p>
<p>In Filecoin, every block header contains a single ticket.</p>
<p>You can find the Ticket data structure <a href="./#listings__data_structures">here</a>.</p>
<h6 id="comparing-tickets-in-a-tipset">Comparing Tickets in a Tipset</h6>
<p>Whenever comparing tickets is evoked in Filecoin, for instance when discussing selecting the &ldquo;min ticket&rdquo; in a Tipset, the comparison is that of the little endian representation of the ticket&rsquo;s VFOutput bytes.</p>
<div id="systems__filecoin_blockchain__storage_power_consensus__ticket_chain"></div>
<h5 id="the-ticket-chain-and-drawing-randomness">The Ticket chain and drawing randomness</h5>
<p>While each Filecoin block header contains a ticket field (see <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Tickets</a>), it is useful to think of a ticket chain abstraction.
Due to the nature of Filecoin&rsquo;s Tipsets and the possibility of using tickets from epochs that did not yield leaders to produce randomness at a given epoch, tracking the canonical ticket of a subchain at a given height can be arduous to reason about in terms of blocks. To that end, it is helpful to create a ticket chain abstraction made up of only those tickets to be used for randomness generation at a given height.</p>
<p>To read more about specifically how tickets are processed for randomness, see <a href="./#algorithms__crypto__randomness">Randomness</a>.</p>
<p>To sample a ticket for a given epoch n:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">Set referenceTipsetOffset = 0
While true:
    Set referenceTipsetHeight = n - referenceTipsetOffset
    If blocks were mined at referenceTipsetHeight:
        ReferenceTipset = TipsetAtHeight(referenceTipsetHeight)
        Select the block in ReferenceTipset with the smallest final ticket, return its value (pastTicket).
    If no blocks were mined at referenceTipsetHeight:
        Increment referenceTipsetOffset
        (Repeat)
newRandomness = H(TicketDrawDST || index || Serialization(epoch || pastTicketOutput))
</code></pre></div><p>In plain language, this means two things:</p>
<ul>
<li>Choose the smallest ticket in the Tipset if it contains multiple blocks.</li>
<li>When sampling a ticket from an epoch with no blocks, draw the min ticket from the prior epoch with blocks and concatenate it with
<ul>
<li>the wanted epoch number</li>
<li>hash this concatenation for a usable ticket value</li>
</ul>
</li>
</ul>
<p>See the <code>RandomnessAtEpoch</code> method below:



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">chain</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">node_base</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/node_base&#34;</span>
<span class="p">)</span>

<span class="c1">// Returns the tipset at or immediately prior to `epoch`.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Tipset</span> <span class="p">{</span>
	<span class="nx">current</span> <span class="o">:=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">HeadTipset</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">current</span><span class="p">.</span><span class="nf">Epoch</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">epoch</span> <span class="p">{</span>
		<span class="nx">current</span> <span class="p">=</span> <span class="nx">current</span><span class="p">.</span><span class="nf">Parents</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">current</span>
<span class="p">}</span>

<span class="c1">// Draws randomness from the tipset at or immediately prior to `epoch`.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="nx">ts</span> <span class="o">:=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ts</span><span class="p">.</span><span class="nf">MinTicket</span><span class="p">().</span><span class="nf">DrawRandomness</span><span class="p">(</span><span class="nx">epoch</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">GetTicketProductionRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="o">-</span> <span class="nx">node_base</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_TICKET</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">GetSealRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="o">-</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_SEAL</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">GetPoStChallengeRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="o">-</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_POST</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>




</p>
<p>The above means that ticket randomness is reseeded with every new block, but can indeed be derived by any miner for an arbitrary epoch number using a past epoch.</p>
<div id="systems__filecoin_blockchain__storage_power_consensus__ticket_generation"></div>
<h6 id="randomness-ticket-generation">Randomness Ticket generation</h6>
<p>This section discusses how tickets are generated by EC for the <code>Ticket</code> field in every block header.</p>
<p>At round <code>N</code>, a new ticket is generated using tickets drawn from the Tipset at round <code>N-1</code> (as shown below).</p>
<p>The miner runs the prior ticket through a Verifiable Random Function (VRF) to get a new unique ticket which can later be derived for randomness (as shown above). The prior ticket is prepended with the ticket domain separation tag and concatenated with the miner actor address (to ensure miners using the same worker keys get different randomness).</p>
<p>To generate a ticket for a given epoch n:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">LastTicket = MinTicketValueAtEpoch(n-1)
newRandomness = VRF_miner(H(TicketProdDST || index || Serialization(pastTicket, minerActorAddress)))
</code></pre></div><p>The VRF&rsquo;s deterministic output adds entropy to the ticket chain, limiting a miner&rsquo;s ability to alter one block to influence a future ticket (given a miner does not know who will win a given round in advance).</p>
<p>We use the VRF from <a href="./#algorithms__crypto__vrf">Verifiable Random Function</a> for ticket generation in EC (see the <code>PrepareNewTicket</code> method below).</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_mining</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">smarkact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_market&#34;</span>
	<span class="nx">sminact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_miner&#34;</span>
	<span class="nx">spowact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_power&#34;</span>
	<span class="nx">acrypto</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/crypto&#34;</span>
	<span class="nx">indices</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&#34;</span>
	<span class="nx">serde</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/serde&#34;</span>
	<span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
	<span class="nx">filproofs</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/filcrypto/filproofs&#34;</span>
	<span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
	<span class="nx">msg</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
	<span class="nx">stateTree</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
	<span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Serialization</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Serialization</span>

<span class="kd">var</span> <span class="nx">Assert</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Assert</span>
<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">TODO</span>

<span class="c1">// Note that implementations may choose to provide default generation methods for miners created
</span><span class="c1">// without miner/owner keypairs. We omit these details from the spec.
</span><span class="c1">// Also note that the pledge amount should be available in the ownerAddr in order for this call
</span><span class="c1">// to succeed.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">CreateMiner</span><span class="p">(</span>
	<span class="nx">state</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span>
	<span class="nx">ownerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">workerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span>
	<span class="nx">sectorSize</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UInt</span><span class="p">,</span>
	<span class="nx">peerId</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span>
	<span class="nx">pledgeAmt</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span>
<span class="p">)</span> <span class="p">(</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">ownerActor</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">ownerAddr</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>

	<span class="nx">unsignedCreationMessage</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage_I</span><span class="p">{</span>
		<span class="nx">From_</span><span class="p">:</span>       <span class="nx">ownerAddr</span><span class="p">,</span>
		<span class="nx">To_</span><span class="p">:</span>         <span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
		<span class="nx">Method_</span><span class="p">:</span>     <span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_CreateMiner</span><span class="p">,</span>
		<span class="nx">Params_</span><span class="p">:</span>     <span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span><span class="nx">ownerAddr</span><span class="p">,</span> <span class="nx">workerAddr</span><span class="p">,</span> <span class="nx">peerId</span><span class="p">),</span>
		<span class="nx">CallSeqNum_</span><span class="p">:</span> <span class="nx">ownerActor</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">(),</span>
		<span class="nx">Value_</span><span class="p">:</span>      <span class="nx">pledgeAmt</span><span class="p">,</span>
		<span class="nx">GasPrice_</span><span class="p">:</span>   <span class="mi">0</span><span class="p">,</span>
		<span class="nx">GasLimit_</span><span class="p">:</span>   <span class="nx">msg</span><span class="p">.</span><span class="nf">GasAmount_SentinelUnlimited</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">workerKey</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">SigKeyPair</span> <span class="c1">// sms._keyStore().Worker()
</span><span class="c1"></span>	<span class="nx">signedMessage</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">Sign</span><span class="p">(</span><span class="nx">unsignedCreationMessage</span><span class="p">,</span> <span class="nx">workerKey</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Undef</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">MessagePool</span><span class="p">().</span><span class="nf">Syncer</span><span class="p">().</span><span class="nf">SubmitMessage</span><span class="p">(</span><span class="nx">signedMessage</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Undef</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="c1">// WAIT for block reception with appropriate response from SPA
</span><span class="c1"></span>	<span class="nx">util</span><span class="p">.</span><span class="nf">IMPL_TODO</span><span class="p">()</span>

	<span class="c1">// harvest address from that block
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">storageMinerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="c1">// and set in key store appropriately
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">storageMinerAddr</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">HandleStorageDeal</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sms</span><span class="p">.</span><span class="nf">SectorIndex</span><span class="p">().</span><span class="nf">AddNewDeal</span><span class="p">(</span><span class="nx">deal</span><span class="p">)</span>
	<span class="c1">// stagedDealResponse := sms.SectorIndex().AddNewDeal(deal)
</span><span class="c1"></span>	<span class="c1">// TODO: way within a node to notify different components
</span><span class="c1"></span>	<span class="c1">// market.StorageProvider().NotifyStorageDealStaged(&amp;storage_provider.StorageDealStagedNotification_I{
</span><span class="c1"></span>	<span class="c1">// 	Deal_:     deal,
</span><span class="c1"></span>	<span class="c1">// 	SectorID_: stagedDealResponse.SectorID(),
</span><span class="c1"></span>	<span class="c1">// })
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">CommitSectorError</span><span class="p">()</span> <span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDeal</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// triggered by new block reception and tipset assembly
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">OnNewBestChain</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sms</span><span class="p">.</span><span class="nf">_runMiningCycle</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// triggered by wall clock
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">OnNewRound</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sms</span><span class="p">.</span><span class="nf">_runMiningCycle</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">_runMiningCycle</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">chainHead</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_blockchain</span><span class="p">().</span><span class="nf">BestChain</span><span class="p">().</span><span class="nf">HeadTipset</span><span class="p">()</span>
	<span class="nx">sma</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_getStorageMinerActorState</span><span class="p">(</span><span class="nx">chainHead</span><span class="p">.</span><span class="nf">StateTree</span><span class="p">(),</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">KeyStore</span><span class="p">().</span><span class="nf">MinerAddress</span><span class="p">())</span>

	<span class="k">if</span> <span class="nx">sma</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nf">Is_OK</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">ePoSt</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_tryLeaderElection</span><span class="p">(</span><span class="nx">chainHead</span><span class="p">.</span><span class="nf">StateTree</span><span class="p">(),</span> <span class="nx">sma</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">ePoSt</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="c1">// Randomness for ticket generation in block production
</span><span class="c1"></span>			<span class="nx">randomness1</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_blockchain</span><span class="p">().</span><span class="nf">BestChain</span><span class="p">().</span><span class="nf">GetTicketProductionRandSeed</span><span class="p">(</span><span class="nx">sms</span><span class="p">.</span><span class="nf">_blockchain</span><span class="p">().</span><span class="nf">LatestEpoch</span><span class="p">())</span>
			<span class="nx">newTicket</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">PrepareNewTicket</span><span class="p">(</span><span class="nx">randomness1</span><span class="p">,</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">KeyStore</span><span class="p">().</span><span class="nf">MinerAddress</span><span class="p">())</span>

			<span class="nx">sms</span><span class="p">.</span><span class="nf">_blockProducer</span><span class="p">().</span><span class="nf">GenerateBlock</span><span class="p">(</span><span class="o">*</span><span class="nx">ePoSt</span><span class="p">,</span> <span class="nx">newTicket</span><span class="p">,</span> <span class="nx">chainHead</span><span class="p">,</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">KeyStore</span><span class="p">().</span><span class="nf">MinerAddress</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">sma</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nf">Is_Challenged</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">sPoSt</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_trySurprisePoSt</span><span class="p">(</span><span class="nx">chainHead</span><span class="p">.</span><span class="nf">StateTree</span><span class="p">(),</span> <span class="nx">sma</span><span class="p">)</span>

		<span class="kd">var</span> <span class="nx">gasLimit</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span>
		<span class="kd">var</span> <span class="nx">gasPrice</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
		<span class="nx">util</span><span class="p">.</span><span class="nf">IMPL_FINISH</span><span class="p">(</span><span class="s">&#34;read from consts (in this case user set param)&#34;</span><span class="p">)</span>
		<span class="nx">sms</span><span class="p">.</span><span class="nf">_submitSurprisePoStMessage</span><span class="p">(</span><span class="nx">chainHead</span><span class="p">.</span><span class="nf">StateTree</span><span class="p">(),</span> <span class="o">*</span><span class="nx">sPoSt</span><span class="p">,</span> <span class="nx">gasPrice</span><span class="p">,</span> <span class="nx">gasLimit</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">_tryLeaderElection</span><span class="p">(</span><span class="nx">currState</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">sma</span> <span class="nx">sminact</span><span class="p">.</span><span class="nx">StorageMinerActorState</span><span class="p">)</span> <span class="o">*</span><span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainElectionPoStVerifyInfo</span> <span class="p">{</span>
	<span class="c1">// Randomness for ElectionPoSt
</span><span class="c1"></span>
	<span class="nx">randomnessK</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_blockchain</span><span class="p">().</span><span class="nf">BestChain</span><span class="p">().</span><span class="nf">GetPoStChallengeRandSeed</span><span class="p">(</span><span class="nx">sms</span><span class="p">.</span><span class="nf">_blockchain</span><span class="p">().</span><span class="nf">LatestEpoch</span><span class="p">())</span>
	<span class="nx">input</span> <span class="o">:=</span> <span class="nx">acrypto</span><span class="p">.</span><span class="nf">DeriveRandWithMinerAddr</span><span class="p">(</span><span class="nx">acrypto</span><span class="p">.</span><span class="nx">DomainSeparationTag_ElectionPoStChallengeSeed</span><span class="p">,</span> <span class="nx">randomnessK</span><span class="p">,</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">KeyStore</span><span class="p">().</span><span class="nf">MinerAddress</span><span class="p">())</span>
	<span class="c1">// Use VRF to generate secret randomness
</span><span class="c1"></span>	<span class="nx">postRandomness</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">KeyStore</span><span class="p">().</span><span class="nf">WorkerKey</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">Generate</span><span class="p">(</span><span class="nx">input</span><span class="p">).</span><span class="nf">Output</span><span class="p">()</span>

	<span class="c1">// TODO: add how sectors are actually stored in the SMS proving set
</span><span class="c1"></span>	<span class="nx">util</span><span class="p">.</span><span class="nf">TODO</span><span class="p">()</span>
	<span class="nx">provingSet</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="nx">candidates</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">StorageProving</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">GenerateElectionPoStCandidates</span><span class="p">(</span><span class="nx">postRandomness</span><span class="p">,</span> <span class="nx">provingSet</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span> <span class="c1">// fail to generate post candidates
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">winningCandidates</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">numMinerSectors</span> <span class="kt">uint64</span>
	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// update
</span><span class="c1"></span>	<span class="c1">// numMinerSectors := uint64(len(sma.SectorTable().Impl().ActiveSectors_.SectorsOn()))
</span><span class="c1"></span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">candidate</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">candidates</span> <span class="p">{</span>
		<span class="nx">sectorNum</span> <span class="o">:=</span> <span class="nx">candidate</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">.</span><span class="nx">Number</span>
		<span class="nx">sectorWeightDesc</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">sma</span><span class="p">.</span><span class="nf">GetStorageWeightDescForSectorMaybe</span><span class="p">(</span><span class="nx">sectorNum</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">nil</span>
		<span class="p">}</span>
		<span class="nx">sectorPower</span> <span class="o">:=</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">ConsensusPowerForStorageWeight</span><span class="p">(</span><span class="nx">sectorWeightDesc</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_consensus</span><span class="p">().</span><span class="nf">IsWinningPartialTicket</span><span class="p">(</span><span class="nx">currState</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">.</span><span class="nx">PartialTicket</span><span class="p">,</span> <span class="nx">sectorPower</span><span class="p">,</span> <span class="nx">numMinerSectors</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">winningCandidates</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">winningCandidates</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">winningCandidates</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="nx">postProofs</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">StorageProving</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">CreateElectionPoStProof</span><span class="p">(</span><span class="nx">postRandomness</span><span class="p">,</span> <span class="nx">winningCandidates</span><span class="p">)</span>

	<span class="nx">electionPoSt</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainElectionPoStVerifyInfo</span><span class="p">{</span>
		<span class="nx">Candidates</span><span class="p">:</span> <span class="nx">winningCandidates</span><span class="p">,</span>
		<span class="nx">Randomness</span><span class="p">:</span> <span class="nx">postRandomness</span><span class="p">,</span>
		<span class="nx">Proofs</span><span class="p">:</span>     <span class="nx">postProofs</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">electionPoSt</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">PrepareNewTicket</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span><span class="p">,</span> <span class="nx">minerActorAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span> <span class="p">{</span>
	<span class="c1">// run it through the VRF and get deterministic output
</span><span class="c1"></span>
	<span class="c1">// take the VRFResult of that ticket as input, specifying the personalization (see data structures)
</span><span class="c1"></span>	<span class="c1">// append the miner actor address for the miner generifying this in order to prevent miners with the same
</span><span class="c1"></span>	<span class="c1">// worker keys from generating the same randomness (given the VRF)
</span><span class="c1"></span>	<span class="nx">input</span> <span class="o">:=</span> <span class="nx">acrypto</span><span class="p">.</span><span class="nf">DeriveRandWithMinerAddr</span><span class="p">(</span><span class="nx">acrypto</span><span class="p">.</span><span class="nx">DomainSeparationTag_TicketProduction</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">,</span> <span class="nx">minerActorAddr</span><span class="p">)</span>

	<span class="c1">// run through VRF
</span><span class="c1"></span>	<span class="nx">vrfRes</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">KeyStore</span><span class="p">().</span><span class="nf">WorkerKey</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">Generate</span><span class="p">(</span><span class="nx">input</span><span class="p">)</span>

	<span class="nx">newTicket</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">block</span><span class="p">.</span><span class="nx">Ticket_I</span><span class="p">{</span>
		<span class="nx">VRFResult_</span><span class="p">:</span> <span class="nx">vrfRes</span><span class="p">,</span>
		<span class="nx">Output_</span><span class="p">:</span>    <span class="nx">vrfRes</span><span class="p">.</span><span class="nf">Output</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">newTicket</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">_getStorageMinerActorState</span><span class="p">(</span><span class="nx">stateTree</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">sminact</span><span class="p">.</span><span class="nx">StorageMinerActorState</span> <span class="p">{</span>
	<span class="nx">actorState</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">substateCID</span> <span class="o">:=</span> <span class="nx">actorState</span><span class="p">.</span><span class="nf">State</span><span class="p">()</span>

	<span class="nx">substate</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">StateStore</span><span class="p">().</span><span class="nf">Get</span><span class="p">(</span><span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">substateCID</span><span class="p">))</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Couldn&#39;t find sma state&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// fix conversion to bytes
</span><span class="c1"></span>	<span class="nx">util</span><span class="p">.</span><span class="nf">IMPL_TODO</span><span class="p">(</span><span class="nx">substate</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">serializedSubstate</span> <span class="nx">Serialization</span>
	<span class="kd">var</span> <span class="nx">st</span> <span class="nx">sminact</span><span class="p">.</span><span class="nx">StorageMinerActorState</span>
	<span class="nx">serde</span><span class="p">.</span><span class="nf">MustDeserialize</span><span class="p">(</span><span class="nx">serializedSubstate</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">st</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">_getStoragePowerActorState</span><span class="p">(</span><span class="nx">stateTree</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="nx">spowact</span><span class="p">.</span><span class="nx">StoragePowerActorState</span> <span class="p">{</span>
	<span class="nx">powerAddr</span> <span class="o">:=</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span>
	<span class="nx">actorState</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">powerAddr</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">substateCID</span> <span class="o">:=</span> <span class="nx">actorState</span><span class="p">.</span><span class="nf">State</span><span class="p">()</span>

	<span class="nx">substate</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">StateStore</span><span class="p">().</span><span class="nf">Get</span><span class="p">(</span><span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">substateCID</span><span class="p">))</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Couldn&#39;t find spa state&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// fix conversion to bytes
</span><span class="c1"></span>	<span class="nx">util</span><span class="p">.</span><span class="nf">IMPL_TODO</span><span class="p">(</span><span class="nx">substate</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">serializedSubstate</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Serialization</span>
	<span class="kd">var</span> <span class="nx">st</span> <span class="nx">spowact</span><span class="p">.</span><span class="nx">StoragePowerActorState</span>
	<span class="nx">serde</span><span class="p">.</span><span class="nf">MustDeserialize</span><span class="p">(</span><span class="nx">serializedSubstate</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">st</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">VerifyElectionPoSt</span><span class="p">(</span><span class="nx">inds</span> <span class="nx">indices</span><span class="p">.</span><span class="nx">Indices</span><span class="p">,</span> <span class="nx">header</span> <span class="nx">block</span><span class="p">.</span><span class="nx">BlockHeader</span><span class="p">,</span> <span class="nx">onChainInfo</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainElectionPoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">sma</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_getStorageMinerActorState</span><span class="p">(</span><span class="nx">header</span><span class="p">.</span><span class="nf">ParentState</span><span class="p">(),</span> <span class="nx">header</span><span class="p">.</span><span class="nf">Miner</span><span class="p">())</span>
	<span class="nx">spa</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_getStoragePowerActorState</span><span class="p">(</span><span class="nx">header</span><span class="p">.</span><span class="nf">ParentState</span><span class="p">())</span>

	<span class="nx">pow</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">spa</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">[</span><span class="nx">header</span><span class="p">.</span><span class="nf">Miner</span><span class="p">()]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 1. Verify miner has enough power (includes implicit checks on min miner size
</span><span class="c1"></span>	<span class="c1">// and challenge status via SPA&#39;s power table).
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pow</span> <span class="o">==</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// 2. verify no duplicate tickets included
</span><span class="c1"></span>	<span class="nx">challengeIndices</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int64</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tix</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">Candidates</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">challengeIndices</span><span class="p">[</span><span class="nx">tix</span><span class="p">.</span><span class="nx">ChallengeIndex</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="nx">challengeIndices</span><span class="p">[</span><span class="nx">tix</span><span class="p">.</span><span class="nx">ChallengeIndex</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// 3. Verify partialTicket values are appropriate
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">sms</span><span class="p">.</span><span class="nf">_verifyElection</span><span class="p">(</span><span class="nx">header</span><span class="p">,</span> <span class="nx">onChainInfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// verify the partialTickets themselves
</span><span class="c1"></span>	<span class="c1">// 4. Verify appropriate randomness
</span><span class="c1"></span>	<span class="c1">// TODO: fix away from BestChain()... every block should track its own chain up to its own production.
</span><span class="c1"></span>	<span class="nx">randomness</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_blockchain</span><span class="p">().</span><span class="nf">BestChain</span><span class="p">().</span><span class="nf">GetPoStChallengeRandSeed</span><span class="p">(</span><span class="nx">header</span><span class="p">.</span><span class="nf">Epoch</span><span class="p">())</span>
	<span class="nx">input</span> <span class="o">:=</span> <span class="nx">acrypto</span><span class="p">.</span><span class="nf">DeriveRandWithMinerAddr</span><span class="p">(</span><span class="nx">acrypto</span><span class="p">.</span><span class="nx">DomainSeparationTag_ElectionPoStChallengeSeed</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">,</span> <span class="nx">header</span><span class="p">.</span><span class="nf">Miner</span><span class="p">())</span>

	<span class="nx">postRand</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFResult_I</span><span class="p">{</span>
		<span class="nx">Output_</span><span class="p">:</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">Randomness</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="c1">// TODO if the workerAddress is secp then payload will be the blake2b hash of its public key
</span><span class="c1"></span>	<span class="c1">// and we will need to recover the entire public key from worker before handing off to Verify
</span><span class="c1"></span>	<span class="c1">// example of recover code: https://github.com/ipsn/go-secp256k1/blob/master/secp256.go#L93
</span><span class="c1"></span>	<span class="nx">workerKey</span> <span class="o">:=</span> <span class="nx">sma</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Worker</span><span class="p">.</span><span class="nf">Payload</span><span class="p">()</span>
	<span class="c1">// Verify VRF output from appropriate input corresponds to randomness used
</span><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">postRand</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nf">VRFPublicKey</span><span class="p">(</span><span class="nx">workerKey</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// A proof must be a valid snark proof with the correct public inputs
</span><span class="c1"></span>	<span class="c1">// 5. Get public inputs
</span><span class="c1"></span>	<span class="nx">info</span> <span class="o">:=</span> <span class="nx">sma</span><span class="p">.</span><span class="nx">Info</span>
	<span class="nx">sectorSize</span> <span class="o">:=</span> <span class="nx">info</span><span class="p">.</span><span class="nx">SectorSize</span>

	<span class="nx">postCfg</span> <span class="o">:=</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nf">ElectionPoStCfg</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">)</span>

	<span class="nx">pvInfo</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">{</span>
		<span class="nx">Candidates</span><span class="p">:</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">Candidates</span><span class="p">,</span>
		<span class="nx">Proofs</span><span class="p">:</span>     <span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">Proofs</span><span class="p">,</span>
		<span class="nx">Randomness</span><span class="p">:</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">Randomness</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">pv</span> <span class="o">:=</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nf">MakeElectionPoStVerifier</span><span class="p">(</span><span class="nx">postCfg</span><span class="p">)</span>

	<span class="c1">// 5. Verify the PoSt Proof
</span><span class="c1"></span>	<span class="nx">isPoStVerified</span> <span class="o">:=</span> <span class="nx">pv</span><span class="p">.</span><span class="nf">VerifyElectionPoSt</span><span class="p">(</span><span class="nx">pvInfo</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">isPoStVerified</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">_verifyElection</span><span class="p">(</span><span class="nx">header</span> <span class="nx">block</span><span class="p">.</span><span class="nx">BlockHeader</span><span class="p">,</span> <span class="nx">onChainInfo</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainElectionPoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_getStorageMinerActorState</span><span class="p">(</span><span class="nx">header</span><span class="p">.</span><span class="nf">ParentState</span><span class="p">(),</span> <span class="nx">header</span><span class="p">.</span><span class="nf">Miner</span><span class="p">())</span>

	<span class="kd">var</span> <span class="nx">numMinerSectors</span> <span class="kt">uint64</span>
	<span class="nf">TODO</span><span class="p">()</span>
	<span class="c1">// TODO: Decide whether to sample sectors uniformly for EPoSt (the cleanest),
</span><span class="c1"></span>	<span class="c1">// or to sample weighted by nominal power.
</span><span class="c1"></span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">info</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">Candidates</span> <span class="p">{</span>
		<span class="nx">sectorNum</span> <span class="o">:=</span> <span class="nx">info</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">.</span><span class="nx">Number</span>
		<span class="nx">sectorWeightDesc</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">GetStorageWeightDescForSectorMaybe</span><span class="p">(</span><span class="nx">sectorNum</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
		<span class="nx">sectorPower</span> <span class="o">:=</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">ConsensusPowerForStorageWeight</span><span class="p">(</span><span class="nx">sectorWeightDesc</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">sms</span><span class="p">.</span><span class="nf">_consensus</span><span class="p">().</span><span class="nf">IsWinningPartialTicket</span><span class="p">(</span><span class="nx">header</span><span class="p">.</span><span class="nf">ParentState</span><span class="p">(),</span> <span class="nx">info</span><span class="p">.</span><span class="nx">PartialTicket</span><span class="p">,</span> <span class="nx">sectorPower</span><span class="p">,</span> <span class="nx">numMinerSectors</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">_trySurprisePoSt</span><span class="p">(</span><span class="nx">currState</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">sma</span> <span class="nx">sminact</span><span class="p">.</span><span class="nx">StorageMinerActorState</span><span class="p">)</span> <span class="o">*</span><span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainSurprisePoStVerifyInfo</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">sma</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nf">Is_Challenged</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// get randomness for SurprisePoSt
</span><span class="c1"></span>	<span class="nx">challEpoch</span> <span class="o">:=</span> <span class="nx">sma</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">SurpriseChallengeEpoch</span>
	<span class="nx">randomnessK</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">_blockchain</span><span class="p">().</span><span class="nf">BestChain</span><span class="p">().</span><span class="nf">GetPoStChallengeRandSeed</span><span class="p">(</span><span class="nx">challEpoch</span><span class="p">)</span>
	<span class="c1">// unlike with ElectionPoSt no need to use a VRF
</span><span class="c1"></span>	<span class="nx">postRandomness</span> <span class="o">:=</span> <span class="nx">acrypto</span><span class="p">.</span><span class="nf">DeriveRandWithMinerAddr</span><span class="p">(</span><span class="nx">acrypto</span><span class="p">.</span><span class="nx">DomainSeparationTag_SurprisePoStChallengeSeed</span><span class="p">,</span> <span class="nx">randomnessK</span><span class="p">,</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">KeyStore</span><span class="p">().</span><span class="nf">MinerAddress</span><span class="p">())</span>

	<span class="c1">// TODO: add how sectors are actually stored in the SMS proving set
</span><span class="c1"></span>	<span class="nx">util</span><span class="p">.</span><span class="nf">TODO</span><span class="p">()</span>
	<span class="nx">provingSet</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

	<span class="nx">candidates</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">StorageProving</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">GenerateSurprisePoStCandidates</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nf">PoStRandomness</span><span class="p">(</span><span class="nx">postRandomness</span><span class="p">),</span> <span class="nx">provingSet</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">candidates</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="c1">// Error. Will fail this surprise post and must then redeclare faults
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">nil</span> <span class="c1">// fail to generate post candidates
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nx">winningCandidates</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">candidate</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">candidates</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">sma</span><span class="p">.</span><span class="nf">VerifySurprisePoStMeetsTargetReq</span><span class="p">(</span><span class="nx">candidate</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">winningCandidates</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">winningCandidates</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">postProofs</span> <span class="o">:=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">StorageProving</span><span class="p">().</span><span class="nf">Impl</span><span class="p">().</span><span class="nf">CreateSurprisePoStProof</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nf">PoStRandomness</span><span class="p">(</span><span class="nx">postRandomness</span><span class="p">),</span> <span class="nx">winningCandidates</span><span class="p">)</span>

	<span class="c1">// var ctc sector.ChallengeTicketsCommitment // TODO: proofs to fix when complete
</span><span class="c1"></span>	<span class="nx">surprisePoSt</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainSurprisePoStVerifyInfo</span><span class="p">{</span>
		<span class="c1">// CommT_:      ctc,
</span><span class="c1"></span>		<span class="nx">Candidates</span><span class="p">:</span> <span class="nx">winningCandidates</span><span class="p">,</span>
		<span class="nx">Proofs</span><span class="p">:</span>     <span class="nx">postProofs</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">surprisePoSt</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sms</span> <span class="o">*</span><span class="nx">StorageMiningSubsystem_I</span><span class="p">)</span> <span class="nf">_submitSurprisePoStMessage</span><span class="p">(</span><span class="nx">state</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">sPoSt</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainSurprisePoStVerifyInfo</span><span class="p">,</span> <span class="nx">gasPrice</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">gasLimit</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">GasAmount</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c1">// TODO if workerAddr is not a secp key (e.g. BLS) then this will need to be handled differently
</span><span class="c1"></span>	<span class="nx">workerAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">NewSecp256k1Address</span><span class="p">(</span><span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">KeyStore</span><span class="p">().</span><span class="nf">WorkerKey</span><span class="p">().</span><span class="nf">VRFPublicKey</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="nx">worker</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">state</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">workerAddr</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">unsignedCreationMessage</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">msg</span><span class="p">.</span><span class="nx">UnsignedMessage_I</span><span class="p">{</span>
		<span class="nx">From_</span><span class="p">:</span>       <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">KeyStore</span><span class="p">().</span><span class="nf">MinerAddress</span><span class="p">(),</span>
		<span class="nx">To_</span><span class="p">:</span>         <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">KeyStore</span><span class="p">().</span><span class="nf">MinerAddress</span><span class="p">(),</span>
		<span class="nx">Method_</span><span class="p">:</span>     <span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMinerActor_SubmitSurprisePoStResponse</span><span class="p">,</span>
		<span class="nx">Params_</span><span class="p">:</span>     <span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span><span class="nx">sPoSt</span><span class="p">),</span>
		<span class="nx">CallSeqNum_</span><span class="p">:</span> <span class="nx">worker</span><span class="p">.</span><span class="nf">CallSeqNum</span><span class="p">(),</span>
		<span class="nx">Value_</span><span class="p">:</span>      <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">GasPrice_</span><span class="p">:</span>   <span class="nx">gasPrice</span><span class="p">,</span>
		<span class="nx">GasLimit_</span><span class="p">:</span>   <span class="nx">gasLimit</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">workerKey</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">SigKeyPair</span> <span class="c1">// sms.Node().Repository().KeyStore().Worker()
</span><span class="c1"></span>	<span class="nx">signedMessage</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">msg</span><span class="p">.</span><span class="nf">Sign</span><span class="p">(</span><span class="nx">unsignedCreationMessage</span><span class="p">,</span> <span class="nx">workerKey</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="nx">err</span> <span class="p">=</span> <span class="nx">sms</span><span class="p">.</span><span class="nf">Node</span><span class="p">().</span><span class="nf">MessagePool</span><span class="p">().</span><span class="nf">Syncer</span><span class="p">().</span><span class="nf">SubmitMessage</span><span class="p">(</span><span class="nx">signedMessage</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">err</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div>





<h6 id="ticket-validation">Ticket Validation</h6>
<p>Each Ticket should be generated from the prior one in the ticket-chain and verified accordingly as shown in <code>validateTicket</code> below.</p>
<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">chain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/chain&#34;</span>
<span class="kn">import</span> <span class="nx">st</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">blockchain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain&#34;</span>
<span class="kn">import</span> <span class="nx">spowact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_power&#34;</span>
<span class="kn">import</span> <span class="nx">node_base</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/node_base&#34;</span>

<span class="kd">type</span> <span class="nx">StoragePowerConsensusSubsystem</span> <span class="kd">struct</span> <span class="p">{</span><span class="c1">//(@mutable)
</span><span class="c1"></span>    <span class="nf">ChooseTipsetToMine</span><span class="p">(</span><span class="nx">tipsets</span> <span class="p">[</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">])</span> <span class="p">[</span><span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">]</span>

    <span class="nx">node</span>        <span class="nx">node_base</span><span class="p">.</span><span class="nx">FilecoinNode</span>
    <span class="nx">ec</span>          <span class="nx">ExpectedConsensus</span>
    <span class="nx">blockchain</span>  <span class="nx">blockchain</span><span class="p">.</span><span class="nx">BlockchainSubsystem</span>

    <span class="c1">// call by BlockchainSubsystem during block reception
</span><span class="c1"></span>    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span> <span class="kt">error</span>

    <span class="nf">IsWinningPartialTicket</span><span class="p">(</span>
        <span class="nx">st</span>                 <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span>
        <span class="nx">partialTicket</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">PartialTicket</span>
        <span class="nx">sectorUtilization</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span>
        <span class="nx">numSectors</span>         <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">_getStoragePowerActorState</span><span class="p">(</span><span class="nx">stateTree</span> <span class="nx">st</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="nx">spowact</span><span class="p">.</span><span class="nx">StoragePowerActorState</span>

    <span class="nf">validateTicket</span><span class="p">(</span>
        <span class="nx">tix</span>             <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span>
        <span class="nx">pk</span>              <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFPublicKey</span>
        <span class="nx">minerActorAddr</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">computeChainWeight</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span>

    <span class="nf">StoragePowerConsensusError</span><span class="p">()</span> <span class="nx">StoragePowerConsensusError</span>

    <span class="nf">GetFinalizedEpoch</span><span class="p">(</span><span class="nx">currentEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StoragePowerConsensusError</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_power_consensus</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math&#34;</span>

	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">spowact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_power&#34;</span>
	<span class="nx">acrypto</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/crypto&#34;</span>
	<span class="nx">inds</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&#34;</span>
	<span class="nx">serde</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/serde&#34;</span>
	<span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
	<span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
	<span class="nx">chain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/chain&#34;</span>
	<span class="nx">node_base</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/node_base&#34;</span>
	<span class="nx">stateTree</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/state_tree&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="c1">// Storage Power Consensus Subsystem
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Block_I</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">validateTicket</span><span class="p">(</span><span class="nx">ticket</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Ticket</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFPublicKey</span><span class="p">,</span> <span class="nx">minerActorAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">randomness1</span> <span class="o">:=</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">blockchain</span><span class="p">().</span><span class="nf">BestChain</span><span class="p">().</span><span class="nf">GetTicketProductionRandSeed</span><span class="p">(</span><span class="nx">spc</span><span class="p">.</span><span class="nf">blockchain</span><span class="p">().</span><span class="nf">LatestEpoch</span><span class="p">())</span>

	<span class="k">return</span> <span class="nx">ticket</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">randomness1</span><span class="p">,</span> <span class="nx">pk</span><span class="p">,</span> <span class="nx">minerActorAddr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">ComputeChainWeight</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">ec</span><span class="p">().</span><span class="nf">ComputeChainWeight</span><span class="p">(</span><span class="nx">tipset</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">IsWinningPartialTicket</span><span class="p">(</span><span class="nx">stateTree</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">,</span> <span class="nx">inds</span> <span class="nx">inds</span><span class="p">.</span><span class="nx">Indices</span><span class="p">,</span> <span class="nx">partialTicket</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PartialTicket</span><span class="p">,</span> <span class="nx">sectorUtilization</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span> <span class="nx">numSectors</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>

	<span class="c1">// finalize the partial ticket
</span><span class="c1"></span>	<span class="nx">challengeTicket</span> <span class="o">:=</span> <span class="nx">acrypto</span><span class="p">.</span><span class="nf">SHA256</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(</span><span class="nx">partialTicket</span><span class="p">))</span>

	<span class="nx">networkPower</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">TotalNetworkEffectivePower</span><span class="p">()</span>

	<span class="nx">sectorsSampled</span> <span class="o">:=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Ceil</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">node_base</span><span class="p">.</span><span class="nx">EPOST_SAMPLE_RATE_NUM</span><span class="o">/</span><span class="nx">node_base</span><span class="p">.</span><span class="nx">EPOST_SAMPLE_RATE_DENOM</span><span class="p">)</span> <span class="o">*</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">numSectors</span><span class="p">)))</span>

	<span class="k">return</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">ec</span><span class="p">().</span><span class="nf">IsWinningChallengeTicket</span><span class="p">(</span><span class="nx">challengeTicket</span><span class="p">,</span> <span class="nx">sectorUtilization</span><span class="p">,</span> <span class="nx">networkPower</span><span class="p">,</span> <span class="nx">sectorsSampled</span><span class="p">,</span> <span class="nx">numSectors</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">_getStoragePowerActorState</span><span class="p">(</span><span class="nx">stateTree</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nx">StateTree</span><span class="p">)</span> <span class="nx">spowact</span><span class="p">.</span><span class="nx">StoragePowerActorState</span> <span class="p">{</span>
	<span class="nx">powerAddr</span> <span class="o">:=</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span>
	<span class="nx">actorState</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">stateTree</span><span class="p">.</span><span class="nf">GetActor</span><span class="p">(</span><span class="nx">powerAddr</span><span class="p">)</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">substateCID</span> <span class="o">:=</span> <span class="nx">actorState</span><span class="p">.</span><span class="nf">State</span><span class="p">()</span>

	<span class="nx">substate</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">spc</span><span class="p">.</span><span class="nf">node</span><span class="p">().</span><span class="nf">Repository</span><span class="p">().</span><span class="nf">StateStore</span><span class="p">().</span><span class="nf">Get</span><span class="p">(</span><span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">substateCID</span><span class="p">))</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>

	<span class="c1">// fix conversion to bytes
</span><span class="c1"></span>	<span class="nx">util</span><span class="p">.</span><span class="nf">IMPL_FINISH</span><span class="p">(</span><span class="nx">substate</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">serializedSubstate</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Serialization</span>
	<span class="kd">var</span> <span class="nx">st</span> <span class="nx">spowact</span><span class="p">.</span><span class="nx">StoragePowerActorState</span>
	<span class="nx">serde</span><span class="p">.</span><span class="nf">MustDeserialize</span><span class="p">(</span><span class="nx">serializedSubstate</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">st</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">spc</span> <span class="o">*</span><span class="nx">StoragePowerConsensusSubsystem_I</span><span class="p">)</span> <span class="nf">GetFinalizedEpoch</span><span class="p">(</span><span class="nx">currentEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">currentEpoch</span> <span class="o">-</span> <span class="nx">node_base</span><span class="p">.</span><span class="nx">FINALITY</span>
<span class="p">}</span>
</code></pre></div>




</p>
<h5 id="repeated-leader-election-attempts">Repeated Leader Election attempts</h5>
<p>In the case that no miner is eligible to produce a block in a given round of EC, the storage power consensus subsystem will be called by the block producer to attempt another leader election by incrementing the nonce appended to the ticket drawn from the past in order to attempt to find a new winning <code>PartialTicket</code> and trying again.
Note that a miner may attempt to grind through tickets by incrementing the nonce repeatedly until they find a winning ticket. However, any block so generated in the future will be rejected by other miners (with synchronized clocks) until that epoch&rsquo;s appropriate time.</p>
<div id="systems__filecoin_blockchain__storage_power_consensus__min_miner_size"></div>
<h5 id="minimum-miner-size">Minimum Miner Size</h5>
<p>In order to secure Storage Power Consensus, the system defines a minimum miner size required to participate in consensus.</p>
<p>Specifically, miners must have either at least <code>MIN_MINER_SIZE_STOR</code> of power (i.e. storage power currently used in storage deals) in order to participate in leader election. If no miner has <code>MIN_MINER_SIZE_STOR</code> or more power, miners with at least as much power as the smallest miner in the top <code>MIN_MINER_SIZE_TARG</code> of miners (sorted by storage power) will be able to participate in leader election. In plain english, take <code>MIN_MINER_SIZE_TARG = 3</code> for instance, this means that miners with at least as much power as the 3rd largest miner will be eligible to participate in consensus.</p>
<p>Miners smaller than this cannot mine blocks and earn block rewards in the network. Their power will still be counted in the total network (raw or claimed) storage power, even though their power will not be counted as votes for leader election. However, <strong>it is important to note that such miners can still have their power faulted and be penalized accordingly</strong>.</p>
<p>Accordingly, to bootstrap the network, the genesis block must include miners, potentially just CommittedCapacity sectors, to initiate the network.</p>
<p>The <code>MIN_MINER_SIZE_TARG</code> condition will not be used in a network in which any miner has more than <code>MIN_MINER_SIZE_STOR</code> power. It is nonetheless defined to ensure liveness in small networks (e.g. close to genesis or after large power drops).</p>
<!-- raw HTML omitted -->
<p>We currently set:</p>
<ul>
<li><code>MIN_MINER_SIZE_STOR = 100 * (1 &lt;&lt; 40) Bytes</code> (100 TiB)</li>
<li>`MIN_MINER_SIZE_TARG = 3</li>
</ul>
<h5 id="network-recovery-after-halting">Network recovery after halting</h5>
<p>Placeholder where we will define a means of rebooting network liveness after it halts catastrophically (i.e. empty power table).</p>


</div>


  
    








<div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_actor">

<h4 class="section-header">
  Storage Power Actor
</h4>

<div class="section-content">




































<h5 id="storagepoweractorstate-implementation"><code>StoragePowerActorState</code> implementation</h5>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_power</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;sort&#34;</span>

	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">crypto</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/crypto&#34;</span>
	<span class="nx">indices</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&#34;</span>
	<span class="nx">autil</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="c1">// TODO: HAMT
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PowerTableHAMT</span> <span class="kd">map</span><span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span> <span class="c1">// TODO: convert address to ActorID
</span><span class="c1"></span>
<span class="c1">// TODO: HAMT
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">MinerEventsHAMT</span> <span class="kd">map</span><span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">]</span><span class="nx">autil</span><span class="p">.</span><span class="nx">MinerEventSetHAMT</span>

<span class="kd">type</span> <span class="nx">StoragePowerActorState</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">TotalNetworkPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span>

	<span class="nx">PowerTable</span>  <span class="nx">PowerTableHAMT</span>
	<span class="nx">EscrowTable</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">BalanceTableHAMT</span>

	<span class="c1">// Metadata cached for efficient processing of sector/challenge events.
</span><span class="c1"></span>	<span class="nx">CachedDeferredCronEvents</span> <span class="nx">MinerEventsHAMT</span>
	<span class="nx">PoStDetectedFaultMiners</span>  <span class="nx">autil</span><span class="p">.</span><span class="nx">MinerSetHAMT</span>
	<span class="nx">ClaimedPower</span>             <span class="nx">PowerTableHAMT</span>
	<span class="nx">NominalPower</span>             <span class="nx">PowerTableHAMT</span>
	<span class="nx">NumMinersMeetingMinPower</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_minerNominalPowerMeetsConsensusMinimum</span><span class="p">(</span><span class="nx">minerPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>

	<span class="c1">// if miner is larger than min power requirement, we&#39;re set
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">minerPower</span> <span class="o">&gt;=</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">MIN_MINER_SIZE_STOR</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// otherwise, if another miner meets min power requirement, return false
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nx">NumMinersMeetingMinPower</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="c1">// else if none do, check whether in MIN_MINER_SIZE_TARG miners
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">MIN_MINER_SIZE_TARG</span> <span class="p">{</span>
		<span class="c1">// miner should pass
</span><span class="c1"></span>		<span class="k">return</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="c1">// get size of MIN_MINER_SIZE_TARGth largest miner
</span><span class="c1"></span>	<span class="nx">minerSizes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">))</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span> <span class="p">{</span>
		<span class="nx">minerSizes</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">minerSizes</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">sort</span><span class="p">.</span><span class="nf">Slice</span><span class="p">(</span><span class="nx">minerSizes</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nb">int</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span> <span class="p">})</span>
	<span class="k">return</span> <span class="nx">minerPower</span> <span class="o">&gt;=</span> <span class="nx">minerSizes</span><span class="p">[</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">MIN_MINER_SIZE_TARG</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_slashPledgeCollateral</span><span class="p">(</span>
	<span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">slashAmountRequested</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>

	<span class="nf">Assert</span><span class="p">(</span><span class="nx">slashAmountRequested</span> <span class="o">&gt;=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">amountSlashed</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">autil</span><span class="p">.</span><span class="nf">BalanceTable_WithSubtractPreservingNonnegative</span><span class="p">(</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">slashAmountRequested</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">newTable</span>

	<span class="nf">TODO</span><span class="p">()</span>
	<span class="c1">// Decide whether we can take any additional action if there is not enough
</span><span class="c1"></span>	<span class="c1">// pledge collateral to be slashed.
</span><span class="c1"></span>
	<span class="k">return</span> <span class="nx">amountSlashed</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">addrInArray</span><span class="p">(</span><span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">list</span> <span class="p">[]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">list</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">b</span> <span class="o">==</span> <span class="nx">a</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="c1">// _selectMinersToSurprise implements the PoSt-Surprise sampling algorithm
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_selectMinersToSurprise</span><span class="p">(</span><span class="nx">challengeCount</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Randomness</span><span class="p">)</span> <span class="p">[]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="c1">// this wont quite work -- a.PowerTable is a HAMT by actor address, doesn&#39;t
</span><span class="c1"></span>	<span class="c1">// support enumerating by int index. maybe we need that as an interface too,
</span><span class="c1"></span>	<span class="c1">// or something similar to an iterator (or iterator over the keys)
</span><span class="c1"></span>	<span class="c1">// or even a seeded random call directly in the HAMT: myhamt.GetRandomElement(seed []byte, idx int) using the ticket as a seed
</span><span class="c1"></span>
	<span class="nx">ptSize</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">)</span>
	<span class="nx">allMiners</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">))</span>
	<span class="nx">index</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">address</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span> <span class="p">{</span>
		<span class="nx">allMiners</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">address</span>
		<span class="nx">index</span><span class="o">++</span>
	<span class="p">}</span>

	<span class="nx">selectedMiners</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">chall</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">chall</span> <span class="p">&lt;</span> <span class="nx">challengeCount</span><span class="p">;</span> <span class="nx">chall</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">minerIndex</span> <span class="o">:=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nf">RandomInt</span><span class="p">(</span><span class="nx">randomness</span><span class="p">,</span> <span class="nx">chall</span><span class="p">,</span> <span class="nx">ptSize</span><span class="p">)</span>
		<span class="nx">potentialChallengee</span> <span class="o">:=</span> <span class="nx">allMiners</span><span class="p">[</span><span class="nx">minerIndex</span><span class="p">]</span>
		<span class="c1">// skip dups
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">addrInArray</span><span class="p">(</span><span class="nx">potentialChallengee</span><span class="p">,</span> <span class="nx">selectedMiners</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">minerIndex</span> <span class="o">:=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nf">RandomInt</span><span class="p">(</span><span class="nx">randomness</span><span class="p">,</span> <span class="nx">chall</span><span class="p">,</span> <span class="nx">ptSize</span><span class="p">)</span>
			<span class="nx">potentialChallengee</span> <span class="p">=</span> <span class="nx">allMiners</span><span class="p">[</span><span class="nx">minerIndex</span><span class="p">]</span>
		<span class="p">}</span>
		<span class="nx">selectedMiners</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">selectedMiners</span><span class="p">,</span> <span class="nx">potentialChallengee</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">selectedMiners</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_getPowerTotalForMiner</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">power</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">minerPower</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">found</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">minerPower</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_getCurrPledgeForMiner</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span><span class="nx">currPledge</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">autil</span><span class="p">.</span><span class="nf">BalanceTable_GetEntry</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_addClaimedPowerForSector</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">storageWeightDesc</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Note: The following computation does not use any of the dynamic information from CurrIndices();
</span><span class="c1"></span>	<span class="c1">// it depends only on storageWeightDesc. This means that the power of a given storageWeightDesc
</span><span class="c1"></span>	<span class="c1">// does not vary over time, so we can avoid continually updating it for each sector every epoch.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The function is located in the indices module temporarily, until we find a better place for
</span><span class="c1"></span>	<span class="c1">// global parameterization functions.
</span><span class="c1"></span>	<span class="nx">sectorPower</span> <span class="o">:=</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">ConsensusPowerForStorageWeight</span><span class="p">(</span><span class="nx">storageWeightDesc</span><span class="p">)</span>

	<span class="nx">currentPower</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">ClaimedPower</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_setClaimedPowerEntryInternal</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">currentPower</span><span class="o">+</span><span class="nx">sectorPower</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_updatePowerEntriesFromClaimedPower</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_deductClaimedPowerForSectorAssert</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">storageWeightDesc</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Note: The following computation does not use any of the dynamic information from CurrIndices();
</span><span class="c1"></span>	<span class="c1">// it depends only on storageWeightDesc. This means that the power of a given storageWeightDesc
</span><span class="c1"></span>	<span class="c1">// does not vary over time, so we can avoid continually updating it for each sector every epoch.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// The function is located in the indices module temporarily, until we find a better place for
</span><span class="c1"></span>	<span class="c1">// global parameterization functions.
</span><span class="c1"></span>	<span class="nx">sectorPower</span> <span class="o">:=</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">ConsensusPowerForStorageWeight</span><span class="p">(</span><span class="nx">storageWeightDesc</span><span class="p">)</span>

	<span class="nx">currentPower</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">ClaimedPower</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_setClaimedPowerEntryInternal</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">currentPower</span><span class="o">-</span><span class="nx">sectorPower</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_updatePowerEntriesFromClaimedPower</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_updatePowerEntriesFromClaimedPower</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">claimedPower</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">ClaimedPower</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>

	<span class="c1">// Compute nominal power: i.e., the power we infer the miner to have (based on the network&#39;s
</span><span class="c1"></span>	<span class="c1">// PoSt queries), which may not be the same as the claimed power.
</span><span class="c1"></span>	<span class="c1">// Currently, the only reason for these to differ is if the miner is in DetectedFault state
</span><span class="c1"></span>	<span class="c1">// from a SurprisePoSt challenge.
</span><span class="c1"></span>	<span class="nx">nominalPower</span> <span class="o">:=</span> <span class="nx">claimedPower</span>
	<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStDetectedFaultMiners</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span> <span class="p">{</span>
		<span class="nx">nominalPower</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_setNominalPowerEntryInternal</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">nominalPower</span><span class="p">)</span>

	<span class="c1">// Compute actual (consensus) power, i.e., votes in leader election.
</span><span class="c1"></span>	<span class="nx">power</span> <span class="o">:=</span> <span class="nx">nominalPower</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">st</span><span class="p">.</span><span class="nf">_minerNominalPowerMeetsConsensusMinimum</span><span class="p">(</span><span class="nx">nominalPower</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">power</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="p">}</span>

	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: Decide effect of undercollateralization on (consensus) power.
</span><span class="c1"></span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_setPowerEntryInternal</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">power</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_setClaimedPowerEntryInternal</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">updatedMinerClaimedPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">updatedMinerClaimedPower</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">ClaimedPower</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">updatedMinerClaimedPower</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_setNominalPowerEntryInternal</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">updatedMinerNominalPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">updatedMinerNominalPower</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">prevMinerNominalPower</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">NominalPower</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">NominalPower</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">updatedMinerNominalPower</span>

	<span class="nx">consensusMinPower</span> <span class="o">:=</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">StoragePower_ConsensusMinMinerPower</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">updatedMinerNominalPower</span> <span class="o">&gt;=</span> <span class="nx">consensusMinPower</span> <span class="o">&amp;&amp;</span> <span class="nx">prevMinerNominalPower</span> <span class="p">&lt;</span> <span class="nx">consensusMinPower</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">NumMinersMeetingMinPower</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">updatedMinerNominalPower</span> <span class="p">&lt;</span> <span class="nx">consensusMinPower</span> <span class="o">&amp;&amp;</span> <span class="nx">prevMinerNominalPower</span> <span class="o">&gt;=</span> <span class="nx">consensusMinPower</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">NumMinersMeetingMinPower</span> <span class="o">-=</span> <span class="mi">1</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_setPowerEntryInternal</span><span class="p">(</span><span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">updatedMinerPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">updatedMinerPower</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nx">prevMinerPower</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">updatedMinerPower</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">TotalNetworkPower</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">updatedMinerPower</span> <span class="o">-</span> <span class="nx">prevMinerPower</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="nf">_getPledgeSlashForConsensusFault</span><span class="p">(</span><span class="nx">currPledge</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">faultType</span> <span class="nx">ConsensusFaultType</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="c1">// default is to slash all pledge collateral for all consensus fault
</span><span class="c1"></span>	<span class="nf">TODO</span><span class="p">()</span>
	<span class="k">switch</span> <span class="nx">faultType</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">DoubleForkMiningFault</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">currPledge</span>
	<span class="k">case</span> <span class="nx">ParentGrindingFault</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">currPledge</span>
	<span class="k">case</span> <span class="nx">TimeOffsetMiningFault</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">currPledge</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Unsupported case for pledge collateral consensus fault slashing&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_getConsensusFaultSlasherReward</span><span class="p">(</span><span class="nx">elapsedEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">collateralToSlash</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span>
	<span class="c1">// BigInt Operation
</span><span class="c1"></span>	<span class="c1">// var growthRate = builtin.SLASHER_SHARE_GROWTH_RATE_NUM / builtin.SLASHER_SHARE_GROWTH_RATE_DENOM
</span><span class="c1"></span>	<span class="c1">// var multiplier = growthRate^elapsedEpoch
</span><span class="c1"></span>	<span class="c1">// var slasherProportion = min(INITIAL_SLASHER_SHARE * multiplier, 1.0)
</span><span class="c1"></span>	<span class="c1">// return collateralToSlash * slasherProportion
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">PowerTableHAMT_Empty</span><span class="p">()</span> <span class="nx">PowerTableHAMT</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">MinerEventsHAMT_Empty</span><span class="p">()</span> <span class="nx">MinerEventsHAMT</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>





<h5 id="storagepoweractor-implementation"><code>StoragePowerActor</code> implementation</h5>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_power</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math&#34;</span>

	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">crypto</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/crypto&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
	<span class="nx">indices</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&#34;</span>
	<span class="nx">serde</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/serde&#34;</span>
	<span class="nx">autil</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
	<span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">ConsensusFaultType</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">UncommittedPowerFault</span> <span class="nx">ConsensusFaultType</span> <span class="p">=</span> <span class="mi">0</span>
	<span class="nx">DoubleForkMiningFault</span> <span class="nx">ConsensusFaultType</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">ParentGrindingFault</span>   <span class="nx">ConsensusFaultType</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">TimeOffsetMiningFault</span> <span class="nx">ConsensusFaultType</span> <span class="p">=</span> <span class="mi">3</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">StoragePowerActor</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">StoragePowerActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">())</span>
	<span class="kd">var</span> <span class="nx">state</span> <span class="nx">StoragePowerActorState</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;state not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Actor methods
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">AddBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">RT_MinerEntry_ValidateCaller_DetermineFundsLocation</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">MinerEntrySpec_MinerOnly</span><span class="p">)</span>

	<span class="nx">msgValue</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReceived</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">autil</span><span class="p">.</span><span class="nf">BalanceTable_WithAdd</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">msgValue</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Escrow operation failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">newTable</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">WithdrawBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amountRequested</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">amountRequested</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Amount to withdraw must be nonnegative&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">recipientAddr</span> <span class="o">:=</span> <span class="nf">RT_MinerEntry_ValidateCaller_DetermineFundsLocation</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">MinerEntrySpec_MinerOnly</span><span class="p">)</span>

	<span class="nx">minBalanceMaintainRequired</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_rtGetPledgeCollateralReqForMinerOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">amountExtracted</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">autil</span><span class="p">.</span><span class="nf">BalanceTable_WithExtractPartial</span><span class="p">(</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">amountRequested</span><span class="p">,</span> <span class="nx">minBalanceMaintainRequired</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Escrow operation failed&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">newTable</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">recipientAddr</span><span class="p">,</span> <span class="nx">amountExtracted</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">CreateMiner</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">workerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">peerId</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="p">{</span>
	<span class="nx">vmr</span><span class="p">.</span><span class="nf">RT_ValidateImmediateCallerIsSignable</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">ownerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">newMinerAddr</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">NewFromBytes</span><span class="p">(</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">InitActorAddr</span><span class="p">,</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_InitActor_Exec</span><span class="p">,</span>
			<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
				<span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">,</span>
				<span class="nx">ownerAddr</span><span class="p">,</span>
				<span class="nx">workerAddr</span><span class="p">,</span>
				<span class="nx">sectorSize</span><span class="p">,</span>
				<span class="nx">peerId</span><span class="p">,</span>
			<span class="p">),</span>
			<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">).</span><span class="nx">ReturnValue</span><span class="p">,</span>
	<span class="p">)</span>
	<span class="nx">autil</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">autil</span><span class="p">.</span><span class="nf">BalanceTable_WithNewAddressEntry</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">newMinerAddr</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReceived</span><span class="p">())</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">newTable</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">[</span><span class="nx">newMinerAddr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">ClaimedPower</span><span class="p">[</span><span class="nx">newMinerAddr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">NominalPower</span><span class="p">[</span><span class="nx">newMinerAddr</span><span class="p">]</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">newMinerAddr</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">DeleteMiner</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">minerPledgeBalance</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">autil</span><span class="p">.</span><span class="nf">BalanceTable_GetEntry</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Miner address not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">minerPledgeBalance</span> <span class="p">&gt;</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deletion requested for miner with pledge balance still remaining&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">minerPower</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">minerPower</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deletion requested for miner with power still remaining&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">ownerAddr</span><span class="p">,</span> <span class="nx">workerAddr</span> <span class="o">:=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nf">RT_GetMinerAccountsAssert</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerInSet</span><span class="p">([]</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">{</span><span class="nx">ownerAddr</span><span class="p">,</span> <span class="nx">workerAddr</span><span class="p">})</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtDeleteMinerActor</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">OnSectorProveCommit</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">storageWeightDesc</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtAddPowerForSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">(),</span> <span class="nx">storageWeightDesc</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">OnSectorTerminate</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">storageWeightDesc</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">,</span> <span class="nx">terminationType</span> <span class="nx">SectorTerminationType</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtDeductClaimedPowerForSectorAssert</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">storageWeightDesc</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">terminationType</span> <span class="o">!=</span> <span class="nx">SectorTerminationType_NormalExpiration</span> <span class="p">{</span>
		<span class="nx">cidx</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrIndices</span><span class="p">()</span>
		<span class="nx">amountToSlash</span> <span class="o">:=</span> <span class="nx">cidx</span><span class="p">.</span><span class="nf">StoragePower_PledgeSlashForSectorTermination</span><span class="p">(</span><span class="nx">storageWeightDesc</span><span class="p">,</span> <span class="nx">terminationType</span><span class="p">)</span>
		<span class="nx">a</span><span class="p">.</span><span class="nf">_rtSlashPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">amountToSlash</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">OnSectorTemporaryFaultEffectiveBegin</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">storageWeightDesc</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtDeductClaimedPowerForSectorAssert</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">(),</span> <span class="nx">storageWeightDesc</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">OnSectorTemporaryFaultEffectiveEnd</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">storageWeightDesc</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtAddPowerForSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">(),</span> <span class="nx">storageWeightDesc</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">OnSectorModifyWeightDesc</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">storageWeightDescPrev</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">,</span> <span class="nx">storageWeightDescNew</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtDeductClaimedPowerForSectorAssert</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">(),</span> <span class="nx">storageWeightDescPrev</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtAddPowerForSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">(),</span> <span class="nx">storageWeightDescNew</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">OnMinerSurprisePoStSuccess</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PoStDetectedFaultMiners</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_updatePowerEntriesFromClaimedPower</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">OnMinerSurprisePoStFailure</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">numConsecutiveFailures</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">PoStDetectedFaultMiners</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_updatePowerEntriesFromClaimedPower</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">)</span>

	<span class="nx">minerClaimedPower</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">ClaimedPower</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">numConsecutiveFailures</span> <span class="p">&gt;</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">StoragePower_SurprisePoStMaxConsecutiveFailures</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">.</span><span class="nf">_rtDeleteMinerActor</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">cidx</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrIndices</span><span class="p">()</span>
		<span class="nx">amountToSlash</span> <span class="o">:=</span> <span class="nx">cidx</span><span class="p">.</span><span class="nf">StoragePower_PledgeSlashForSurprisePoStFailure</span><span class="p">(</span><span class="nx">minerClaimedPower</span><span class="p">,</span> <span class="nx">numConsecutiveFailures</span><span class="p">)</span>
		<span class="nx">a</span><span class="p">.</span><span class="nf">_rtSlashPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">amountToSlash</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">OnMinerEnrollCronEvent</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">eventEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">sectorNumbers</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>
	<span class="nx">minerEvent</span> <span class="o">:=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">MinerEvent</span><span class="p">{</span>
		<span class="nx">MinerAddr</span><span class="p">:</span> <span class="nx">minerAddr</span><span class="p">,</span>
		<span class="nx">Sectors</span><span class="p">:</span>   <span class="nx">sectorNumbers</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedDeferredCronEvents</span><span class="p">[</span><span class="nx">eventEpoch</span><span class="p">];</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">CachedDeferredCronEvents</span><span class="p">[</span><span class="nx">eventEpoch</span><span class="p">]</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nf">MinerEventSetHAMT_Empty</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">CachedDeferredCronEvents</span><span class="p">[</span><span class="nx">eventEpoch</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">CachedDeferredCronEvents</span><span class="p">[</span><span class="nx">eventEpoch</span><span class="p">],</span> <span class="nx">minerEvent</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">ReportVerifiedConsensusFault</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">slasheeAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">faultEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">faultType</span> <span class="nx">ConsensusFaultType</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">TODO</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// TODO: The semantics here are quite delicate:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// - (proof []block.Block) can&#39;t be validated in isolation; we must query the runtime to confirm
</span><span class="c1"></span>	<span class="c1">//   that at least one of the blocks provided actually appeared in the current chain.
</span><span class="c1"></span>	<span class="c1">// - We must prevent duplicate slashes on the same offense, taking into account that the blocks
</span><span class="c1"></span>	<span class="c1">//   may appear in different orders.
</span><span class="c1"></span>	<span class="c1">// - We must determine how to reward multiple reporters of the same fault within a single epoch.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Deferring to followup after these security/mechanism design questions have been resolved.
</span><span class="c1"></span>	<span class="c1">// Previous notes:
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// validation checks to be done in runtime before calling this method
</span><span class="c1"></span>	<span class="c1">// - there should be exactly two block headers in proof
</span><span class="c1"></span>	<span class="c1">// - both blocks are mined by the same miner
</span><span class="c1"></span>	<span class="c1">// - first block is of the same or lower block height as the second block
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Use EC&#39;s IsValidConsensusFault method to validate the proof
</span><span class="c1"></span>
	<span class="c1">// this method assumes that ConsensusFault has been checked in runtime
</span><span class="c1"></span>	<span class="nx">slasherAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">claimedPower</span><span class="p">,</span> <span class="nx">powerOk</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">ClaimedPower</span><span class="p">[</span><span class="nx">slasheeAddr</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">powerOk</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;spa.ReportConsensusFault: miner to slash has been slashed&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">claimedPower</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>

	<span class="nx">currPledge</span><span class="p">,</span> <span class="nx">pledgeOk</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getCurrPledgeForMiner</span><span class="p">(</span><span class="nx">slasheeAddr</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">pledgeOk</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;spa.ReportConsensusFault: miner to slash has no pledge&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">currPledge</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>

	<span class="c1">// elapsed epoch from the latter block which committed the fault
</span><span class="c1"></span>	<span class="nx">elapsedEpoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">-</span> <span class="nx">faultEpoch</span>
	<span class="k">if</span> <span class="nx">elapsedEpoch</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;spa.ReportConsensusFault: invalid block&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">collateralToSlash</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getPledgeSlashForConsensusFault</span><span class="p">(</span><span class="nx">currPledge</span><span class="p">,</span> <span class="nx">faultType</span><span class="p">)</span>
	<span class="nx">slasherReward</span> <span class="o">:=</span> <span class="nf">_getConsensusFaultSlasherReward</span><span class="p">(</span><span class="nx">elapsedEpoch</span><span class="p">,</span> <span class="nx">collateralToSlash</span><span class="p">)</span>

	<span class="c1">// request slasherReward to be deducted from EscrowTable
</span><span class="c1"></span>	<span class="nx">amountToSlasher</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_slashPledgeCollateral</span><span class="p">(</span><span class="nx">slasherAddr</span><span class="p">,</span> <span class="nx">slasherReward</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">slasherReward</span> <span class="o">==</span> <span class="nx">amountToSlasher</span><span class="p">)</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// reward slasher
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">slasherAddr</span><span class="p">,</span> <span class="nx">amountToSlasher</span><span class="p">)</span>

	<span class="c1">// burn the rest of pledge collateral
</span><span class="c1"></span>	<span class="c1">// delete miner from power table
</span><span class="c1"></span>	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtDeleteMinerActor</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">slasheeAddr</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Called by Cron.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">OnEpochTickEnd</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">CronActorAddr</span><span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtInitiateNewSurprisePoStChallenges</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtProcessDeferredCronEvents</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>

	<span class="nx">st</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">StoragePowerActorState</span><span class="p">{</span>
		<span class="nx">TotalNetworkPower</span><span class="p">:</span>        <span class="nx">abi</span><span class="p">.</span><span class="nf">StoragePower</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">PowerTable</span><span class="p">:</span>               <span class="nf">PowerTableHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">EscrowTable</span><span class="p">:</span>              <span class="nx">autil</span><span class="p">.</span><span class="nf">BalanceTableHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">CachedDeferredCronEvents</span><span class="p">:</span> <span class="nf">MinerEventsHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">PoStDetectedFaultMiners</span><span class="p">:</span>  <span class="nx">autil</span><span class="p">.</span><span class="nf">MinerSetHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">ClaimedPower</span><span class="p">:</span>             <span class="nf">PowerTableHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">NominalPower</span><span class="p">:</span>             <span class="nf">PowerTableHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">NumMinersMeetingMinPower</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="o">*</span><span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Method utility functions
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">_rtAddPowerForSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">storageWeightDesc</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_addClaimedPowerForSector</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">storageWeightDesc</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">_rtDeductClaimedPowerForSectorAssert</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">storageWeightDesc</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_deductClaimedPowerForSectorAssert</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">storageWeightDesc</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">_rtInitiateNewSurprisePoStChallenges</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">provingPeriod</span> <span class="o">:=</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">StorageMining_SurprisePoStProvingPeriod</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// sample the actor addresses
</span><span class="c1"></span>	<span class="nx">minerSelectionSeed</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">GetRandomness</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">())</span>
	<span class="nx">randomness</span> <span class="o">:=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nf">DeriveRandWithEpoch</span><span class="p">(</span><span class="nx">crypto</span><span class="p">.</span><span class="nx">DomainSeparationTag_SurprisePoStSelectMiners</span><span class="p">,</span> <span class="nx">minerSelectionSeed</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()))</span>

	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic (not floating-point)
</span><span class="c1"></span>	<span class="nx">challengeCount</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Ceil</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">))</span> <span class="o">/</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">provingPeriod</span><span class="p">))</span>
	<span class="nx">surprisedMiners</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_selectMinersToSurprise</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">challengeCount</span><span class="p">),</span> <span class="nx">randomness</span><span class="p">)</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">addr</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">surprisedMiners</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
			<span class="nx">addr</span><span class="p">,</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMinerActor_OnSurprisePoStChallenge</span><span class="p">,</span>
			<span class="kc">nil</span><span class="p">,</span>
			<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">_rtProcessDeferredCronEvents</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">epoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">minerEvents</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedDeferredCronEvents</span><span class="p">[</span><span class="nx">epoch</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">CachedDeferredCronEvents</span><span class="p">,</span> <span class="nx">epoch</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">minerEventsRetain</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">autil</span><span class="p">.</span><span class="nx">MinerEvent</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">minerEvent</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">minerEvents</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">[</span><span class="nx">minerEvent</span><span class="p">.</span><span class="nx">MinerAddr</span><span class="p">];</span> <span class="nx">found</span> <span class="p">{</span>
			<span class="nx">minerEventsRetain</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">minerEventsRetain</span><span class="p">,</span> <span class="nx">minerEvent</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">minerEvent</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">minerEventsRetain</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
			<span class="nx">minerEvent</span><span class="p">.</span><span class="nx">MinerAddr</span><span class="p">,</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMinerActor_OnDeferredCronEvent</span><span class="p">,</span>
			<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
				<span class="nx">minerEvent</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">,</span>
			<span class="p">),</span>
			<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">_rtGetPledgeCollateralReqForMinerOrAbort</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">minerNominalPower</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">NominalPower</span><span class="p">[</span><span class="nx">minerAddr</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Miner not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="nx">cidx</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrIndices</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">cidx</span><span class="p">.</span><span class="nf">PledgeCollateralReq</span><span class="p">(</span><span class="nx">minerNominalPower</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">_rtSlashPledgeCollateral</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amountToSlash</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">amountSlashed</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_slashPledgeCollateral</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">amountToSlash</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">amountSlashed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StoragePowerActor</span><span class="p">)</span> <span class="nf">_rtDeleteMinerActor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PowerTable</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">ClaimedPower</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">NominalPower</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PoStDetectedFaultMiners</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>

	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">amountSlashed</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">autil</span><span class="p">.</span><span class="nf">BalanceTable_WithExtractAll</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nf">BalanceTable_WithDeletedAddressEntry</span><span class="p">(</span><span class="nx">newTable</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">newTable</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
		<span class="nx">minerAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMinerActor_OnDeleteMiner</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(),</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">amountSlashed</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>





<div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table"></div>
<h5 id="the-power-table">The Power Table</h5>
<p>The portion of blocks a given miner generates through leader election in EC (and so the block rewards they earn) is proportional to their <code>Power Fraction</code> over time. That is, a miner whose storage represents 1% of total storage on the network should mine 1% of blocks on expectation.</p>
<p>SPC provides a power table abstraction which tracks miner power (i.e. miner storage in relation to network storage) over time. The power table is updated for new sector commitments (incrementing miner power), for failed PoSts (decrementing miner power) or for other storage and consensus faults.</p>
<p>Sector ProveCommit is the first time power is proven to the network and hence power is first added upon successful sector ProveCommit. Power is also added when a sector&rsquo;s TemporaryFault period has ended. Miners are expected to prove over all their sectors that contribute to their power.</p>
<p>Power is decremented when a sector expires, when a sector enters TemporaryFault, or when it is invoked by miners through Sector Termination. Miners can also extend the lifetime of a sector through <code>ExtendSectorExpiration</code> and thus modifying <code>SectorStorageWeightDesc</code>. This may or may not have an impact on power but the machinery is in place to preserve the flexibility.</p>
<p>The Miner lifecycle in the power table should be roughly as follows:</p>
<ul>
<li>MinerRegistration: A new miner with an associated worker public key and address is registered on the power table by the storage mining subsystem, along with their associated sector size (there is only one per worker).</li>
<li>UpdatePower: These power increments and decrements are called by various storage actor (and must thus be verified by every full node on the network). Specifically:
<ul>
<li>Power is incremented at SectorProveCommit</li>
<li>All Power of a particular miner is decremented immediately after a missed SurprisePoSt (DetectedFault).</li>
<li>A particular sector&rsquo;s power is decremented when its TemporaryFault begins.</li>
<li>A particular sector&rsquo;s power is added back when its TemporaryFault ends and miner is expected to prove over this sector.</li>
<li>A particular sector&rsquo;s power is removed when the sector is terminated through sector expiration or miner invocation.</li>
</ul>
</li>
</ul>
<p>To summarize, only sectors in the Active state will command power. A Sector becomes Active when it is added upon ProveCommit. Power is immediately decremented upon when TemporaryFault begins on an Active sector or when the miner is in Challenged or DetectedFault state. Power will be restored when TemporaryFault has ended and when the miner successfully responds to a SurprisePoSt challenge. A sector&rsquo;s power is removed when it is terminated through either miner invocation or normal expiration.</p>
<div id="systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__pledge_collateral"></div>
<h5 id="pledge-collateral">Pledge Collateral</h5>
<p>Consensus in Filecoin is secured in part by economic incentives enforced by Pledge Collateral.</p>
<p>Pledge collateral amount is committed based on power pledged to the system (i.e. proportional to number of sectors committed and sector size for a miner). It is a system-wide parameter and is committed to the <code>StoragePowerActor</code>. Pledge collateral can be posted by the <code>StorageMinerActor</code> at any time by a miner and its requirement is dependent on miner&rsquo;s power. Details around pledge collateral will be announced soon.</p>
<p>Pledge Collateral will be slashed when <a href="./#algorithms__expected_consensus__consensus_faults">Consensus Faults</a> are reported to the <code>StoragePowerActor</code>'s <code>ReportConsensusFault</code> method, when a miner fails a SurprisePoSt (DetectedFault), or when a miner terminates a sector earlier than its duration.</p>
<p>Pledge Collateral is slashed for any fault affecting storage-power consensus, these include:</p>
<ul>
<li>faults to expected consensus in particular (see <a href="./#algorithms__expected_consensus__consensus_faults">Consensus Faults</a>) which will be reported by a slasher to the <code>StoragePowerActor</code> in exchange for a reward.</li>
<li>faults affecting consensus power more generally, specifically uncommitted power faults (i.e. <a href="./#systems__filecoin_markets__storage_market__faults">Storage Faults</a>) which will be reported by the <code>CronActor</code> automatically or when a miner terminates a sector earlier than its promised duration.</li>
</ul>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_token">

<h2 class="section-header">
  <strong>Token</strong>
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token">
        

        <strong>Token</strong>

        
            <br /><br /><i class="menuIcon">üìÄ</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__wallets">
        
            <i class="statusIcon">üõë</i>
        

        Wallet

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payment_channels">
        
            <i class="statusIcon">üîÅ</i>
        

        Payment Channels

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__payment_channels__payment_channel_actor">
        

        Payment Channel Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__multisig">
        
            <i class="statusIcon">‚úÖ</i>
        

        Multisig Wallet

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_token__multisig__multisig_actor">
        

        Multisig Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>



</div>


  
    








<div id="systems__filecoin_token__wallets">

<h3 class="section-header">
  FIL Wallet
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="systems__filecoin_token__payment_channels">

<h3 class="section-header">
  Payment Channels
</h3>

<div class="section-content">




































<div id="systems__filecoin_token__payment_channels__payment_channels"></div>
<p>Payment Channels are used in the Filecoin <a href="./#systems__filecoin_markets__retrieval_market___index">Retrieval Market</a> to enable efficient off-chain payments and accounting between parties for what is expected to be series of microtransactions, specifically those occurring as part of retrieval market data retrieval.</p>
<p>Note that the following provides a high-level overview of payment channels and an accompanying interface. The lotus implementation of <a href="https://github.com/filecoin-project/lotus/blob/master/chain/types/voucher.go">vouchers</a> and <a href="https://github.com/filecoin-project/lotus/tree/master/paych">payment channels</a> are also good references.</p>
<p>You can also read more about the <a href="./#systems__filecoin_token__payment_channels__payment_channel_actor">Filecoin payment channel actor interface</a>.</p>
<p>In short, the payment channel actor can be used to open long-lived, flexible payment channels between users. Each channel can be funded by adding to their balance.
The goal of the payment channel actor is to enable a series of off-chain microtransactions to be reconciled on-chain at a later time with fewer messages. Accordingly, the expectation is <code>From</code> will send to <code>To</code> vouchers of successively greater <code>Value</code> and increasing <code>Nonce</code>s. When they choose to, <code>To</code> can <code>Update</code> the channel to update the balance available <code>ToSend</code> to them in the channel, and can choose to <code>Collect</code> this balance at any time (incurring a gas cost).
The channel is split into <code>lane</code>s created as part of updating the channel state with a payment <code>voucher</code>. Each lane has an associated <code>nonce</code> and amount of tokens it can be <code>redeemed</code> for. These lanes allow for a lot of accounting between parties to be done off chain and reconciled via single updates to the payment channel, merging these lanes to arrive at a desired outcome.</p>
<p>Over the course of a transaction cycle, each party to the payment channel can send the other <code>voucher</code>s. The payment channel&rsquo;s  <code>From</code> account holder will send a signed voucher with a given nonce to the <code>To</code> account holder. The latter can use the voucher to <code>redeem</code> part of the lane&rsquo;s value, merging other lanes into it as needed.</p>
<p>For instance if <code>From</code> sends <code>To</code> the following vouchers (voucher_val, voucher_nonce) for a lane with 100 to be redeemed: (10, 1), (20, 2), (30, 3), then <code>To</code> could choose to redeem (30, 3) bringing the lane&rsquo;s value to 70 (100 - 30). They could not redeem (10, 1) or (20, 2) thereafter. They could however redeem (20, 2) for 20, and then (30, 3) for 10 (30 - 20) thereafter.</p>
<p>The multiple lanes enable two parties to use a single payment channel to adjudicate multiple independent sets of payments.</p>
<p>Vouchers are signed by the sender and authenticated using a <code>Secret</code>, <code>PreImage</code> pair provided by the paying party. If the <code>PreImage</code> is indeed a pre-image of the <code>Secret</code> when used as input to some given algorithm (typically a one-way function like a hash), the <code>Voucher</code> is valid. The <code>Voucher</code> itself contains the <code>PreImage</code> but not the <code>Secret</code> (communicated separately to the receiving party). This enables multi-hop payments since an intermediary cannot redeem a voucher on their own. They can also be used to update the minimum height at which a channel will be closed. Likewise, vouchers can have <code>TimeLock</code>s to prevent they are being used too early, likewise a channel can have a <code>MinCloseHeight</code> to prevent it being closed prematurely (e.g. before the recipient has collected funds) by the sender.</p>
<p>Once their transactions have completed, either party can choose to <code>Close</code> the channel, the recipient can then <code>Collect</code> the <code>ToPay</code> amount from the channel. <code>From</code> will be refunded the remaining balance in the channel.</p>
<p>So we have:</p>
<ul>
<li>[off-chain] - Two parties agree to a series of transactions (for instance as part of file retrieval) with party <strong>A</strong> paying party <strong>B</strong> up to some <strong>total</strong> sum of Filecoin over time.</li>
<li>[on-chain] - The <a href="./#systems__filecoin_token__payment_channels__payment_channel_actor">Payment Channel Actor</a> is used called by A to open a payment channel <code>from</code> A <code>to</code> B and a lane is opened to increase the <code>balance</code> of the channel, triggering a transaction between A and the payment channel actor.
At any time, A can open new lanes to increase the total balance available in the channel (e.g. if A and B choose to do more transactions together).</li>
<li>[off-chain] - Throughout the transaction cycle (e.g. on every piece of data sent via a retrieval deal), party A sends a voucher to party B enabling B to redeem more payment from the payment lanes, and incentivizing B to continue providing a service (e.g. sending more data along).</li>
<li>[on-chain] - At regular intervals, B can <code>Update</code> the payment channel balance available <code>ToSend</code> with the vouchers received (past their <code>timeLock</code>), decreasing the remaining <code>Value</code> of the payment channel.</li>
<li>[on-chain] - At the end of the cycle, past the <code>MinCloseHeight</code>, A can choose to <code>Close</code> the payment channel.</li>
<li>[on-chain] - B can choose to <code>Collect</code> the amount <code>ToSend</code> triggering a payment between the payment channel actor and B.</li>
</ul>


</div>


  
    








<div id="systems__filecoin_token__payment_channels__payment_channel_actor">

<h4 class="section-header">
  Payment Channel Actor
</h4>

<div class="section-content">




































<div id="systems__filecoin_token__payment_channels__payment_channel_actor__payment_channel_actor"></div>
















<p style="color: #D74848"><b><i>Something's not right. The <code>payment_channel_actor.id</code> file was not found.</i></b></p>




</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_token__multisig">

<h3 class="section-header">
  Multisig - Wallet requiring multiple signatures
</h3>

<div class="section-content">






































</div>


  
    








<div id="systems__filecoin_token__multisig__multisig_actor">

<h4 class="section-header">
  Multisig Actor
</h4>

<div class="section-content">




































<p>

















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">multisig</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">actor</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
	<span class="nx">autil</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">InvocOutput</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">InvocOutput</span>
<span class="kd">type</span> <span class="nx">Runtime</span> <span class="p">=</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span>

<span class="kd">var</span> <span class="nx">AssertMsg</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">AssertMsg</span>
<span class="kd">var</span> <span class="nx">IMPL_FINISH</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">IMPL_FINISH</span>
<span class="kd">var</span> <span class="nx">IMPL_TODO</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">IMPL_TODO</span>
<span class="kd">var</span> <span class="nx">TODO</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">TODO</span>

<span class="kd">type</span> <span class="nx">TxnID</span> <span class="kt">int64</span>

<span class="kd">type</span> <span class="nx">MultiSigTransaction</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Proposer</span>   <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">Expiration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>

	<span class="nx">To</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">Method</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodNum</span>
	<span class="nx">Params</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">MethodParams</span>
	<span class="nx">Value</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">txn</span> <span class="o">*</span><span class="nx">MultiSigTransaction</span><span class="p">)</span> <span class="nf">Equals</span><span class="p">(</span><span class="nx">MultiSigTransaction</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MultiSigTransactionHAMT</span> <span class="kd">map</span><span class="p">[</span><span class="nx">TxnID</span><span class="p">]</span><span class="nx">MultiSigTransaction</span>
<span class="kd">type</span> <span class="nx">MultiSigApprovalSetHAMT</span> <span class="kd">map</span><span class="p">[</span><span class="nx">TxnID</span><span class="p">]</span><span class="nx">autil</span><span class="p">.</span><span class="nx">ActorIDSetHAMT</span>

<span class="kd">func</span> <span class="nf">MultiSigTransactionHAMT_Empty</span><span class="p">()</span> <span class="nx">MultiSigTransactionHAMT</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">MultiSigApprovalSetHAMT_Empty</span><span class="p">()</span> <span class="nx">MultiSigApprovalSetHAMT</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MultiSigActor</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">MultiSigActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">())</span>
	<span class="kd">var</span> <span class="nx">state</span> <span class="nx">MultiSigActorState</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;state not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">Propose</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">txn</span> <span class="nx">MultiSigTransaction</span><span class="p">)</span> <span class="nx">TxnID</span> <span class="p">{</span>
	<span class="nx">vmr</span><span class="p">.</span><span class="nf">RT_ValidateImmediateCallerIsSignable</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">callerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtValidateAuthorizedPartyOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">callerAddr</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">txnID</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">NextTxnID</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">NextTxnID</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">PendingTxns</span><span class="p">[</span><span class="nx">txnID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">txn</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">PendingApprovals</span><span class="p">[</span><span class="nx">txnID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nf">ActorIDSetHAMT_Empty</span><span class="p">()</span>
	<span class="nf">UpdateRelease_MultiSig</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Proposal implicitly includes approval of a transaction.
</span><span class="c1"></span>	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtApproveTransactionOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">callerAddr</span><span class="p">,</span> <span class="nx">txnID</span><span class="p">,</span> <span class="nx">txn</span><span class="p">)</span>

	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// Ensure stability across reorgs (consider having proposer supply ID?)
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">txnID</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">Approve</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">txnID</span> <span class="nx">TxnID</span><span class="p">,</span> <span class="nx">txn</span> <span class="nx">MultiSigTransaction</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">vmr</span><span class="p">.</span><span class="nf">RT_ValidateImmediateCallerIsSignable</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">callerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtValidateAuthorizedPartyOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">callerAddr</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtApproveTransactionOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">callerAddr</span><span class="p">,</span> <span class="nx">txnID</span><span class="p">,</span> <span class="nx">txn</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">AddAuthorizedParty</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">actorID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Can only be called by the multisig wallet itself.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrReceiver</span><span class="p">())</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">AuthorizedParties</span><span class="p">[</span><span class="nx">actorID</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nf">UpdateRelease_MultiSig</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">RemoveAuthorizedParty</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">actorID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Can only be called by the multisig wallet itself.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrReceiver</span><span class="p">())</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">AuthorizedParties</span><span class="p">[</span><span class="nx">actorID</span><span class="p">];</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Party not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">AuthorizedParties</span><span class="p">,</span> <span class="nx">actorID</span><span class="p">)</span>

	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">AuthorizedParties</span><span class="p">)</span> <span class="p">&lt;</span> <span class="nx">st</span><span class="p">.</span><span class="nx">NumApprovalsThreshold</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Cannot decrease authorized parties below threshold&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease_MultiSig</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">SwapAuthorizedParty</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">oldActorID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">,</span> <span class="nx">newActorID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Can only be called by the multisig wallet itself.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrReceiver</span><span class="p">())</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">AuthorizedParties</span><span class="p">[</span><span class="nx">oldActorID</span><span class="p">];</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Party not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">AuthorizedParties</span><span class="p">[</span><span class="nx">oldActorID</span><span class="p">];</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Party already present&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">AuthorizedParties</span><span class="p">,</span> <span class="nx">oldActorID</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">AuthorizedParties</span><span class="p">[</span><span class="nx">newActorID</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="nf">UpdateRelease_MultiSig</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">ChangeNumApprovalsThreshold</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">newThreshold</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// Can only be called by the multisig wallet itself.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrReceiver</span><span class="p">())</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">newThreshold</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">newThreshold</span> <span class="p">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">AuthorizedParties</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;New threshold value not supported&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">NumApprovalsThreshold</span> <span class="p">=</span> <span class="nx">newThreshold</span>

	<span class="nf">UpdateRelease_MultiSig</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">Runtime</span><span class="p">,</span> <span class="nx">authorizedParties</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">ActorIDSetHAMT</span><span class="p">,</span> <span class="nx">numApprovalsThreshold</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">InitActorAddr</span><span class="p">)</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>

	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">MultiSigActorState</span><span class="p">{</span>
		<span class="nx">AuthorizedParties</span><span class="p">:</span>     <span class="nx">authorizedParties</span><span class="p">,</span>
		<span class="nx">NumApprovalsThreshold</span><span class="p">:</span> <span class="nx">numApprovalsThreshold</span><span class="p">,</span>
		<span class="nx">PendingTxns</span><span class="p">:</span>           <span class="nf">MultiSigTransactionHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">PendingApprovals</span><span class="p">:</span>      <span class="nf">MultiSigApprovalSetHAMT_Empty</span><span class="p">(),</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease_MultiSig</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">_rtApproveTransactionOrAbort</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">callerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">txnID</span> <span class="nx">TxnID</span><span class="p">,</span> <span class="nx">txn</span> <span class="nx">MultiSigTransaction</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">txnCheck</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PendingTxns</span><span class="p">[</span><span class="nx">txnID</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="o">||</span> <span class="p">!</span><span class="nx">txnCheck</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="nx">txn</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Requested transcation not found or not matched&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">expirationExceeded</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">txn</span><span class="p">.</span><span class="nx">Expiration</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">expirationExceeded</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Transaction expiration exceeded&#34;</span><span class="p">)</span>

		<span class="nf">TODO</span><span class="p">()</span>
		<span class="c1">// Determine what to do about state accumulation over time.
</span><span class="c1"></span>		<span class="c1">// Cannot rely on proposer to delete unexecuted transactions;
</span><span class="c1"></span>		<span class="c1">// there is no incentive (in fact, this costs gas).
</span><span class="c1"></span>		<span class="c1">// Could potentially amortize cost of cleanup via Cron.
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="nf">AssertMsg</span><span class="p">(</span><span class="nx">callerAddr</span><span class="p">.</span><span class="nf">Protocol</span><span class="p">()</span> <span class="o">==</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="s">&#34;caller address does not have ID&#34;</span><span class="p">)</span>
	<span class="nx">actorID</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">IDFromAddress</span><span class="p">(</span><span class="nx">callerAddr</span><span class="p">)</span>
	<span class="nx">autil</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">PendingApprovals</span><span class="p">[</span><span class="nx">txnID</span><span class="p">][</span><span class="nx">abi</span><span class="p">.</span><span class="nf">ActorID</span><span class="p">(</span><span class="nx">actorID</span><span class="p">)]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">thresholdMet</span> <span class="o">:=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PendingApprovals</span><span class="p">[</span><span class="nx">txnID</span><span class="p">])</span> <span class="o">==</span> <span class="nx">st</span><span class="p">.</span><span class="nx">NumApprovalsThreshold</span><span class="p">)</span>

	<span class="nf">UpdateRelease_MultiSig</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">thresholdMet</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">st</span><span class="p">.</span><span class="nf">_hasAvailable</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrentBalance</span><span class="p">(),</span> <span class="nx">txn</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">())</span> <span class="p">{</span>
			<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;insufficient funds unlocked&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// A sufficient number of approvals have arrived and sufficient funds have been unlocked: relay the message and delete from pending queue.
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
			<span class="nx">txn</span><span class="p">.</span><span class="nx">To</span><span class="p">,</span>
			<span class="nx">txn</span><span class="p">.</span><span class="nx">Method</span><span class="p">,</span>
			<span class="nx">txn</span><span class="p">.</span><span class="nx">Params</span><span class="p">,</span>
			<span class="nx">txn</span><span class="p">.</span><span class="nx">Value</span><span class="p">,</span>
		<span class="p">)</span>
		<span class="nx">a</span><span class="p">.</span><span class="nf">_rtDeletePendingTransaction</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">txnID</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">_rtDeletePendingTransaction</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">txnID</span> <span class="nx">TxnID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PendingTxns</span><span class="p">,</span> <span class="nx">txnID</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PendingApprovals</span><span class="p">,</span> <span class="nx">txnID</span><span class="p">)</span>
	<span class="nf">UpdateRelease_MultiSig</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">MultiSigActor</span><span class="p">)</span> <span class="nf">_rtValidateAuthorizedPartyOrAbort</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">AssertMsg</span><span class="p">(</span><span class="nx">address</span><span class="p">.</span><span class="nf">Protocol</span><span class="p">()</span> <span class="o">==</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="s">&#34;caller address does not have ID&#34;</span><span class="p">)</span>
	<span class="nx">actorID</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">IDFromAddress</span><span class="p">(</span><span class="nx">address</span><span class="p">)</span>
	<span class="nx">autil</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">AuthorizedParties</span><span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nf">ActorID</span><span class="p">(</span><span class="nx">actorID</span><span class="p">)];</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Party not authorized&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nf">Release_MultiSig</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Release_MultiSig</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">MultiSigActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">checkCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">st</span><span class="p">))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="nx">checkCID</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">UpdateRelease_MultiSig</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">h</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">st</span> <span class="nx">MultiSigActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newCID</span> <span class="o">:=</span> <span class="nx">actor</span><span class="p">.</span><span class="nf">ActorSubstateCID</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldPut</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">st</span><span class="p">))</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">newCID</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">multisig</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">autil</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">MultiSigActorState</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Linear unlock
</span><span class="c1"></span>	<span class="nx">InitialBalance</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">StartEpoch</span>     <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nx">UnlockDuration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>

	<span class="nx">AuthorizedParties</span>     <span class="nx">autil</span><span class="p">.</span><span class="nx">ActorIDSetHAMT</span>
	<span class="nx">NumApprovalsThreshold</span> <span class="kt">int</span>
	<span class="nx">NextTxnID</span>             <span class="nx">TxnID</span>
	<span class="nx">PendingTxns</span>           <span class="nx">MultiSigTransactionHAMT</span>
	<span class="nx">PendingApprovals</span>      <span class="nx">MultiSigApprovalSetHAMT</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">MultiSigActorState</span><span class="p">)</span> <span class="nf">AmountLocked</span><span class="p">(</span><span class="nx">elapsedEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">elapsedEpoch</span> <span class="o">&gt;=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">UnlockDuration</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// BigInt
</span><span class="c1"></span>	<span class="nx">lockedProportion</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">UnlockDuration</span> <span class="o">-</span> <span class="nx">elapsedEpoch</span><span class="p">)</span> <span class="o">/</span> <span class="nx">st</span><span class="p">.</span><span class="nx">UnlockDuration</span>
	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">InitialBalance</span><span class="p">)</span> <span class="o">*</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">lockedProportion</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// return true if MultiSig maintains required locked balance after spending the amount
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">MultiSigActorState</span><span class="p">)</span> <span class="nf">_hasAvailable</span><span class="p">(</span><span class="nx">currBalance</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">amountToSpend</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">currEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">amountToSpend</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">currBalance</span> <span class="p">&lt;</span> <span class="nx">amountToSpend</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">currBalance</span><span class="o">-</span><span class="nx">amountToSpend</span> <span class="p">&lt;</span> <span class="nx">st</span><span class="p">.</span><span class="nf">AmountLocked</span><span class="p">(</span><span class="nx">currEpoch</span><span class="o">-</span><span class="nx">st</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">MultiSigActorState</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>




</p>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining">

<h2 class="section-header">
  Storage Mining System - proving storage for producing blocks
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining">
        

        <strong>Storage Mining</strong>

        
            <br /><br /><i class="menuIcon">‚õè</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining">
        
            <i class="statusIcon">üîÅ</i>
        

        Storage Miner

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining__mining_cycle">
        

        Storage Mining Cycle

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor">
        

        Storage Miner Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector">
        
            <i class="statusIcon">üîÅ</i>
        

        Sector

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector__sectorset">
        

        Sector Set

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector__posting">
        

        Sector PoSting

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector__sealing">
        

        Sector Sealing

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index">
        
            <i class="statusIcon">‚úÖ</i>
        

        Sector Index

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
            
                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index__sector_builder">
        

        Sector Builder

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__sector_index__sector_store">
        

        SectorStore

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving">
        
            <i class="statusIcon">‚úÖ</i>
        

        Storage Proving

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving__sealer">
        

        Sector Sealer

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_mining__storage_proving__poster">
        

        Sector Poster

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>

<p>The Storage Mining System is the part of the Filecoin Protocol that deals with storing Client&rsquo;s
data, producing proof artifacts that demonstrate correct storage behavior, and managing the work
involved.</p>
<p>Storing data and producing proofs is a complex, highly optimizable process, with lots of tunable
choices. Miners should explore the design space to arrive at something that (a) satisfies protocol
and network-wide constraints, (b) satisfies clients&rsquo; requests and expectations (as expressed in
<code>Deals</code>), and (c) gives them the most cost-effective operation. This part of the Filecoin Spec
primarily describes in detail what MUST and SHOULD happen here, and leaves ample room for
various optimizations for implementers, miners, and users to make. In some parts, we describe
algorithms that could be replaced by other, more optimized versions, but in those cases it is
important that the <strong>protocol constraints</strong> are satisfied. The <strong>protocol constraints</strong> are
spelled out in clear detail (an unclear, unmentioned constraint is a &ldquo;spec error&rdquo;).  It is up
to implementers who deviate from the algorithms presented here to ensure their modifications
satisfy those constraints, especially those relating to protocol security.</p>


</div>


  
    








<div id="systems__filecoin_mining__storage_mining">

<h3 class="section-header">
  Storage Miner
</h3>

<div class="section-content">




































<div id="systems__filecoin_mining__storage_mining__storage_mining_subsystem"></div>
<h4 id="filecoin-storage-mining-subsystem">Filecoin Storage Mining Subsystem</h4>
<p>The Filecoin Storage Mining Subsystem ensures a storage miner can effectively commit storage to the Filecoin protocol in order to both:</p>
<ul>
<li>participate in the Filecoin <a href="./#systems__filecoin_markets__storage_market___index">Storage Market</a> by taking on client data and participating in storage deals.</li>
<li>participate in Filecoin <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a>, verifying and generating blocks to grow the Filecoin blockchain and earning block rewards and fees for doing so.</li>
</ul>
<p>The above involves a number of steps to putting on and maintaining online storage, such as:</p>
<ul>
<li>Committing new storage (see Sealing and PoRep)</li>
<li>Continously proving storage (see <a href="./#algorithms__post__election_post">Election PoSt</a>)</li>
<li>Declaring storage faults and recovering from them.</li>
</ul>
<h5 id="sector-types">Sector Types</h5>
<p>There are two types of sectors, Regular Sectors with storage deals in them and Committed Capacity (CC) Sectors with no deals. All sectors require an expiration epoch that is declared upon PreCommit and sectors are assigned a StartEpoch at ProveCommit. Start and Expiration epoch collectively define the lifetime of a Sector. Length and size of active deals in a sector&rsquo;s lifetime determine the <code>DealWeight</code> of the sector. <code>SectorSize</code>, <code>Duration</code>, and <code>DealWeight</code> statically determine the power assigned to a sector that will remain constant throughout its lifetime. More details on cost and reward for different sector types will be announced soon.</p>
<h5 id="sector-states">Sector States</h5>
<p>When managing their storage <a href="./#systems__filecoin_mining__sector___index">sectors</a>  as part of Filecoin mining, storage providers will account for where in the <a href="./#systems__filecoin_mining__storage_mining__mining_cycle">Storage Mining Cycle</a> their sectors are. For instance, has a sector been committed? Does it need a new PoSt? Most of these operations happen as part of cycles of chain epochs called <code>Proving Period</code>s each of which yield high confidence that every miner in the chain has proven their power (see <a href="./#algorithms__post__election_post">Election PoSt</a>).</p>
<p>There are three states that an individual sector can be in:</p>
<ul>
<li><code>PreCommit</code> when a sector has been added through a PreCommit message.</li>
<li><code>Active</code> when a sector has been proven through a ProveCommit message and when a sector&rsquo;s TemporaryFault period has ended.</li>
<li><code>TemporaryFault</code> when a miner declares fault on a particular sector.</li>
</ul>
<p>Sectors enter <code>Active</code> from <code>PreCommit</code> through a ProveCommit message that serves as the first proof for the sector. PreCommit requires a PreCommit deposit which will be returned upon successful and timely ProveCommit. However, if there is no matching ProveCommit for a particular PreCommit message, the deposit will be burned at PreCommit expiration.</p>
<p>A particular sector enters <code>TemporaryFault</code> from <code>Active</code> through <code>DeclareTemporaryFault</code> with a specified period. Power associated with the sector will be lost immediately and miner needs to pay a <code>TemporaryFaultFee</code> determined by the power suspended and the duration of suspension. At the end of the declared duration, faulted sectors automatically regain power and enter <code>Active</code>. Miners are expected to prove over this recovered sector. Failure to do so may result in failing ElectionPoSt or <code>DetectedFault</code> from failing SurprisePoSt.</p>












<div class="diagram">

<span class="diagram-title">Sector State Machine</span>




(<a href="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_machine.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_machine.dot.svg" />




</div>













<div class="diagram">

<span class="diagram-title">Sector State Machine Legend</span>




(<a href="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_machine_legend.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/diagrams/sector_state_machine_legend.dot.svg" />




</div>

<h6 id="miner-post-state">Miner PoSt State</h6>
<p><code>MinerPoStState</code> keeps track of a miner&rsquo;s state in responding to PoSt and there are three states in <code>MinerPoStState</code>:</p>
<ul>
<li><code>OK</code> miner has passed either a ElectionPoSt or a SurprisePoSt sufficiently recently.</li>
<li><code>Challenged</code> miner has been selected to prove its storage via SurprisePoSt and is currently in the Challenged state</li>
<li><code>DetectedFault</code> miner has failed at least one SurprisePoSt, indicating that all claimed storage may not be proven. Miner has lost power on its sector and recovery can only proceed by a successful response to a subsequent SurprisePoSt challenge, up until the limit of number of consecutive failures.</li>
</ul>
<p><code>DetectedFault</code> is a miner-wide PoSt state when all sectors are considered inactive. All power is lost immediately and pledge collateral is slashed. If a miner remains in <code>DetectedFault</code> for more than MaxConsecutiveFailures, all sectors will be terminated, both power and market actors will be notified for slashing and return of client deal collateral.</p>
<p><code>ProvingSet</code> consists of sectors that miners are required to generate proofs against and is what counts towards miners&rsquo; power. In other words, <code>ProvingSet</code> is a set of all <code>Active</code> sectors for a particular miner. <code>ProvingSet</code> is only relevant when the miner is in OK stage of its <code>MinerPoStState</code>. When a miner is in the <code>Challenged</code> state, <code>ChallengedSectors</code> specify the list of sectors to be challenged which is the <code>ProvingSet</code> before the challenge is issued thus allowing more sectors to be added while it is in the <code>Challenged</code> state.</p>
<p>Miners can call ProveCommit to commit a sector and add to their Claimed Power. However, a miner&rsquo;s Nominal Power and Consensus Power will be zero when it is in either Challenged or DetectedFault state. Note also that miners can call DeclareTemporaryFault when they are in Challenged or DetectedFault state. This does not change the list of  sectors that are currently challenged which is a snapshot of all active sectors (ProvingSet) at the time of challenge.</p>












<div class="diagram">

<span class="diagram-title">Miner PoSt State Machine</span>




(<a href="docs/systems/filecoin_mining/storage_mining/diagrams/miner_post_state_machine.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/diagrams/miner_post_state_machine.dot.svg" />




</div>













<div class="diagram">

<span class="diagram-title">Miner PoSt State Machine Legend</span>




(<a href="docs/systems/filecoin_mining/storage_mining/diagrams/miner_post_state_machine_legend.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/diagrams/miner_post_state_machine_legend.dot.svg" />




</div>



</div>


  
    








<div id="systems__filecoin_mining__storage_mining__mining_cycle">

<h4 class="section-header">
  Storage Mining Cycle
</h4>

<div class="section-content">




































<div id="systems__filecoin_mining__storage_mining__mining_cycle__mining_cycle"></div>
<p>Block miners should constantly be performing Proofs of SpaceTime using <a href="./#algorithms__post__election_post">Election PoSt</a>, and checking the outputted partial tickets to run <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a> and determine whether they can propose a block at each epoch. Epochs are currently set to take around X seconds, in order to account for election PoSt and network propagation around the world. The details of the mining cycle are defined here.</p>
<h6 id="active-miner-mining-cycle">Active Miner Mining Cycle</h6>
<p>In order to mine blocks on the Filecoin blockchain a miner must be running <a href="./#systems__filecoin_blockchain__block__block_validation">Block Validation</a> at all times, keeping track of recent blocks received and the heaviest current chain (based on <a href="./#algorithms__expected_consensus___index">Expected Consensus</a>).</p>
<p>With every new tipset, the miner can use their committed power to attempt to craft a new block.</p>
<p>For additional details around how consensus works in Filecoin, see <a href="./#algorithms__expected_consensus___index">Expected Consensus</a>. For the purposes of this section, there is a consensus protocol (Expected Consensus) that guarantees a fair process for determining what blocks have been generated in a round, whether a miner is eligible to mine a block itself, and other rules pertaining to the production of some artifacts required of valid blocks (e.g. Tickets, ElectionPoSt).</p>
<h6 id="continuous-mining-cycle">Continuous Mining Cycle</h6>
<p>After the chain has caught up to the current head using <a href="./#systems__filecoin_blockchain__chainsync">ChainSync - synchronizing the Blockchain</a>, the mining process is as follows:</p>
<ul>
<li>The node continuously receives and transmits messages using the <a href="./#systems__filecoin_blockchain__message_pool__message_syncer">Message Syncer</a></li>
<li>At the same time it continuously <a href="./#algorithms__block_sync">receives blocks</a>
<ul>
<li>Each block has an associated timestamp and epoch (quantized time window in which it was crafted)</li>
<li>Blocks are validated as they come in during an epoch (provided it is their epoch, see <a href="./#systems__filecoin_blockchain__struct__block___index">validation</a>)</li>
</ul>
</li>
<li>At the end of a given epoch, the miner should take all the valid blocks received for this epoch and assemble them into tipsets according to <a href="./#systems__filecoin_blockchain__struct__tipset___index">tipset validation rules</a></li>
<li>The miner then attempts to mine atop the heaviest tipset (as calculated with <a href="./#algorithms__expected_consensus__chain_selection">EC&#39;s weight function</a>) using its smallest ticket to run leader election
<ul>
<li>The miner runs an <a href="./#algorithms__post__election_post">Election PoSt</a> on their sectors in order to generate partial tickets</li>
<li>The miner uses these tickets in order to run <a href="./#algorithms__expected_consensus__leader_election">Secret Leader Election</a>
<ul>
<li>if successful, the miner generates a new <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">randomness ticket</a> for inclusion in the block</li>
<li>the miner then assembles a new block (see &ldquo;block creation&rdquo; below) and broadcasts it</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This process is repeated until either the <a href="./#algorithms__post__election_post">Election PoSt</a> process yields a winning ticket (in EC) and a block published or a new valid <a href="./#systems__filecoin_blockchain__struct__tipset___index"></a> comes in from the network.</p>
<p>At any height <code>H</code>, there are three possible situations:</p>
<ul>
<li>The miner is eligible to mine a block: they produce their block and propagate it. They then resume mining at the next height <code>H+1</code>.</li>
<li>The miner is not eligible to mine a block but has received blocks: they form a Tipset with them and resume mining at the next height <code>H+1</code>.</li>
<li>The miner is not eligible to mine a block and has received no blocks: prompted by their clock they run leader election again, incrementing the epoch number.</li>
</ul>
<p>Anytime a miner receives new valid blocks, it should evaluate what is the heaviest Tipset it knows about and mine atop it.</p>
<h6 id="timing">Timing</h6>












<div class="diagram">

<span class="diagram-title">Mining Cycle Timing</span>




(<a href="docs/systems/filecoin_mining/storage_mining/./diagrams/timing.png" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/storage_mining/./diagrams/timing.png" />




</div>

<p>The mining cycle relies on receiving and producing blocks concurrently.  The sequence of these events in time is given by the timing diagram above.  The upper row represents the conceptual consumption channel consisting of successive receiving periods <code>Rx</code> during which nodes validate and select blocks as chain heads.  The lower row is the conceptual production channel made up of a period of mining <code>M</code> followed by a period of transmission <code>Tx</code>.  The lengths of the periods are not to scale.</p>
<p>Blocks are received and validated during <code>Rx</code> up to the end of the epoch.  At the beginning of the next epoch, the heaviest tipset is computed from the blocks received during <code>Rx</code>, used as the head to build on during <code>M</code>.  If mining is successful a block is transmitted during <code>Tx</code>.  The epoch boundaries are as shown.</p>
<p>In a fully synchronized network most of period <code>Rx</code> does not see any network traffic, only the period lined up with <code>Tx</code>.  In practice we expect blocks from previous epochs to propagate during the remainder of <code>Rx</code>.  We also expect differences in operator mining time to cause additional variance.</p>
<p>This sequence of events applies only when the node is in the <code>CHAIN_FOLLOW</code> syncing mode.  Nodes in other syncing modes do not mine blocks.</p>
<h6 id="full-miner-lifecycle">Full Miner Lifecycle</h6>
<h6 id="step-0-registration-and-market-participation">Step 0: Registration and Market participation</h6>
<p>To initially become a miner, a miner first register a new miner actor on-chain. This is done through the storage power actor&rsquo;s <code>CreateStorageMiner</code> method. The call will then create a new miner actor instance and return its address.</p>
<p>The next step is to place one or more storage market asks on the market. This is done off-chain as part of storage market functions. A miner may create a single ask for their entire storage, or partition their storage up in some way with multiple asks (at potentially different prices).</p>
<p>After that, they need to make deals with clients and begin filling up sectors with data. For more information on making deals, see the <a href="./#systems__filecoin_markets__storage_market___index">Storage Market</a>. The miner will need to put up storage deal collateral for the deals they have entered into.</p>
<p>When they have a full sector, they should seal it. This is done by invoking the <a href="./#systems__filecoin_mining__storage_proving__sector_sealer">Sector Sealer</a>.</p>
<h6 id="ownerworker-distinction">Owner/Worker distinction</h6>
<p>The miner actor has two distinct &lsquo;controller&rsquo; <a href="./#appendix__address">addresses</a>. One is the worker, which is the address which will be responsible for doing all of the work, submitting proofs, committing new sectors, and all other day to day activities. The owner address is the address that created the miner, paid the collateral, and has block rewards paid out to it. The reason for the distinction is to allow different parties to fulfil the different roles. One example would be for the owner to be a multisig wallet, or a cold storage key, and the worker key to be a &lsquo;hot wallet&rsquo; key.</p>
<h6 id="changing-worker-addresses">Changing Worker Addresses</h6>
<p>Note that any change to worker keys after registration must be appropriately delayed in relation to randomness lookback for SEALing data (see <a href="https://github.com/filecoin-project/specs/issues/415">this issue</a>).</p>
<h6 id="step-1-committing-sectors">Step 1: Committing Sectors</h6>
<p>When the miner has completed their first seal, they should post it on-chain using the <a href="./#systems__filecoin_mining__storage_mining__storage_miner_actor">Storage Miner Actor</a>&rsquo;s <code>ProveCommitSector</code> function. The miner will need to put up pledge collateral in proportion to the amount of storage they commit on chain. Miner will now gain power for this particular sector upon successful <code>ProveCommitSector</code>.</p>
<p>You can read more about sectors <a href="./#systems__filecoin_mining__sector___index">here</a> and how sector relates to power <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power">here</a>.</p>
<h6 id="step-2-running-elections">Step 2: Running Elections</h6>
<p>Once the miner has power on the network, they can begin to submit <code>ElectionPoSts</code>. To do so, the miner must run a PoSt on a subset of their sectors in every round, using the outputted partial tickets to run leader election.</p>
<p>If the miner finds winning tickets, they are eligible to generate a new block and earn block rewards using the <a href="./#systems__filecoin_blockchain__struct__block_producer___index">Block Producer</a>.</p>
<p>Every successful PoSt submission will delay the next SurprisePoSt challenge the miner will receive.</p>
<p>In this period, the miner can still:</p>
<ul>
<li>commit new sectors</li>
<li>be challenged with a SurprisePoSt</li>
<li>declare faults</li>
</ul>
<h6 id="faults">Faults</h6>
<p>If a miner detects <a href="./#systems__filecoin_markets__storage_market__faults">Storage Faults</a> among their sectors (any sort of storage failure that would prevent them from crafting a PoSt), they should declare these faults with the <code>DeclareTemporaryFaults()</code> method of the Storage Miner Actor.</p>
<p>The miner will be unable to craft valid PoSts over faulty sectors, thereby reducing their chances of winning Election and SurprisePoSts. By declaring a fault, the miner will no longer be challenged on that sector, and will lose power accordingly. The miner can specify how long the duration of their TemporaryFault and pay a TemporaryFaultFee.</p>
<p>A miner will no longer be able to declare faults after being challenged for a SurprisePoSt.</p>
<h6 id="step-3-dealsector-expiration">Step 3: Deal/Sector Expiration</h6>
<p>In order to stop mining, a miner must complete all of its storage deals. Once all deals in a sector have expired, the sector itself will expire thereby enabling the miner to remove the associated collateral from their account.</p>
<h6 id="future-work">Future Work</h6>
<p>There are many ideas for improving upon the storage miner, here are ideas that may be potentially implemented in the future.</p>
<ul>
<li><strong>Sector Resealing</strong>: Miners should be able to &lsquo;re-seal&rsquo; sectors, to allow them to take a set of sectors with mostly expired pieces, and combine the not-yet-expired pieces into a single (or multiple) sectors.</li>
<li><strong>Sector Transfer</strong>: Miners should be able to re-delegate the responsibility of storing data to another miner. This is tricky for many reasons, and will not be implemented in the initial release of Filecoin, but could provide interesting capabilities down the road.</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_mining__storage_mining__storage_miner_actor">

<h4 class="section-header">
  Storage Miner Actor
</h4>

<div class="section-content">




































<div id="systems__filecoin_mining__storage_mining__storage_miner_actor__storage_miner_actor"></div>
<h5 id="storagemineractorstate-implementation"><code>StorageMinerActorState</code> implementation</h5>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_miner</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math/big&#34;</span>

	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">indices</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&#34;</span>
	<span class="nx">autil</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
	<span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>
<span class="p">)</span>

<span class="c1">// Balance of a StorageMinerActor should equal exactly the sum of PreCommit deposits
</span><span class="c1">// that are not yet returned or burned.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StorageMinerActorState</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Sectors</span>    <span class="nx">SectorsAMT</span>
	<span class="nx">PoStState</span>  <span class="nx">MinerPoStState</span>
	<span class="nx">ProvingSet</span> <span class="nx">SectorNumberSetHAMT</span>
	<span class="nx">Info</span>       <span class="nx">MinerInfo</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MinerPoStState</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Epoch of the last succesful PoSt, either election post or surprise post.
</span><span class="c1"></span>	<span class="nx">LastSuccessfulPoSt</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>

	<span class="c1">// If &gt;= 0 miner has been challenged and not yet responded successfully.
</span><span class="c1"></span>	<span class="c1">// SurprisePoSt challenge state: The miner has not submitted timely ElectionPoSts,
</span><span class="c1"></span>	<span class="c1">// and as a result, the system has fallen back to proving storage via SurprisePoSt.
</span><span class="c1"></span>	<span class="c1">//  `epochUndefined` if not currently challeneged.
</span><span class="c1"></span>	<span class="nx">SurpriseChallengeEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>

	<span class="c1">// Not empty iff the miner is challenged.
</span><span class="c1"></span>	<span class="nx">ChallengedSectors</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span>

	<span class="c1">// Number of surprised post challenges that have been failed since last successful PoSt.
</span><span class="c1"></span>	<span class="c1">// Indicates that the claimed storage power may not actually be proven. Recovery can proceed by
</span><span class="c1"></span>	<span class="c1">// submitting a correct response to a subsequent SurprisePoSt challenge, up until
</span><span class="c1"></span>	<span class="c1">// the limit of number of consecutive failures.
</span><span class="c1"></span>	<span class="nx">NumConsecutiveFailures</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">mps</span> <span class="o">*</span><span class="nx">MinerPoStState</span><span class="p">)</span> <span class="nf">Is_Challenged</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">mps</span><span class="p">.</span><span class="nx">SurpriseChallengeEpoch</span> <span class="o">!=</span> <span class="nx">epochUndefined</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">mps</span> <span class="o">*</span><span class="nx">MinerPoStState</span><span class="p">)</span> <span class="nf">Is_OK</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">!</span><span class="nx">mps</span><span class="p">.</span><span class="nf">Is_Challenged</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">mps</span><span class="p">.</span><span class="nf">Is_DetectedFault</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">mps</span> <span class="o">*</span><span class="nx">MinerPoStState</span><span class="p">)</span> <span class="nf">Is_DetectedFault</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">mps</span><span class="p">.</span><span class="nx">NumConsecutiveFailures</span> <span class="p">&gt;</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorState</span> <span class="kt">int64</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">PreCommit</span> <span class="nx">SectorState</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">Active</span>
	<span class="nx">TemporaryFault</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">SectorOnChainInfo</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">State</span>                 <span class="nx">SectorState</span>
	<span class="nx">Info</span>                  <span class="nx">SectorPreCommitInfo</span> <span class="c1">// Also contains Expiration field.
</span><span class="c1"></span>	<span class="nx">PreCommitDeposit</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">PreCommitEpoch</span>        <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nx">ActivationEpoch</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="c1">// -1 if still in PreCommit state.
</span><span class="c1"></span>	<span class="nx">DeclaredFaultEpoch</span>    <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="c1">// -1 if not currently declared faulted.
</span><span class="c1"></span>	<span class="nx">DeclaredFaultDuration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="c1">// -1 if not currently declared faulted.
</span><span class="c1"></span>	<span class="nx">DealWeight</span>            <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span>        <span class="c1">// -1 if not yet validated with StorageMarketActor.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorPreCommitInfo</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">SectorNumber</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span>
	<span class="nx">SealedCID</span>    <span class="nx">abi</span><span class="p">.</span><span class="nx">SealedSectorCID</span> <span class="c1">// CommR
</span><span class="c1"></span>	<span class="nx">SealEpoch</span>    <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nx">DealIDs</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span>
	<span class="nx">Expiration</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorProveCommitInfo</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">SectorNumber</span>     <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span>
	<span class="nx">RegisteredProof</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span>
	<span class="nx">Proof</span>            <span class="nx">abi</span><span class="p">.</span><span class="nx">SealProof</span>
	<span class="nx">InteractiveEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nx">Expiration</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="c1">// TODO AMT
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorsAMT</span> <span class="kd">map</span><span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span><span class="nx">SectorOnChainInfo</span>

<span class="c1">// TODO HAMT
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorNumberSetHAMT</span> <span class="kd">map</span><span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span><span class="kt">bool</span>

<span class="kd">type</span> <span class="nx">MinerInfo</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// Account that owns this miner.
</span><span class="c1"></span>	<span class="c1">// - Income and returned collateral are paid to this address.
</span><span class="c1"></span>	<span class="c1">// - This address is also allowed to change the worker address for the miner.
</span><span class="c1"></span>	<span class="nx">Owner</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="c1">// Must be an ID-address.
</span><span class="c1"></span>
	<span class="c1">// Worker account for this miner.
</span><span class="c1"></span>	<span class="c1">// This will be the key that is used to sign blocks created by this miner, and
</span><span class="c1"></span>	<span class="c1">// sign messages sent on behalf of this miner to commit sectors, submit PoSts, and
</span><span class="c1"></span>	<span class="c1">// other day to day miner activities.
</span><span class="c1"></span>	<span class="nx">Worker</span>       <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="c1">// Must be an ID-address.
</span><span class="c1"></span>	<span class="nx">WorkerVRFKey</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span> <span class="c1">// Must be a SECP or BLS address
</span><span class="c1"></span>
	<span class="c1">// Libp2p identity that should be used when connecting to this miner.
</span><span class="c1"></span>	<span class="nx">PeerId</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>

	<span class="c1">// Amount of space in each sector committed to the network by this miner.
</span><span class="c1"></span>	<span class="nx">SectorSize</span>             <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span>
	<span class="nx">SealPartitions</span>         <span class="kt">int64</span>
	<span class="nx">ElectionPoStPartitions</span> <span class="kt">int64</span>
	<span class="nx">SurprisePoStPartitions</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState</span><span class="p">)</span> <span class="nf">_getSectorOnChainInfo</span><span class="p">(</span><span class="nx">sectorNo</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">(</span><span class="nx">info</span> <span class="nx">SectorOnChainInfo</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sectorInfo</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">sectorNo</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">SectorOnChainInfo</span><span class="p">{},</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">sectorInfo</span><span class="p">,</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState</span><span class="p">)</span> <span class="nf">_getSectorDealIDsAssert</span><span class="p">(</span><span class="nx">sectorNo</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span> <span class="p">{</span>
	<span class="nx">sectorInfo</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getSectorOnChainInfo</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">found</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">DealIDs</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SectorsAMT_Empty</span><span class="p">()</span> <span class="nx">SectorsAMT</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SectorNumberSetHAMT_Empty</span><span class="p">()</span> <span class="nx">SectorNumberSetHAMT</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState</span><span class="p">)</span> <span class="nf">GetStorageWeightDescForSectorMaybe</span><span class="p">(</span><span class="nx">sectorNumber</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">(</span><span class="nx">ret</span> <span class="nx">SectorStorageWeightDesc</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">sectorInfo</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">sectorNumber</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">SectorStorageWeightDesc</span><span class="p">{}</span>
		<span class="nx">ok</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">ret</span> <span class="p">=</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">SectorStorageWeightDesc</span><span class="p">{</span>
		<span class="nx">SectorSize</span><span class="p">:</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span>
		<span class="nx">DealWeight</span><span class="p">:</span> <span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">DealWeight</span><span class="p">,</span>
		<span class="nx">Duration</span><span class="p">:</span>   <span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Expiration</span> <span class="o">-</span> <span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">ActivationEpoch</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">ok</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState</span><span class="p">)</span> <span class="nf">_getStorageWeightDescForSector</span><span class="p">(</span><span class="nx">sectorNumber</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="nx">SectorStorageWeightDesc</span> <span class="p">{</span>
	<span class="nx">ret</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">GetStorageWeightDescForSectorMaybe</span><span class="p">(</span><span class="nx">sectorNumber</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">found</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState</span><span class="p">)</span> <span class="nf">_getStorageWeightDescsForSectors</span><span class="p">(</span><span class="nx">sectorNumbers</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">[]</span><span class="nx">SectorStorageWeightDesc</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">SectorStorageWeightDesc</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNumber</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sectorNumbers</span> <span class="p">{</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getStorageWeightDescForSector</span><span class="p">(</span><span class="nx">sectorNumber</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">SectorOnChainInfo</span><span class="p">)</span> <span class="nf">Is_TemporaryFault</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">TemporaryFault</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">ret</span> <span class="p">{</span>
		<span class="nf">Assert</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">DeclaredFaultEpoch</span> <span class="o">!=</span> <span class="nx">epochUndefined</span><span class="p">)</span>
		<span class="nf">Assert</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">DeclaredFaultDuration</span> <span class="o">!=</span> <span class="nx">epochUndefined</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="c1">// Must be significantly larger than DeclaredFaultEpoch, since otherwise it may be possible
</span><span class="c1">// to declare faults adaptively in order to exempt challenged sectors.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">SectorOnChainInfo</span><span class="p">)</span> <span class="nf">EffectiveFaultBeginEpoch</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nf">Is_TemporaryFault</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">DeclaredFaultEpoch</span> <span class="o">+</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">StorageMining_DeclaredFaultEffectiveDelay</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">x</span> <span class="o">*</span><span class="nx">SectorOnChainInfo</span><span class="p">)</span> <span class="nf">EffectiveFaultEndEpoch</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nf">Is_TemporaryFault</span><span class="p">())</span>
	<span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nf">EffectiveFaultBeginEpoch</span><span class="p">()</span> <span class="o">+</span> <span class="nx">x</span><span class="p">.</span><span class="nx">DeclaredFaultDuration</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">MinerInfo_New</span><span class="p">(</span>
	<span class="nx">ownerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">workerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">peerId</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span> <span class="nx">MinerInfo</span> <span class="p">{</span>

	<span class="nx">ret</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">MinerInfo</span><span class="p">{</span>
		<span class="nx">Owner</span><span class="p">:</span>      <span class="nx">ownerAddr</span><span class="p">,</span>
		<span class="nx">Worker</span><span class="p">:</span>     <span class="nx">workerAddr</span><span class="p">,</span>
		<span class="nx">PeerId</span><span class="p">:</span>     <span class="nx">peerId</span><span class="p">,</span>
		<span class="nx">SectorSize</span><span class="p">:</span> <span class="nx">sectorSize</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nf">TODO</span><span class="p">()</span> <span class="c1">// TODO: determine how to generate/validate VRF key and initialize other fields
</span><span class="c1"></span>
	<span class="k">return</span> <span class="o">*</span><span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMinerActorState</span><span class="p">)</span> <span class="nf">VerifySurprisePoStMeetsTargetReq</span><span class="p">(</span><span class="nx">candidate</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// TODO: Determine what should be the acceptance criterion for sector numbers proven in SurprisePoSt proofs.
</span><span class="c1"></span>	<span class="nf">TODO</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SectorNumberSetHAMT_Items</span><span class="p">(</span><span class="nx">x</span> <span class="nx">SectorNumberSetHAMT</span><span class="p">)</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>





<h5 id="storagemineractorcode-implementation"><code>StorageMinerActorCode</code> implementation</h5>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_miner</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;math/big&#34;</span>

	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">crypto</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/crypto&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
	<span class="nx">indices</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&#34;</span>
	<span class="nx">serde</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/serde&#34;</span>
	<span class="nx">autil</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
	<span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">epochUndefined</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">ChainEpoch</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="kd">type</span> <span class="nx">StorageMinerActor</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">StorageMinerActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">())</span>
	<span class="kd">var</span> <span class="nx">state</span> <span class="nx">StorageMinerActorState</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;state not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>

<span class="c1">//////////////////
</span><span class="c1">// SurprisePoSt //
</span><span class="c1">//////////////////
</span><span class="c1"></span>
<span class="c1">// Called by StoragePowerActor to notify StorageMiner of SurprisePoSt Challenge.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">OnSurprisePoStChallenge</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// If already challenged, do not challenge again.
</span><span class="c1"></span>	<span class="c1">// Failed PoSt will automatically reset the state to not-challenged.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nf">Is_Challenged</span><span class="p">()</span> <span class="p">{</span>
		<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Do not challenge if the last successful PoSt was recent enough.
</span><span class="c1"></span>	<span class="nx">noChallengePeriod</span> <span class="o">:=</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">StorageMining_PoStNoChallengePeriod</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">LastSuccessfulPoSt</span> <span class="o">&gt;=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span><span class="o">-</span><span class="nx">noChallengePeriod</span> <span class="p">{</span>
		<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">curRecBuf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrReceiver</span><span class="p">().</span><span class="nf">MarshalCBOR</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">curRecBuf</span><span class="p">)</span>
	<span class="nx">autil</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="nx">randomnessK</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">GetRandomness</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">-</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_POST</span><span class="p">)</span>
	<span class="nx">challengedSectorsRandomness</span> <span class="o">:=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nf">DeriveRandWithMinerAddr</span><span class="p">(</span><span class="nx">crypto</span><span class="p">.</span><span class="nx">DomainSeparationTag_SurprisePoStSampleSectors</span><span class="p">,</span> <span class="nx">randomnessK</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrReceiver</span><span class="p">())</span>

	<span class="nx">challengedSectors</span> <span class="o">:=</span> <span class="nf">_surprisePoStSampleChallengedSectors</span><span class="p">(</span>
		<span class="nx">challengedSectorsRandomness</span><span class="p">,</span>
		<span class="nf">SectorNumberSetHAMT_Items</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">),</span>
	<span class="p">)</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span> <span class="p">=</span> <span class="nx">MinerPoStState</span><span class="p">{</span>
		<span class="nx">LastSuccessfulPoSt</span><span class="p">:</span>     <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">LastSuccessfulPoSt</span><span class="p">,</span>
		<span class="nx">SurpriseChallengeEpoch</span><span class="p">:</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">(),</span>
		<span class="nx">ChallengedSectors</span><span class="p">:</span>      <span class="nx">challengedSectors</span><span class="p">,</span>
		<span class="nx">NumConsecutiveFailures</span><span class="p">:</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">NumConsecutiveFailures</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Request deferred Cron check for SurprisePoSt challenge expiry.
</span><span class="c1"></span>	<span class="nx">provingPeriod</span> <span class="o">:=</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">StorageMining_SurprisePoStProvingPeriod</span><span class="p">()</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtEnrollCronEvent</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span><span class="o">+</span><span class="nx">provingPeriod</span><span class="p">,</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">{})</span>
<span class="p">}</span>

<span class="c1">// Invoked by miner&#39;s worker address to submit a response to a pending SurprisePoSt challenge.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">SubmitSurprisePoStResponse</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">onChainInfo</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainSurprisePoStVerifyInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Worker</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nf">Is_Challenged</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Not currently challenged&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtVerifySurprisePoStOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">onChainInfo</span><span class="p">)</span>

	<span class="nx">newPostSt</span> <span class="o">:=</span> <span class="nx">MinerPoStState</span><span class="p">{</span>
		<span class="nx">LastSuccessfulPoSt</span><span class="p">:</span>     <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">(),</span>
		<span class="nx">SurpriseChallengeEpoch</span><span class="p">:</span> <span class="nx">epochUndefined</span><span class="p">,</span>
		<span class="nx">ChallengedSectors</span><span class="p">:</span>      <span class="kc">nil</span><span class="p">,</span>
		<span class="nx">NumConsecutiveFailures</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtUpdatePoStState</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">newPostSt</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_OnMinerSurprisePoStSuccess</span><span class="p">,</span>
		<span class="kc">nil</span><span class="p">,</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Called by StoragePowerActor.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">OnDeleteMiner</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrReceiver</span><span class="p">()</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">DeleteActor</span><span class="p">(</span><span class="nx">minerAddr</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//////////////////
</span><span class="c1">// ElectionPoSt //
</span><span class="c1">//////////////////
</span><span class="c1"></span>
<span class="c1">// Called by the VM interpreter once an ElectionPoSt has been verified.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">OnVerifiedElectionPoSt</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>

	<span class="c1">// The receiver must be the miner who produced the block for which this message is created.
</span><span class="c1"></span>	<span class="nf">Assert</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">ToplevelBlockWinner</span><span class="p">()</span> <span class="o">==</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrReceiver</span><span class="p">())</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">updateSuccessEpoch</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nf">Is_OK</span><span class="p">()</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Advance the timestamp of the most recent PoSt success, provided the miner is currently
</span><span class="c1"></span>	<span class="c1">// in normal state. (Cannot do this if SurprisePoSt mechanism already underway.)
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">updateSuccessEpoch</span> <span class="p">{</span>
		<span class="nx">newPostSt</span> <span class="o">:=</span> <span class="nx">MinerPoStState</span><span class="p">{</span>
			<span class="nx">LastSuccessfulPoSt</span><span class="p">:</span>     <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">(),</span>
			<span class="nx">SurpriseChallengeEpoch</span><span class="p">:</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">SurpriseChallengeEpoch</span><span class="p">,</span> <span class="c1">// expected to be undef because PoStState is OK
</span><span class="c1"></span>			<span class="nx">ChallengedSectors</span><span class="p">:</span>      <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">ChallengedSectors</span><span class="p">,</span>      <span class="c1">// expected to be empty
</span><span class="c1"></span>			<span class="nx">NumConsecutiveFailures</span><span class="p">:</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">NumConsecutiveFailures</span><span class="p">,</span> <span class="c1">// expected to be 0
</span><span class="c1"></span>		<span class="p">}</span>
		<span class="nx">a</span><span class="p">.</span><span class="nf">_rtUpdatePoStState</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">newPostSt</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">///////////////////////
</span><span class="c1">// Sector Commitment //
</span><span class="c1">///////////////////////
</span><span class="c1"></span>
<span class="c1">// Deals must be posted on chain via sma.PublishStorageDeals before PreCommitSector.
</span><span class="c1">// Optimization: PreCommitSector could contain a list of deals that are not published yet.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">PreCommitSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">SectorPreCommitInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Worker</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">info</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">];</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Sector number already exists in table&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">cidx</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrIndices</span><span class="p">()</span>
	<span class="nx">depositReq</span> <span class="o">:=</span> <span class="nx">cidx</span><span class="p">.</span><span class="nf">StorageMining_PreCommitDeposit</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">info</span><span class="p">.</span><span class="nx">Expiration</span><span class="p">)</span>
	<span class="nf">RT_ConfirmFundsReceiptOrAbort_RefundRemainder</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">depositReq</span><span class="p">)</span>

	<span class="c1">// Verify deals with StorageMarketActor; abort if this fails.
</span><span class="c1"></span>	<span class="c1">// (Note: committed-capacity sectors contain no deals, so in that case verification will pass trivially.)
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMarketActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMarketActor_OnMinerSectorPreCommit_VerifyDealsOrAbort</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
			<span class="nx">info</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">,</span>
			<span class="nx">info</span><span class="p">,</span>
		<span class="p">),</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">newSectorInfo</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">SectorOnChainInfo</span><span class="p">{</span>
		<span class="nx">State</span><span class="p">:</span>            <span class="nx">PreCommit</span><span class="p">,</span>
		<span class="nx">Info</span><span class="p">:</span>             <span class="nx">info</span><span class="p">,</span>
		<span class="nx">PreCommitDeposit</span><span class="p">:</span> <span class="nx">depositReq</span><span class="p">,</span>
		<span class="nx">PreCommitEpoch</span><span class="p">:</span>   <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">(),</span>
		<span class="nx">ActivationEpoch</span><span class="p">:</span>  <span class="nx">epochUndefined</span><span class="p">,</span>
		<span class="nx">DealWeight</span><span class="p">:</span>       <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">info</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span> <span class="p">=</span> <span class="o">*</span><span class="nx">newSectorInfo</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Request deferred Cron check for PreCommit expiry check.
</span><span class="c1"></span>	<span class="nx">expiryBound</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">+</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">MAX_PROVE_COMMIT_SECTOR_EPOCH</span> <span class="o">+</span> <span class="mi">1</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtEnrollCronEvent</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">expiryBound</span><span class="p">,</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">{</span><span class="nx">info</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">})</span>

	<span class="k">if</span> <span class="nx">info</span><span class="p">.</span><span class="nx">Expiration</span> <span class="o">&lt;=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;PreCommit sector must have positive lifetime&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtEnrollCronEvent</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">info</span><span class="p">.</span><span class="nx">Expiration</span><span class="p">,</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">{</span><span class="nx">info</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">})</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">ProveCommitSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">info</span> <span class="nx">SectorProveCommitInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">workerAddr</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Worker</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">workerAddr</span><span class="p">)</span>

	<span class="nx">preCommitSector</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">info</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="o">||</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">State</span> <span class="o">!=</span> <span class="nx">PreCommit</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Sector not valid or not in PreCommit state&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">PreCommitEpoch</span><span class="o">+</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">MAX_PROVE_COMMIT_SECTOR_EPOCH</span> <span class="o">||</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">PreCommitEpoch</span><span class="o">+</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">MIN_PROVE_COMMIT_SECTOR_EPOCH</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Invalid ProveCommitSector epoch&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">TODO</span><span class="p">()</span>
	<span class="c1">// TODO: How are SealEpoch, InteractiveEpoch determined (and intended to be used)?
</span><span class="c1"></span>	<span class="c1">// Presumably they cannot be derived from the SectorProveCommitInfo provided by an untrusted party.
</span><span class="c1"></span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtVerifySealOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo</span><span class="p">{</span>
		<span class="nx">SealedCID</span><span class="p">:</span>        <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">SealedCID</span><span class="p">,</span>
		<span class="nx">SealEpoch</span><span class="p">:</span>        <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">SealEpoch</span><span class="p">,</span>
		<span class="nx">InteractiveEpoch</span><span class="p">:</span> <span class="nx">info</span><span class="p">.</span><span class="nx">InteractiveEpoch</span><span class="p">,</span>
		<span class="nx">RegisteredProof</span><span class="p">:</span>  <span class="nx">info</span><span class="p">.</span><span class="nx">RegisteredProof</span><span class="p">,</span>
		<span class="nx">Proof</span><span class="p">:</span>            <span class="nx">info</span><span class="p">.</span><span class="nx">Proof</span><span class="p">,</span>
		<span class="nx">DealIDs</span><span class="p">:</span>          <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">,</span>
		<span class="nx">SectorNumber</span><span class="p">:</span>     <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">,</span>
	<span class="p">})</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Check (and activate) storage deals associated to sector. Abort if checks failed.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMarketActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMarketActor_OnMinerSectorProveCommit_VerifyDealsOrAbort</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
			<span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">,</span>
			<span class="nx">info</span><span class="p">,</span>
		<span class="p">),</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">)</span>

	<span class="nx">res</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">SendQuery</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMarketActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMarketActor_GetWeightForDealSet</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
			<span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">,</span>
		<span class="p">),</span>
	<span class="p">)</span>
	<span class="kd">var</span> <span class="nx">dealWeight</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">serde</span><span class="p">.</span><span class="nf">Deserialize</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">dealWeight</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">info</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span> <span class="p">=</span> <span class="nx">SectorOnChainInfo</span><span class="p">{</span>
		<span class="nx">State</span><span class="p">:</span>           <span class="nx">Active</span><span class="p">,</span>
		<span class="nx">Info</span><span class="p">:</span>            <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">Info</span><span class="p">,</span>
		<span class="nx">PreCommitEpoch</span><span class="p">:</span>  <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">PreCommitEpoch</span><span class="p">,</span>
		<span class="nx">ActivationEpoch</span><span class="p">:</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">(),</span>
		<span class="nx">DealWeight</span><span class="p">:</span>      <span class="o">*</span><span class="nx">dealWeight</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">[</span><span class="nx">info</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Request deferred Cron check for sector expiry.
</span><span class="c1"></span>	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtEnrollCronEvent</span><span class="p">(</span>
		<span class="nx">rt</span><span class="p">,</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Expiration</span><span class="p">,</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">{</span><span class="nx">info</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">})</span>

	<span class="c1">// Notify SPA to update power associated to newly activated sector.
</span><span class="c1"></span>	<span class="nx">storageWeightDesc</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_rtGetStorageWeightDescForSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">info</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_OnSectorProveCommit</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
			<span class="nx">storageWeightDesc</span><span class="p">,</span>
		<span class="p">),</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">)</span>

	<span class="c1">// Return PreCommit deposit to worker upon successful ProveCommit.
</span><span class="c1"></span>	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">workerAddr</span><span class="p">,</span> <span class="nx">preCommitSector</span><span class="p">.</span><span class="nx">PreCommitDeposit</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">/////////////////////////
</span><span class="c1">// Sector Modification //
</span><span class="c1">/////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">ExtendSectorExpiration</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumber</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">,</span> <span class="nx">newExpiration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">storageWeightDescPrev</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_rtGetStorageWeightDescForSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Worker</span><span class="p">)</span>

	<span class="nx">sectorInfo</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">sectorNumber</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Sector not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">extensionLength</span> <span class="o">:=</span> <span class="nx">newExpiration</span> <span class="o">-</span> <span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Expiration</span>
	<span class="k">if</span> <span class="nx">extensionLength</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Cannot reduce sector expiration&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Expiration</span> <span class="p">=</span> <span class="nx">newExpiration</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">sectorNumber</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sectorInfo</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">storageWeightDescNew</span> <span class="o">:=</span> <span class="nx">storageWeightDescPrev</span>
	<span class="nx">storageWeightDescNew</span><span class="p">.</span><span class="nx">Duration</span> <span class="p">=</span> <span class="nx">storageWeightDescPrev</span><span class="p">.</span><span class="nx">Duration</span> <span class="o">+</span> <span class="nx">extensionLength</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_OnSectorModifyWeightDesc</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
			<span class="nx">storageWeightDescPrev</span><span class="p">,</span>
			<span class="nx">storageWeightDescNew</span><span class="p">,</span>
		<span class="p">),</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">TerminateSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumber</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Worker</span><span class="p">)</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtTerminateSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">,</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">UserTermination</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////
</span><span class="c1">// Faults //
</span><span class="c1">////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">DeclareTemporaryFaults</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumbers</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">,</span> <span class="nx">duration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">duration</span> <span class="o">&lt;=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">ChainEpoch</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Temporary fault duration must be positive&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">storageWeightDescs</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_rtGetStorageWeightDescsForSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNumbers</span><span class="p">)</span>
	<span class="nx">cidx</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrIndices</span><span class="p">()</span>
	<span class="nx">requiredFee</span> <span class="o">:=</span> <span class="nx">cidx</span><span class="p">.</span><span class="nf">StorageMining_TemporaryFaultFee</span><span class="p">(</span><span class="nx">storageWeightDescs</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span>

	<span class="nf">RT_ConfirmFundsReceiptOrAbort_RefundRemainder</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">requiredFee</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">requiredFee</span><span class="p">)</span>

	<span class="nx">effectiveBeginEpoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">+</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">StorageMining_DeclaredFaultEffectiveDelay</span><span class="p">()</span>
	<span class="nx">effectiveEndEpoch</span> <span class="o">:=</span> <span class="nx">effectiveBeginEpoch</span> <span class="o">+</span> <span class="nx">duration</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Worker</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNumber</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sectorNumbers</span> <span class="p">{</span>
		<span class="nx">sectorInfo</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">sectorNumber</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="o">||</span> <span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">State</span> <span class="o">!=</span> <span class="nx">Active</span> <span class="p">{</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="nx">TemporaryFault</span>
		<span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">DeclaredFaultEpoch</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>
		<span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">DeclaredFaultDuration</span> <span class="p">=</span> <span class="nx">duration</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">sectorNumber</span><span class="p">]</span> <span class="p">=</span> <span class="nx">sectorInfo</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Request deferred Cron invocation to update temporary fault state.
</span><span class="c1"></span>	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtEnrollCronEvent</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">effectiveBeginEpoch</span><span class="p">,</span> <span class="nx">sectorNumbers</span><span class="p">)</span>
	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtEnrollCronEvent</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">effectiveEndEpoch</span><span class="p">,</span> <span class="nx">sectorNumbers</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">//////////
</span><span class="c1">// Cron //
</span><span class="c1">//////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">OnDeferredCronEvent</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumbers</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNumber</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sectorNumbers</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">.</span><span class="nf">_rtCheckTemporaryFaultEvents</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>
		<span class="nx">a</span><span class="p">.</span><span class="nf">_rtCheckSectorExpiry</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtCheckSurprisePoStExpiry</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">/////////////////
</span><span class="c1">// Constructor //
</span><span class="c1">/////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">ownerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">workerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">peerId</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">)</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>

	<span class="nx">initPostState</span> <span class="o">:=</span> <span class="nx">MinerPoStState</span><span class="p">{</span>
		<span class="nx">LastSuccessfulPoSt</span><span class="p">:</span>     <span class="nx">epochUndefined</span><span class="p">,</span>
		<span class="nx">SurpriseChallengeEpoch</span><span class="p">:</span> <span class="nx">epochUndefined</span><span class="p">,</span>
		<span class="nx">ChallengedSectors</span><span class="p">:</span>      <span class="kc">nil</span><span class="p">,</span>
		<span class="nx">NumConsecutiveFailures</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">st</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">StorageMinerActorState</span><span class="p">{</span>
		<span class="nx">Sectors</span><span class="p">:</span>    <span class="nf">SectorsAMT_Empty</span><span class="p">(),</span>
		<span class="nx">PoStState</span><span class="p">:</span>  <span class="nx">initPostState</span><span class="p">,</span>
		<span class="nx">ProvingSet</span><span class="p">:</span> <span class="nf">SectorNumberSetHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">Info</span><span class="p">:</span>       <span class="nf">MinerInfo_New</span><span class="p">(</span><span class="nx">ownerAddr</span><span class="p">,</span> <span class="nx">workerAddr</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">peerId</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="o">*</span><span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Method utility functions
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtCheckTemporaryFaultEvents</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumber</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">checkSector</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">sectorNumber</span><span class="p">]</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">storageWeightDesc</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_rtGetStorageWeightDescForSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">checkSector</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">Active</span> <span class="o">&amp;&amp;</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">==</span> <span class="nx">checkSector</span><span class="p">.</span><span class="nf">EffectiveFaultBeginEpoch</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">checkSector</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="nx">TemporaryFault</span>

		<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_OnSectorTemporaryFaultEffectiveBegin</span><span class="p">,</span>
			<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
				<span class="nx">storageWeightDesc</span><span class="p">,</span>
			<span class="p">),</span>
			<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">)</span>

		<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">checkSector</span><span class="p">.</span><span class="nf">Is_TemporaryFault</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">==</span> <span class="nx">checkSector</span><span class="p">.</span><span class="nf">EffectiveFaultEndEpoch</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">checkSector</span><span class="p">.</span><span class="nx">State</span> <span class="p">=</span> <span class="nx">Active</span>
		<span class="nx">checkSector</span><span class="p">.</span><span class="nx">DeclaredFaultEpoch</span> <span class="p">=</span> <span class="nx">epochUndefined</span>
		<span class="nx">checkSector</span><span class="p">.</span><span class="nx">DeclaredFaultDuration</span> <span class="p">=</span> <span class="nx">epochUndefined</span>

		<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_OnSectorTemporaryFaultEffectiveEnd</span><span class="p">,</span>
			<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
				<span class="nx">storageWeightDesc</span><span class="p">,</span>
			<span class="p">),</span>
			<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">)</span>

		<span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">[</span><span class="nx">sectorNumber</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">sectorNumber</span><span class="p">]</span> <span class="p">=</span> <span class="nx">checkSector</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtCheckSectorExpiry</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumber</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">checkSector</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">sectorNumber</span><span class="p">]</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">checkSector</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">PreCommit</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span><span class="o">-</span><span class="nx">checkSector</span><span class="p">.</span><span class="nx">PreCommitEpoch</span> <span class="p">&gt;</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">MAX_PROVE_COMMIT_SECTOR_EPOCH</span> <span class="p">{</span>
			<span class="nx">a</span><span class="p">.</span><span class="nf">_rtDeleteSectorEntry</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>
			<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">checkSector</span><span class="p">.</span><span class="nx">PreCommitDeposit</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// Note: the following test may be false, if sector expiration has been extended by the worker
</span><span class="c1"></span>	<span class="c1">// in the interim after the Cron request was enrolled.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="nx">checkSector</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">Expiration</span> <span class="p">{</span>
		<span class="nx">a</span><span class="p">.</span><span class="nf">_rtTerminateSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">,</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">NormalExpiration</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtTerminateSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumber</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">,</span> <span class="nx">terminationType</span> <span class="nx">SectorTerminationType</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">checkSector</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">[</span><span class="nx">sectorNumber</span><span class="p">]</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">found</span><span class="p">)</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">storageWeightDesc</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">_rtGetStorageWeightDescForSector</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">checkSector</span><span class="p">.</span><span class="nx">State</span> <span class="o">==</span> <span class="nx">TemporaryFault</span> <span class="p">{</span>
		<span class="c1">// To avoid boundary-case errors in power accounting, make sure we explicitly end
</span><span class="c1"></span>		<span class="c1">// the temporary fault state first, before terminating the sector.
</span><span class="c1"></span>		<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
			<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_OnSectorTemporaryFaultEffectiveEnd</span><span class="p">,</span>
			<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
				<span class="nx">storageWeightDesc</span><span class="p">,</span>
			<span class="p">),</span>
			<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_OnSectorTerminate</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
			<span class="nx">storageWeightDesc</span><span class="p">,</span>
			<span class="nx">terminationType</span><span class="p">,</span>
		<span class="p">),</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">)</span>

	<span class="nx">a</span><span class="p">.</span><span class="nf">_rtDeleteSectorEntry</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">ProvingSet</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtCheckSurprisePoStExpiry</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nf">Is_Challenged</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Already exited challenged state successfully prior to expiry.
</span><span class="c1"></span>		<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">provingPeriod</span> <span class="o">:=</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">StorageMining_SurprisePoStProvingPeriod</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">SurpriseChallengeEpoch</span><span class="o">+</span><span class="nx">provingPeriod</span> <span class="p">{</span>
		<span class="c1">// Challenge not yet expired.
</span><span class="c1"></span>		<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">numConsecutiveFailures</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">NumConsecutiveFailures</span> <span class="o">+</span> <span class="mi">1</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">numConsecutiveFailures</span> <span class="p">&gt;</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">StoragePower_SurprisePoStMaxConsecutiveFailures</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Terminate all sectors, notify power and market actors to terminate
</span><span class="c1"></span>		<span class="c1">// associated storage deals, and reset miner&#39;s PoSt state to OK.
</span><span class="c1"></span>		<span class="nx">terminatedSectors</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">{}</span>
		<span class="k">for</span> <span class="nx">sectorNumber</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span> <span class="p">{</span>
			<span class="nx">terminatedSectors</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">terminatedSectors</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">a</span><span class="p">.</span><span class="nf">_rtNotifyMarketForTerminatedSectors</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">terminatedSectors</span><span class="p">)</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="c1">// Increment count of consecutive failures, and continue.
</span><span class="c1"></span>		<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="p">=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

		<span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span> <span class="p">=</span> <span class="nx">MinerPoStState</span><span class="p">{</span>
			<span class="nx">LastSuccessfulPoSt</span><span class="p">:</span>     <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">LastSuccessfulPoSt</span><span class="p">,</span>
			<span class="nx">SurpriseChallengeEpoch</span><span class="p">:</span> <span class="nx">epochUndefined</span><span class="p">,</span>
			<span class="nx">ChallengedSectors</span><span class="p">:</span>      <span class="kc">nil</span><span class="p">,</span>
			<span class="nx">NumConsecutiveFailures</span><span class="p">:</span> <span class="nx">numConsecutiveFailures</span><span class="p">,</span>
		<span class="p">}</span>
		<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_OnMinerSurprisePoStFailure</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
			<span class="nx">numConsecutiveFailures</span><span class="p">,</span>
		<span class="p">),</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtEnrollCronEvent</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">eventEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">sectorNumbers</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StoragePowerActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StoragePowerActor_OnMinerEnrollCronEvent</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
			<span class="nx">eventEpoch</span><span class="p">,</span>
			<span class="nx">sectorNumbers</span><span class="p">,</span>
		<span class="p">),</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtDeleteSectorEntry</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumber</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">Sectors</span><span class="p">,</span> <span class="nx">sectorNumber</span><span class="p">)</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtUpdatePoStState</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">state</span> <span class="nx">MinerPoStState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span> <span class="p">=</span> <span class="nx">state</span>
	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtGetStorageWeightDescForSector</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumber</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="nx">autil</span><span class="p">.</span><span class="nx">SectorStorageWeightDesc</span> <span class="p">{</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getStorageWeightDescForSector</span><span class="p">(</span><span class="nx">sectorNumber</span><span class="p">)</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtGetStorageWeightDescsForSectors</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumbers</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">[]</span><span class="nx">autil</span><span class="p">.</span><span class="nx">SectorStorageWeightDesc</span> <span class="p">{</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getStorageWeightDescsForSectors</span><span class="p">(</span><span class="nx">sectorNumbers</span><span class="p">)</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtNotifyMarketForTerminatedSectors</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">sectorNumbers</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">dealIDItems</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">sectorNo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">sectorNumbers</span> <span class="p">{</span>
		<span class="nx">dealIDItems</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">dealIDItems</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getSectorDealIDsAssert</span><span class="p">(</span><span class="nx">sectorNo</span><span class="p">).</span><span class="nx">Items</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">dealIDs</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">{</span><span class="nx">Items</span><span class="p">:</span> <span class="nx">dealIDItems</span><span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">Send</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMarketActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMarketActor_OnMinerSectorsTerminate</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
			<span class="nx">dealIDs</span><span class="p">,</span>
		<span class="p">),</span>
		<span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtVerifySurprisePoStOrAbort</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">onChainInfo</span> <span class="o">*</span><span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainSurprisePoStVerifyInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nf">Is_Challenged</span><span class="p">())</span>
	<span class="nx">sectorSize</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Info</span><span class="p">.</span><span class="nx">SectorSize</span>
	<span class="nx">challengeEpoch</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">SurpriseChallengeEpoch</span>
	<span class="nx">challengedSectors</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">PoStState</span><span class="p">.</span><span class="nx">ChallengedSectors</span>

	<span class="c1">// verify no duplicate tickets
</span><span class="c1"></span>	<span class="nx">challengeIndices</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int64</span><span class="p">]</span><span class="kt">bool</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">tix</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">Candidates</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">challengeIndices</span><span class="p">[</span><span class="nx">tix</span><span class="p">.</span><span class="nx">ChallengeIndex</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
			<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Invalid Surprise PoSt. Duplicate ticket included.&#34;</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">challengeIndices</span><span class="p">[</span><span class="nx">tix</span><span class="p">.</span><span class="nx">ChallengeIndex</span><span class="p">]</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="p">}</span>

	<span class="nf">TODO</span><span class="p">(</span><span class="nx">challengedSectors</span><span class="p">)</span>
	<span class="c1">// TODO: Determine what should be the acceptance criterion for sector numbers
</span><span class="c1"></span>	<span class="c1">// proven in SurprisePoSt proofs.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Previous note:
</span><span class="c1"></span>	<span class="c1">// Verify the partialTicket values
</span><span class="c1"></span>	<span class="c1">// if !a._rtVerifySurprisePoStMeetsTargetReq(rt) {
</span><span class="c1"></span>	<span class="c1">// 	rt.AbortStateMsg(&#34;Invalid Surprise PoSt. Tickets do not meet target.&#34;)
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>
	<span class="nx">randomnessK</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">GetRandomness</span><span class="p">(</span><span class="nx">challengeEpoch</span> <span class="o">-</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_POST</span><span class="p">)</span>
	<span class="c1">// regenerate randomness used. The PoSt Verification below will fail if
</span><span class="c1"></span>	<span class="c1">// the same was not used to generate the proof
</span><span class="c1"></span>	<span class="nx">postRandomness</span> <span class="o">:=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nf">DeriveRandWithMinerAddr</span><span class="p">(</span><span class="nx">crypto</span><span class="p">.</span><span class="nx">DomainSeparationTag_SurprisePoStChallengeSeed</span><span class="p">,</span> <span class="nx">randomnessK</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrReceiver</span><span class="p">())</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="c1">// Get public inputs
</span><span class="c1"></span>
	<span class="nx">pvInfo</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">{</span>
		<span class="nx">Candidates</span><span class="p">:</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">Candidates</span><span class="p">,</span>
		<span class="nx">Proofs</span><span class="p">:</span>     <span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">Proofs</span><span class="p">,</span>
		<span class="nx">Randomness</span><span class="p">:</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">PoStRandomness</span><span class="p">(</span><span class="nx">postRandomness</span><span class="p">),</span>
		<span class="c1">// EligibleSectors_: FIXME: verification needs these.
</span><span class="c1"></span>	<span class="p">}</span>

	<span class="c1">// Verify the PoSt Proof
</span><span class="c1"></span>	<span class="nx">isVerified</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">Syscalls</span><span class="p">().</span><span class="nf">VerifyPoSt</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">pvInfo</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">isVerified</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Surprise PoSt failed to verify&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMinerActor</span><span class="p">)</span> <span class="nf">_rtVerifySealOrAbort</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">onChainInfo</span> <span class="o">*</span><span class="nx">abi</span><span class="p">.</span><span class="nx">OnChainSealVerifyInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">info</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Info</span>
	<span class="nx">sectorSize</span> <span class="o">:=</span> <span class="nx">info</span><span class="p">.</span><span class="nx">SectorSize</span>
	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">pieceInfos</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfos</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">serde</span><span class="p">.</span><span class="nf">Deserialize</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">SendQuery</span><span class="p">(</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMarketActorAddr</span><span class="p">,</span>
		<span class="nx">builtin</span><span class="p">.</span><span class="nx">Method_StorageMarketActor_GetPieceInfosForDealIDs</span><span class="p">,</span>
		<span class="nx">serde</span><span class="p">.</span><span class="nf">MustSerializeParams</span><span class="p">(</span>
			<span class="nx">sectorSize</span><span class="p">,</span>
			<span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">,</span>
		<span class="p">),</span>
	<span class="p">),</span> <span class="o">&amp;</span><span class="nx">pieceInfos</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="c1">// Unless we enforce a minimum padding amount, this totalPieceSize calculation can be removed.
</span><span class="c1"></span>	<span class="c1">// Leaving for now until that decision is entirely finalized.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">totalPieceSize</span> <span class="kt">int64</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">pieceInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pieceInfos</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">pieceSize</span> <span class="o">:=</span> <span class="nx">pieceInfo</span><span class="p">.</span><span class="nx">Size</span>
		<span class="nx">totalPieceSize</span> <span class="o">+=</span> <span class="nx">pieceSize</span>
	<span class="p">}</span>

	<span class="nx">unsealedCID</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">Syscalls</span><span class="p">().</span><span class="nf">ComputeUnsealedSectorCID</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">pieceInfos</span><span class="p">.</span><span class="nx">Items</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;invalid sector piece infos&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">minerActorID</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">addr</span><span class="p">.</span><span class="nf">IDFromAddress</span><span class="p">(</span><span class="nx">rt</span><span class="p">.</span><span class="nf">CurrReceiver</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;receiver must be ID address&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">IMPL_TODO</span><span class="p">()</span> <span class="c1">// Use randomness APIs
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">svInfoRandomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Randomness</span>
	<span class="kd">var</span> <span class="nx">svInfoInteractiveRandomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Randomness</span>

	<span class="nx">svInfo</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">{</span>
		<span class="nx">SectorID</span><span class="p">:</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">{</span>
			<span class="nx">Miner</span><span class="p">:</span>  <span class="nx">abi</span><span class="p">.</span><span class="nf">ActorID</span><span class="p">(</span><span class="nx">minerActorID</span><span class="p">),</span>
			<span class="nx">Number</span><span class="p">:</span> <span class="nx">onChainInfo</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="nx">OnChain</span><span class="p">:</span>               <span class="o">*</span><span class="nx">onChainInfo</span><span class="p">,</span>
		<span class="nx">Randomness</span><span class="p">:</span>            <span class="nx">abi</span><span class="p">.</span><span class="nf">SealRandomness</span><span class="p">(</span><span class="nx">svInfoRandomness</span><span class="p">),</span>
		<span class="nx">InteractiveRandomness</span><span class="p">:</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">InteractiveSealRandomness</span><span class="p">(</span><span class="nx">svInfoInteractiveRandomness</span><span class="p">),</span>
		<span class="nx">UnsealedCID</span><span class="p">:</span>           <span class="nx">unsealedCID</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="nx">isVerified</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">Syscalls</span><span class="p">().</span><span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">svInfo</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">isVerified</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Sector seal failed to verify&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getSectorNums</span><span class="p">(</span><span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span><span class="nx">SectorOnChainInfo</span><span class="p">)</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">l</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">m</span> <span class="p">{</span>
		<span class="nx">l</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">l</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_surprisePoStSampleChallengedSectors</span><span class="p">(</span>
	<span class="nx">sampleRandomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Randomness</span><span class="p">,</span> <span class="nx">provingSet</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">)</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span> <span class="p">{</span>

	<span class="nf">IMPL_TODO</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining__sector">

<h3 class="section-header">
  Sector
</h3>

<div class="section-content">




































<div id="systems__filecoin_mining__sector__sector"></div>
<p>The <code>Sector</code> is a fundamental &ldquo;storage container&rdquo; abstraction used in Filecoin Storage Mining. It is the basic unit of storage,
and serves to make storage conform to a set of expectations.</p>
<p>New sectors are empty upon creation. As the miner receives client data, they fill or &ldquo;pack&rdquo; the piece(s) into an unsealed sector.</p>
<p>Once a sector is full, the unsealed sector is combined by a proving tree into a single root <code>UnsealedSectorCID</code>. The sealing process then encodes (using CBOR) an unsealed sector into a sealed sector, with the root <code>SealedSectorCID</code>.</p>
<p>This diagram shows the composition of an unsealed sector and a sealed sector.</p>












<div class="diagram">

<span class="diagram-title">Unsealed Sectors and Sealed Sectors</span>




(<a href="docs/systems/filecoin_mining/sector/diagrams/sectors.png" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_mining/sector/diagrams/sectors.png" />




</div>




















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">smarkact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_market&#34;</span>

<span class="kd">type</span> <span class="nx">Bytes32</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">Commitment</span> <span class="nx">Bytes32</span>  <span class="c1">// TODO
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">FaultSet</span> <span class="nx">CompactSectorSet</span>
<span class="kd">type</span> <span class="nx">StorageFaultType</span> <span class="kt">int</span>

<span class="c1">// SectorInDetail describes all the bits of information associated
</span><span class="c1">// with each sector.
</span><span class="c1">// - ID   - a unique identifier assigned once the Sector is registered on chain
</span><span class="c1">// - Size - the size of the sector. there are a set of allowable sizes
</span><span class="c1">//
</span><span class="c1">// NOTE: do not use this struct. It is for illustrative purposes only.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorInDetail</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>    <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">Size</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span>

    <span class="nx">Unsealed</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">CID</span>     <span class="nx">abi</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span>
        <span class="nx">Deals</span>   <span class="p">[</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">]</span>
        <span class="nx">Pieces</span>  <span class="p">[</span><span class="nx">piece</span><span class="p">.</span><span class="nx">Piece</span><span class="p">]</span>
        <span class="c1">// Pieces Tree&lt;Piece&gt; // some tree for proofs
</span><span class="c1"></span>        <span class="nx">Bytes</span>
    <span class="p">}</span>

    <span class="nx">Sealed</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">CID</span>              <span class="nx">abi</span><span class="p">.</span><span class="nx">SealedSectorCID</span>
        <span class="nx">Bytes</span>
        <span class="nx">RegisteredProof</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// SectorInfo is an object that gathers all the information miners know about their
</span><span class="c1">// sectors. This is meant to be used for a local index.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>                  <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">UnsealedInfo</span>        <span class="nx">UnsealedSectorInfo</span>
    <span class="nx">SealedInfo</span>          <span class="nx">SealedSectorInfo</span>
    <span class="nx">SealVerifyInfo</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">SealVerifyInfo</span>
    <span class="nx">PersistentProofAux</span>
<span class="p">}</span>

<span class="c1">// UnsealedSectorInfo is an object that tracks the relevant data to keep in a sector
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">UnsealedSectorInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">UnsealedCID</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span>  <span class="c1">// CommD
</span><span class="c1"></span>    <span class="nx">Size</span>         <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span>
    <span class="nx">PieceCount</span>   <span class="nx">UVarint</span>  <span class="c1">// number of pieces in this sector (can get it from len(Pieces) too)
</span><span class="c1"></span>    <span class="nx">Pieces</span>       <span class="p">[</span><span class="nx">piece</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">]</span>  <span class="c1">// wont get externalized easy, -- it&#39;s big
</span><span class="c1"></span>    <span class="c1">// Deals       [smarkact.StorageDeal]
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// SealedSectorInfo keeps around information about a sector that has been sealed.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealedSectorInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealedCID</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">SealedSectorCID</span>
    <span class="nx">Size</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span>
    <span class="nx">SealArgs</span>   <span class="nx">SealArguments</span>
<span class="p">}</span>
</code></pre></div>





<p>TODO:</p>
<ul>
<li>describe sizing ranges of sectors</li>
<li>describe &ldquo;storage/shipping container&rdquo; analogy</li>
</ul>


</div>


  
    








<div id="systems__filecoin_mining__sector__sectorset">

<h4 class="section-header">
  Sector Set
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>

<span class="c1">// sector sets
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorSet</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">]</span>
<span class="kd">type</span> <span class="nx">UnsealedSectorSet</span> <span class="nx">SectorSet</span>
<span class="kd">type</span> <span class="nx">SealedSectorSet</span> <span class="nx">SectorSet</span>

<span class="c1">// compact sector sets
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Bitfield</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">RLEpBitfield</span> <span class="nx">Bitfield</span>
<span class="kd">type</span> <span class="nx">CompactSectorSet</span> <span class="nx">RLEpBitfield</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__sector__posting">

<h4 class="section-header">
  Sector PoSting
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//import abi &#34;github.com/filecoin-project/specs-actors/actors/abi&#34;
</span><span class="c1"></span>
<span class="c1">// type PoStWitness struct {
</span><span class="c1">//     Candidates [abi.PoStCandidate]
</span><span class="c1">// }
</span></code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__sector__sealing">

<h4 class="section-header">
  Sector Sealing
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>

<span class="kd">type</span> <span class="nx">Path</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">// TODO
</span><span class="c1"></span>
<span class="c1">// SealSeed is unique to each Sector
</span><span class="c1">// SealSeed is:
</span><span class="c1">//    SealSeedHash(MinerID, SectorNumber, SealRandomness, abi.UnsealedSectorCID)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealSeed</span> <span class="nx">Bytes</span>

<span class="c1">// SealCommitment is the information kept in the state tree about a sector.
</span><span class="c1">// SealCommitment is a subset of OnChainSealVerifyInfo.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealCommitment</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealedCID</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">SealedSectorCID</span>  <span class="c1">// CommR
</span><span class="c1"></span>    <span class="nx">DealIDs</span>     <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span>
    <span class="nx">Expiration</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="c1">// PersistentProofAux is meta data required to generate certain proofs
</span><span class="c1">// for a sector, for example PoSt.
</span><span class="c1">// These should be stored and indexed somewhere by CommR.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PersistentProofAux</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">CommC</span>              <span class="nx">Commitment</span>
    <span class="nx">CommQ</span>              <span class="nx">Commitment</span>
    <span class="nx">CommRLast</span>          <span class="nx">Commitment</span>

    <span class="c1">// TODO: This may be a partially-cached tree.
</span><span class="c1"></span>    <span class="c1">// this may be empty
</span><span class="c1"></span>    <span class="nx">CommRLastTreePath</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProofAuxTmp</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">RegisteredProof</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span>  <span class="c1">// FIXME: Make sure this is supplied.
</span><span class="c1"></span>    <span class="nx">PersistentAux</span>    <span class="nx">PersistentProofAux</span>  <span class="c1">// TODO: Move this to sealer.SealOutputs.
</span><span class="c1"></span>
    <span class="nx">SectorID</span>         <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">CommD</span>            <span class="nx">Commitment</span>
    <span class="nx">CommR</span>            <span class="nx">abi</span><span class="p">.</span><span class="nx">SealedSectorCID</span>
    <span class="nx">CommDTreePath</span>    <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">CommCTreePath</span>    <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">CommQTreePath</span>    <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>

    <span class="nx">Seed</span>             <span class="nx">SealSeed</span>
    <span class="nx">KeyLayers</span>        <span class="p">[</span><span class="nx">Bytes</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealArguments</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">RegisteredProof</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span>
    <span class="nx">OutputArtifacts</span>  <span class="nx">SealOutputArtifacts</span>
<span class="p">}</span>

<span class="c1">// TODO: move into proofs lib
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">FilecoinSNARKProof</span> <span class="kd">struct</span> <span class="p">{}</span>  <span class="c1">//&lt;bls12-381, Groth16&gt;
</span><span class="c1"></span>
<span class="c1">// TODO
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealOutputArtifacts</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>





<h6 id="drawing-randomness-for-sector-commitments">Drawing randomness for sector commitments</h6>
<p><a href="./#systems__filecoin_blockchain__storage_power_consensus__ticket_chain">Tickets</a> are used as input to calculation of the ReplicaID in order to tie Proofs-of-Replication to a given chain, thereby preventing long-range attacks (from another miner in the future trying to reuse SEALs).</p>
<p>The ticket has to be drawn from a finalized block in order to prevent the miner from potential losing storage (in case of a chain reorg) even though their storage is intact.</p>
<p>Verification should ensure that the ticket was drawn no farther back than necessary by the miner. We note that tickets can uniquely be associated to a given round in the protocol (lest a hash collision be found), but that the round number is explicited by the miner in <code>commitSector</code>.</p>
<p>We present precisely how ticket selection and verification should work. In the below, we use the following notation:</p>
<ul>
<li><code>F</code>&ndash; Finality (number of rounds)</li>
<li><code>X</code>&ndash; round in which SEALing starts</li>
<li><code>Z</code>&ndash; round in which the SEAL appears (in a block)</li>
<li><code>Y</code>&ndash; round announced in the SEAL <code>commitSector</code> (should be X, but a miner could use any Y &lt;= X), denoted by the ticket selection</li>
<li><code>T</code>&ndash; estimated time for SEAL, dependent on sector size</li>
<li><code>G = T + variance</code>&ndash; necessary flexibility to account for network delay and SEAL-time variance.</li>
</ul>
<p>We expect Filecoin will be able to produce estimates for sector commitment time based on sector sizes, e.g.:
<code>(estimate, variance) &lt;--- SEALTime(sectors)</code>
G and T will be selected using these.</p>
<h6 id="picking-a-ticket-to-seal">Picking a Ticket to Seal</h6>
<p>When starting to prepare a SEAL in round X, the miner should draw a ticket from X-F with which to compute the SEAL.</p>
<h6 id="verifying-a-seals-ticket">Verifying a Seal&rsquo;s ticket</h6>
<p>When verifying a SEAL in round Z, a verifier should ensure that the ticket used to generate the SEAL is found in the range of rounds [Z-T-F-G, Z-T-F+G].</p>
<h6 id="in-detail">In Detail</h6>
<pre><code>                               Prover
           ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ
          ‚îÇ

          ‚ñº
         X-F ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄF‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ X ‚óÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄT‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ Z
     -G   .  +G                 .                        .
  ‚îÄ‚îÄ‚îÄ(‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê)‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ( )‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ( )‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 '                        '        time
 [Z-T-F-G, Z-T-F+G]
          ‚ñ≤

          ‚îî ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ ‚îÄ
                              Verifier
</code></pre><p>Note that the prover here is submitting a message on chain (i.e. the SEAL). Using an older ticket than necessary to generate the SEAL is something the miner may do to gain more confidence about finality (since we are in a probabilistically final system). However it has a cost in terms of securing the chain in the face of long-range attacks (specifically, by mixing in chain randomness here, we ensure that an attacker going back a month in time to try and create their own chain would have to completely regenerate any and all sectors drawing randomness since to use for their fork&rsquo;s power).</p>
<p>We break this down as follows:</p>
<ul>
<li>The miner should draw from <code>X-F</code>.</li>
<li>The verifier wants to find what <code>X-F</code> should have been (to ensure the miner is not drawing from farther back) even though Y (i.e. the round of the ticket actually used) is an unverifiable value.</li>
<li>Thus, the verifier will need to make an inference about what <code>X-F</code> is likely to have been based on:
<ul>
<li>(known) round in which the message is received (Z)</li>
<li>(known) finality value (F)</li>
<li>(approximate) SEAL time (T)</li>
</ul>
</li>
<li>Because T is an approximate value, and to account for network delay and variance in SEAL time across miners, the verifier allows for G offset from the assumed value of <code>X-F</code>: <code>Z-T-F</code>, hence verifying that the ticket is drawn from the range <code>[Z-T-F-G, Z-T-F+G]</code>.</li>
</ul>
<h6 id="in-practice">In Practice</h6>
<p>The Filecoin protocol will include a <code>MAX_SEAL_TIME</code> for each sector size and proof type.</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining__sector_index">

<h3 class="section-header">
  Sector Index
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">smarkact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_market&#34;</span>

<span class="c1">// TODO import this from StorageMarket
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorIndex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">BySectorID</span>     <span class="p">{</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">ByUnsealedCID</span>  <span class="p">{</span><span class="nx">abi</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">BySealedCID</span>    <span class="p">{</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SealedSectorCID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">ByPieceID</span>      <span class="p">{</span><span class="nx">piece</span><span class="p">.</span><span class="nx">PieceID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
    <span class="nx">ByDealID</span>       <span class="p">{</span><span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">:</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SectorInfo</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorIndexerSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Index</span>    <span class="nx">SectorIndex</span>
    <span class="nx">Store</span>    <span class="nx">SectorStore</span>
    <span class="nx">Builder</span>  <span class="nx">SectorBuilder</span>

    <span class="c1">// AddNewDeal is called by StorageMiningSubsystem after the StorageMarket
</span><span class="c1"></span>    <span class="c1">// has made a deal. AddNewDeal returns an error when:
</span><span class="c1"></span>    <span class="c1">// - there is no capacity to store more deals and their pieces
</span><span class="c1"></span>    <span class="nf">AddNewDeal</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="nx">StageDealResponse</span>

    <span class="c1">// bring back if needed.
</span><span class="c1"></span>    <span class="c1">// OnNewTipset(chain Chain, epoch abi.Epoch) struct {}
</span><span class="c1"></span>
    <span class="c1">// SectorsExpiredAtEpoch returns the set of sectors that expire
</span><span class="c1"></span>    <span class="c1">// at a particular epoch.
</span><span class="c1"></span>    <span class="nf">SectorsExpiredAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">]</span>

    <span class="c1">// removeSectors removes the given sectorIDs from storage.
</span><span class="c1"></span>    <span class="nf">removeSectors</span><span class="p">(</span><span class="nx">sectorIDs</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">])</span>
<span class="p">}</span>
</code></pre></div>







</div>


  

  

  
    








<div id="systems__filecoin_mining__sector_index__sector_builder">

<h4 class="section-header">
  Sector Builder
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">smarkact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_market&#34;</span>

<span class="c1">// SectorBuilder accumulates deals, keeping track of their
</span><span class="c1">// sector configuration requirements and the piece sizes.
</span><span class="c1">// Once there is a sector ready to be sealed, NextSector
</span><span class="c1">// will return a sector.
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">StageDealResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorBuilder</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// DealsToSeal keeps a set of StorageDeal objects.
</span><span class="c1"></span>    <span class="c1">// These include the info for the relevant pieces.
</span><span class="c1"></span>    <span class="c1">// This builder just accumulates deals, keeping track of their
</span><span class="c1"></span>    <span class="c1">// sector configuration requirements, and the piece sizes.
</span><span class="c1"></span>    <span class="nx">DealsToSeal</span> <span class="p">[</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">]</span>

    <span class="c1">// StageDeal adds a deal to be packed into a sector.
</span><span class="c1"></span>    <span class="nf">StageDeal</span><span class="p">(</span><span class="nx">d</span> <span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="nx">StageDealResponse</span>

    <span class="c1">// NextSector returns an UnsealedSectorInfo, which includes the (ordered) set of
</span><span class="c1"></span>    <span class="c1">// pieces, and the SealCfg. An error may be returned if SectorBuilder is not
</span><span class="c1"></span>    <span class="c1">// ready to produce a Sector.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// TODO: use go channels? or notifications?
</span><span class="c1"></span>    <span class="nf">NextSector</span><span class="p">()</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">i</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">UnsealedSectorInfo</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__sector_index__sector_store">

<h4 class="section-header">
  SectorStore
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">piece</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/piece&#34;</span>
<span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>

<span class="kd">type</span> <span class="nx">SectorStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// FileStore stores all the unsealed and sealed sectors.
</span><span class="c1"></span>    <span class="nx">FileStore</span>   <span class="nx">file</span><span class="p">.</span><span class="nx">FileStore</span>

    <span class="c1">// PieceStore is shared with DataTransfer, and is a way to store or read
</span><span class="c1"></span>    <span class="c1">// pieces temporarily. This may or may not be backed by the FileStore above.
</span><span class="c1"></span>    <span class="nx">PieceStore</span>  <span class="nx">piece</span><span class="p">.</span><span class="nx">PieceStore</span>

    <span class="c1">// GetSectorFile returns the file for a given sector id.
</span><span class="c1"></span>    <span class="c1">// If the SectorID does not have any sector files associated yet, GetSectorFiles
</span><span class="c1"></span>    <span class="c1">// returns an error.
</span><span class="c1"></span>    <span class="nf">GetSectorFiles</span><span class="p">(</span><span class="nx">id</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">SectorFiles</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Get information, including a merkle tree file/path, needed to generate PoSt for a sector.
</span><span class="c1"></span>    <span class="nf">GetSectorPersistentProofAux</span><span class="p">(</span><span class="nx">id</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PersistentProofAux</span>

    <span class="nf">StoreSectorPersistentProofAux</span><span class="p">(</span><span class="nx">id</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">proofAux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PersistentProofAux</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">proofAux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PersistentProofAux</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// CreateSectorFiles allocates two sector files, one for unsealed and one for
</span><span class="c1"></span>    <span class="c1">// sealed sector.
</span><span class="c1"></span>    <span class="nf">CreateSectorFiles</span><span class="p">(</span><span class="nx">id</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">f</span> <span class="nx">SectorFiles</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// SectorFiles is a datastructure that groups two file objects and a sectorID.
</span><span class="c1">// These files are where unsealed and sealed sectors should go.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SectorFiles</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">Unsealed</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">File</span>
    <span class="nx">Sealed</span>    <span class="nx">file</span><span class="p">.</span><span class="nx">File</span>
<span class="p">}</span>
</code></pre></div>





<p>TODO</p>
<ul>
<li>talk about how sectors are stored</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_mining__storage_proving">

<h3 class="section-header">
  Storage Proving
</h3>

<div class="section-content">




































<p>Filecoin Proving Subsystem</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">poster</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/poster&#34;</span>
<span class="kn">import</span> <span class="nx">sealer</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/storage_proving/sealer&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>

<span class="kd">type</span> <span class="nx">StorageProvingSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorSealer</span>   <span class="nx">sealer</span><span class="p">.</span><span class="nx">SectorSealer</span>
    <span class="nx">PoStGenerator</span>  <span class="nx">poster</span><span class="p">.</span><span class="nx">PoStGenerator</span>

    <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">,</span> <span class="nx">pieceInfos</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">])</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">ok</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">ComputeUnsealedSectorCID</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">pieceInfos</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">])</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">unsealedSectorCID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span>

    <span class="c1">// TODO: remove this?
</span><span class="c1"></span>    <span class="c1">// GetPieceInclusionProof(pieceRef CID) union { PieceInclusionProofs, error }
</span><span class="c1"></span>
    <span class="nf">GenerateElectionPoStCandidates</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">sectorIDs</span>      <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">]</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>

    <span class="nf">GenerateSurprisePoStCandidates</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">sectorIDs</span>      <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">]</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>

    <span class="nf">CreateElectionPoStProof</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">candidates</span>     <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span><span class="p">]</span>

    <span class="nf">CreateSurprisePoStProof</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">candidates</span>     <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_mining__storage_proving__sealer">

<h4 class="section-header">
  Sector Sealer
</h4>

<div class="section-content">




































<p>Sector Sealer</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>

<span class="kd">type</span> <span class="nx">SealInputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorSize</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span>
    <span class="nx">RegisteredProof</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span>  <span class="c1">// FIXME: Ensure this is provided.
</span><span class="c1"></span>    <span class="nx">SectorID</span>         <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">MinerID</span>          <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">RandomSeed</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">SealRandomness</span>  <span class="c1">// This should be derived from SEAL_EPOCH = CURRENT_EPOCH - FINALITY.
</span><span class="c1"></span>    <span class="nx">UnsealedPath</span>     <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">SealedPath</span>       <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">DealIDs</span>          <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CreateSealProofInputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorID</span>               <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span>
    <span class="nx">RegisteredProof</span>        <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span>
    <span class="nx">InteractiveRandomSeed</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span>
    <span class="nx">SealedPaths</span>            <span class="p">[</span><span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">]</span>
    <span class="nx">SealOutputs</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealOutputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ProofAuxTmp</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">CreateSealProofOutputs</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealInfo</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">SealVerifyInfo</span>
    <span class="nx">ProofAux</span>  <span class="nx">sector</span><span class="p">.</span><span class="nx">PersistentProofAux</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SectorSealer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">SealSector</span><span class="p">()</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">so</span> <span class="nx">SealOutputs</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
    <span class="nf">CreateSealProof</span><span class="p">(</span><span class="nx">si</span> <span class="nx">CreateSealProofInputs</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">so</span> <span class="nx">CreateSealProofOutputs</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="nf">MaxUnsealedBytesPerSector</span><span class="p">(</span><span class="nx">SectorSize</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">UInt</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_mining__storage_proving__poster">

<h4 class="section-header">
  Sector Poster
</h4>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">sector_index</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector_index&#34;</span>

<span class="kd">type</span> <span class="nx">UInt64</span> <span class="nx">UInt</span>

<span class="c1">// TODO: move this to somewhere the blockchain can import
</span><span class="c1">// candidates:
</span><span class="c1">// - filproofs - may have to learn about Sectors (and if we move Seal stuff, Deals)
</span><span class="c1">// - &#34;blockchain/builtins&#34; or something like that - a component in the blockchain that handles storage verification
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PoStSubmission</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PostProof</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span>
    <span class="nx">ChainEpoch</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PoStGenerator</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorStore</span> <span class="nx">sector_index</span><span class="p">.</span><span class="nx">SectorStore</span>

    <span class="nf">GeneratePoStCandidates</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">candidateCount</span>  <span class="nx">UInt</span>
        <span class="nx">sectors</span>         <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">]</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>

    <span class="nf">CreateElectionPoStProof</span><span class="p">(</span>
        <span class="nx">randomness</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">witness</span>     <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span><span class="p">]</span>

    <span class="nf">CreateSurprisePoStProof</span><span class="p">(</span>
        <span class="nx">randomness</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">witness</span>     <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span><span class="p">]</span>

    <span class="c1">// FIXME: Verification shouldn&#39;t require a PoStGenerator. Move this.
</span><span class="c1"></span>    <span class="nf">VerifyPoStProof</span><span class="p">(</span>
        <span class="nx">Proof</span>          <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span>
        <span class="nx">challengeSeed</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
    <span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">poster</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">filproofs</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/filcrypto/filproofs&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Serialization</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Serialization</span>

<span class="c1">// See &#34;Proof-of-Spacetime Parameters&#34; Section
</span><span class="c1">// TODO: Unify with orient model.
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">POST_CHALLENGE_DEADLINE</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="mi">480</span><span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pg</span> <span class="o">*</span><span class="nx">PoStGenerator_I</span><span class="p">)</span> <span class="nf">GeneratePoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">candidateCount</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sectors</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span> <span class="p">{</span>
	<span class="c1">// Question: Should we pass metadata into FilProofs so it can interact with SectorStore directly?
</span><span class="c1"></span>	<span class="c1">// Like this:
</span><span class="c1"></span>	<span class="c1">// PoStReponse := SectorStorageSubsystem.GeneratePoSt(sectorSize, challenge, faults, sectorsMetatada);
</span><span class="c1"></span>
	<span class="c1">// Question: Or should we resolve + manifest trees here and pass them in?
</span><span class="c1"></span>	<span class="c1">// Like this:
</span><span class="c1"></span>	<span class="c1">// trees := sectorsMetadata.map(func(md) { SectorStorage.GetMerkleTree(md.MerkleTreePath) });
</span><span class="c1"></span>	<span class="c1">// Done this way, we redundantly pass the tree paths in the metadata. At first thought, the other way
</span><span class="c1"></span>	<span class="c1">// seems cleaner.
</span><span class="c1"></span>	<span class="c1">// PoStReponse := SectorStorageSubsystem.GeneratePoSt(sectorSize, challenge, faults, sectorsMetadata, trees);
</span><span class="c1"></span>
	<span class="c1">// For now, dodge this by passing the whole SectorStore. Once we decide how we want to represent this, we can narrow the call.
</span><span class="c1"></span>
	<span class="k">return</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nf">GenerateElectionPoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">sectors</span><span class="p">,</span> <span class="nx">candidateCount</span><span class="p">,</span> <span class="nx">pg</span><span class="p">.</span><span class="nf">SectorStore</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pg</span> <span class="o">*</span><span class="nx">PoStGenerator_I</span><span class="p">)</span> <span class="nf">CreateElectionPoStProof</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">postCandidates</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">)</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">privateProofs</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">candidate</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">postCandidates</span> <span class="p">{</span>
		<span class="nx">privateProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">privateProofs</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">.</span><span class="nx">PrivateProof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nf">CreateElectionPoStProof</span><span class="p">(</span><span class="nx">privateProofs</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pg</span> <span class="o">*</span><span class="nx">PoStGenerator_I</span><span class="p">)</span> <span class="nf">CreateSurprisePoStProof</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">postCandidates</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">)</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">privateProofs</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">candidate</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">postCandidates</span> <span class="p">{</span>
		<span class="nx">privateProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">privateProofs</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">.</span><span class="nx">PrivateProof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">filproofs</span><span class="p">.</span><span class="nf">CreateSurprisePoStProof</span><span class="p">(</span><span class="nx">privateProofs</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>





<h5 id="post-generator-object">PoSt Generator object</h5>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="systems__filecoin_markets">

<h2 class="section-header">
  Markets in Filecoin
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets">
        

        <strong>Market</strong>

        
            <br /><br /><i class="menuIcon">‚öñÔ∏è</i>
        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market">
        
            <i class="statusIcon">‚úÖ</i>
        

        Storage Market

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__storage_deal">
        
            <i class="statusIcon">üîÅ</i>
        

        Storage Deal

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__storage_market_actor">
        

        Storage Market Actor

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__storage_provider">
        

        Storage Provider

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__storage_market__storage_client">
        

        Storage Client

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market">
        
            <i class="statusIcon">‚úÖ</i>
        

        Retrieval Market

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market__retrieval_peer_resolver">
        

        Retrieval Peer Resolver

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market__retrieval_protocols">
        

        Retrieval Protocols

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market__retrieval_client">
        

        Retrieval Client

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#systems__filecoin_markets__retrieval_market__retrieval_provider">
        

        Retrieval Provider (Miner)

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>

<p>The Filecoin project is a protocol, a platform, and a marketplace. There are two major components to Filecoin markets, storage market and retrieval market. While both markets are expected to happen primarily off the blockchain, storage deals made in storage market will be published on chain and enforced by the protocol. Storage deal negotiation and order matching are expected to happen off chain in the first version of Filecoin. Retrieval deals are also negotiated off chain and executed with micropayments between transacting parties in payment channels.</p>
<p>Even though most of the market actions happen off the blockchain, there are on-chain invariants that create economic structure for network success and allow for positive emergent behavior. You can read more about the
relationship between on chain deals and storage power in <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a>.</p>


</div>


  
    








<div id="systems__filecoin_markets__storage_market">

<h3 class="section-header">
  Storage Market in Filecoin
</h3>

<div class="section-content">




































<p><div id="systems__filecoin_markets__storage_market__storage_market"></div>
Storage Market subsystem is the data entry point into the network. Storage miners only earn power from data stored in a storage deal and all deals live on the Filecoin network. Specific deal negotiation process happens off chain, clients and miners enter a storage deal after an agreement has been reached and post storage deals on the Filecoin network to earn block rewards and get paid for storing the data in the storage deal. A deal is only valid when it is posted on chain with signatures from both parties and at the time of posting, there are sufficient balances for both parties locked up to honor the deal in terms of deal price and deal collateral.</p>
<h4 id="terminology">Terminology</h4>
<ul>
<li><strong>StorageClient</strong> - The party that wants to make a deal to store data</li>
<li><strong>StorageProvider</strong> - The party that will store the data in exchange for payment. A storage miner.</li>
<li><strong>StorageMarketActor</strong> - The on-chain component of deals. The StorageMarketActor is analogous to an escrow and a ledger for all deals made.</li>
<li><strong>StorageAsk</strong> - The current price and parameters a miner is currently offering for storage (analogous to an Ask in a financial market)</li>
<li><strong>StorageDealProposal</strong> - A proposal for a storage deal, signed only by the - <code>Storage client</code></li>
<li><strong>StorageDeal</strong> - A storage deal proposal with a counter signature from the Provider, which then goes on-chain.</li>
</ul>
<h4 id="deal-flow">Deal Flow</h4>
<p>The lifecycle for a deal within the storage market contains distinct phases:</p>
<ol>
<li><strong>Discovery</strong> - Client identifies miners and determines their current asks</li>
<li><strong>Negotiation</strong> (out of band) - Both parties come to an agreement about the terms of the deal, each party commits funds to the deal, data is transferred</li>
<li><strong>Publishing</strong> - Deal is published on chain, making the storage provider publicly accountable for the deal</li>
<li><strong>Handoff</strong> - Once the deal is published, it is handled off the Storage Mining Subsystem. The Storage Mining Subsystem will add the deal to a sector,
seal the sector, and tell the Storage Market Actor that the deal is in a sector, thereby making the deal active.</li>
</ol>
<p>The remaining parts of the deal lifecycle are handled by the Storage Mining Subsystem, which communicates with the Storage Market Actor in order to process deal payments. See <a href="./#systems__filecoin_mining__storage_mining">Storage Miner</a> for more details.</p>
<p>The following diagram outlines the phases of deal flow within the storage market in detail:</p>












<div class="diagram">

<span class="diagram-title">Storage Market Deal Flow</span>




(<a href="docs/systems/filecoin_markets/storage_market/storage_market_flow.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_markets/storage_market/storage_market_flow.mmd.svg" />




</div>

<h4 id="discovery">Discovery</h4>
<p>Discovery is the process where a client identifies storage providers (i.e. a miner) who might be able to store their data. There are many ways a client might identify a provider to store their data. This outlines the minimum discovery services a filecoin implementation MUST provide. As the network evolves, third parties may build systems that supplement or enhance these services.</p>
<p>Discovery involves identifying providers and determining their current <code>StorageAsk</code>. The steps are as follows:</p>
<ol>
<li>A client queries the chain to gain a list of Storage Miner Actors who have registerd as miners with the StoragePowerActor</li>
<li>A client may perform additional queries to each Storage Miner Actor to determine their properties &ndash; worker address, sector size, libp2p Multiaddress etc</li>
<li>Once the client identifies potentially suitable providers, it sends a direct libp2p message using the <code>Storage Query Protocol</code> to get each potential provider&rsquo;s current <code>StorageAsk</code>.</li>
<li>Miners respond on the <code>AskProtocol</code> with a signed version of their current <code>StorageAsk</code></li>
</ol>
<p>A <code>StorageAsk</code> contains all the properties that a client will need to determine if a given provider will meet its needs for storage at this moment. Providers should update their asks frequently to insure the information they are providing to clients is up to date.</p>
<h4 id="negotiation">Negotiation</h4>
<p>Negotiation is the out of band process where a storage client and a storage provider come to an agreement about a storage deal and reach the point where a deal is published on chain.</p>
<p>Negotiation begins once a client has discovered a miner whose <code>StorageAsk</code> meets their desired criteria.The <em>recommended</em> order of operations for negotiating and publishing a deal is as follows:</p>
<ol>
<li>Before sending a proposal to the provider, the <code>StorageClient</code> adds funds for a deal, as necessary, to the <code>StorageMarketActor</code> (by calling <code>AddBalance</code>)</li>
<li>In order to propose a storage deal, the <code>StorageClient</code> then calculates the piece commitment (<code>CommP</code>) for the data it intends to store ahead of time. This is neccesary so that the <code>StorageProvider</code> can verify the data the <code>StorageClient</code> sends to be stored matches the <code>CommP</code> in the <code>StorageDealProposal</code>. For more detail about the relationship between payloads, pieces, and <code>CommP</code> see <a href="./#systems__filecoin_files__piece___index"></a> and <a href="./#libraries__filcrypto__filproofs___index"></a></li>
<li>The <code>StorageClient</code> now creates a <code>StorageDealProposal</code> and sends the proposal and the CID for the root of the data payload to be stored to the <code>StorageProvider</code> using the <code>Storage Deal Protocol</code></li>
</ol>
<p>Execution now moves to the <code>StorageProvider</code></p>
<ol start="4">
<li>The <code>StorageProvider</code> inspects the deal to verify that its parameters match it own internal criteria (such as price, piece size, deal duration, etc) &ndash; and rejects the proposal if it doesn&rsquo;t (it sends a rejection to the client over the
<code>Storage Deal Protocol</code>)</li>
<li>The <code>StorageProvider</code> queries the <code>StorageMarketActor</code> to verify the <code>StorageClient</code> has deposited enough funds to make the deal (i.e. balance &gt; total storage price) and rejects the proposal if it hasn&rsquo;t.</li>
<li>If all criteria are met, the <code>StorageProvider</code> responds using the <code>Storage Deal Protocol</code> indicate an intent to accept the deal.</li>
</ol>
<p>Execution now moves back to the <code>StorageClient</code></p>
<ol start="7">
<li>The <code>StorageClient</code> opens a push request for the payload data using the <code>Data Transfer Module</code>, and sends the request to the provider along with a voucher containing the CID for the <code>StorageDealProposal</code></li>
<li>The <code>StorageProvider</code> checks the voucher and verifies the CID matches a storage deal proposal it has received and verified but not put on chain already. If so, it accepts the data transfer request from the <code>StorageClient</code>.</li>
<li>The <code>Data Transfer Module</code> now transfers for the payload data to be stored from the  <code>StorageClient</code> to the <code>StorageProvider</code> using <code>GraphSync</code>.</li>
<li>Once complete, the <code>Data Transfer Module</code> notifies the <code>StorageProvider</code></li>
<li>The <code>StorageProvider</code> recalculates the piece commitment (<code>CommP</code>) from the data that was transferred and verifies it matches the piece commitment in the the <code>StorageDealProposal</code></li>
</ol>
<h4 id="publishing">Publishing</h4>
<p>Data is now transferred, both parties have agreed, and it&rsquo;s time to publish the deal. Given that the counter signature on a deal proposal is a standard message signature by the provider and the signed deal is an on-chain message, it is usually the <code>StorageProvider</code> that publishes the deal. However, if <code>StorageProvider</code> decides to send this signed on-chain message to the client before calling <code>PublishStorageDeal</code> then client can publish the deal on chain. Client&rsquo;s funds are not locked until the deal is published and a published deal that is not activated within some window will result in on-chain penalty.</p>
<ol start="12">
<li>First, the <code>StorageProvider</code> adds collateral for the deal as needed to the <code>StorageMarketActor</code> (using <code>AddBalance</code>)</li>
<li>Now, the <code>StorageProvider</code> prepares and signs the on-chain <code>StorageDeal</code> message with the <code>StorageDealProposal</code> signed by the client and its own signature. It can now either send this message back to the client or call <code>PublishStorageDeals</code> on the <code>StorageMarketActor</code> to publish the deal. It is recommended for <code>StorageProvider</code> to send back the signed message before <code>PublishStorageDeals</code> is called.</li>
<li>After calling <code>PublishStorageDeals</code>, <code>StorageProvider</code> sends a message to the <code>StorageClient</code> on the <code>Storage Deal Protocol</code> with the CID of the message that it is putting on chain for convenience.</li>
<li>If all goes well, the <code>StorageMarketActor</code> responds with an on chain <code>DealID</code> for the published deal.</li>
</ol>
<p>Finally, the client verifies the deal.</p>
<ol start="16">
<li>The <code>StorageClient</code> queries the node for the CID of the message published on chain (sent by the provider). It then inspects message parameters to make sure they match the expected deal</li>
</ol>
<h4 id="handoff">Handoff</h4>
<p>Now that a deal is published, it needs to be stored, sealed, and proven in order for the provider to be paid. (see <a href="./#systems__filecoin_markets__storage_market__storage_deal___index"></a> for more information about how deal payments are made) These later stages of a deal are handled by the <a href="./#systems__filecoin_mining__storage_mining">Storage Miner</a>. So the final task for the Storage Market is to handoff to the Storage Mining Subsystem</p>
<ol start="17">
<li>The <code>StorageProvider</code> writes the serialized, padded piece to a shared <a href="./#systems__filecoin_files__file__filestore">FileStore - Local Storage for Files</a>.</li>
<li>The <code>StorageProvider</code> calls <code>HandleStorageDeal</code> on the <code>StorageMiner</code> with the published <code>StorageDeal</code> and filestore path.</li>
</ol>
<p>A note order of operations: the only requirement to publish a storage deal with the <code>StorageMarketActor</code> is that the <code>StorageDealProposal</code> is signed by the <code>StorageClient</code>, the publish message is signed by the <code>StorageProvider</code>, and both parties have deposited adequate funds/collateral in the <code>StorageMarketActor</code>. As such, it&rsquo;s not required that the steps listed above happen in exactly the order listed above. However, the above order is <em>recommended</em> because it generally minimizes the ability of either party to act maliciously.</p>
<h4 id="data-types">Data Types</h4>
<p>The following data types unique to the Storage Market:</p>
<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">message</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="kn">import</span> <span class="nx">smarkact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_market&#34;</span>

<span class="kd">type</span> <span class="nx">StorageDealStatus</span> <span class="kt">uint64</span>

<span class="c1">// StorageAsk is the current price and parameters a miner is currently offering for storage
</span><span class="c1">// (analogous to an Ask in a financial market)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StorageAsk</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Price</span>             <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>  <span class="c1">// attoFIL per GiB per epoch
</span><span class="c1"></span>    <span class="nx">Collateral</span>        <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>  <span class="c1">// attoFIL per GiB per epoch
</span><span class="c1"></span>
    <span class="nx">MinPieceSize</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span>
    <span class="c1">// address of miner actor for deals
</span><span class="c1"></span>    <span class="nx">Miner</span>             <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="c1">// the epoch at the time this ask was published
</span><span class="c1"></span>    <span class="nx">PublicationEpoch</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">MaxDuration</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="nx">MinDuration</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
    <span class="c1">// a miner should update sequence number each time it publishes an ask
</span><span class="c1"></span>    <span class="c1">// so that anyone with two asks from the same miner can determine which is
</span><span class="c1"></span>    <span class="c1">// more current
</span><span class="c1"></span>    <span class="nx">SeqNo</span>             <span class="nx">UVarint</span>
<span class="p">}</span>

<span class="c1">// A SignedStorageAsk is an ask signed by the miner that is making the offer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SignedStorageAsk</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Ask</span>        <span class="nx">StorageAsk</span>
    <span class="nx">Signature</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">Signature</span>
<span class="p">}</span>

<span class="c1">// AskProtocolRequest is a request sent over the storage ask protocol to a miner 
</span><span class="c1">// to determine their current ask
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AskProtocolRequest</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Miner</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
<span class="p">}</span>

<span class="c1">// AskProtocolResponse is the response a miner sends over the ask protocol with
</span><span class="c1">// a signed version of their most recent storage ask
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">AskProtocolResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Ask</span> <span class="nx">SignedStorageAsk</span>
<span class="p">}</span>

<span class="c1">// DealProtocolRequest is a request sent by a storage client to 
</span><span class="c1">// a storage provider on the storage deal protocol to propose a storage deal
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DealProtocolRequest</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The deal being proposed
</span><span class="c1"></span>    <span class="nx">DealProposal</span>  <span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDealProposal</span>
    <span class="c1">// root of the data to be transferred
</span><span class="c1"></span>    <span class="nx">Payload</span>       <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
<span class="p">}</span>

<span class="c1">// DealProtocolResponse is a response sent by a storage miner 
</span><span class="c1">// on the storage deal protocol with the current status of a storage
</span><span class="c1">// deal proposal
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DealProtocolResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The CID of the storage deal proposal 
</span><span class="c1"></span>    <span class="nx">Proposal</span>        <span class="o">&amp;</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDealProposal</span>

    <span class="c1">// Status of deal
</span><span class="c1"></span>    <span class="nx">State</span>           <span class="nx">StorageDealStatus</span>
    <span class="c1">// any additional information about status
</span><span class="c1"></span>    <span class="nx">Message</span>         <span class="kt">string</span>

    <span class="c1">// CID of message published on chain, once it is published
</span><span class="c1"></span>    <span class="nx">PublishMessage</span>  <span class="o">&amp;</span><span class="nx">message</span><span class="p">.</span><span class="nx">SignedMessage</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageDataTransferVoucher</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Proposal</span> <span class="o">&amp;</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDealProposal</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_market</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">StorageDealProposalNotFound</span> <span class="nx">StorageDealStatus</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">StorageDealProposalRejected</span>
	<span class="nx">StorageDealProposalAccepted</span>
	<span class="nx">StorageDealProposalSigned</span>
	<span class="nx">StorageDealPublished</span>
	<span class="nx">StorageDealCommitted</span>
	<span class="nx">StorageDealActive</span>
	<span class="nx">StorageDealFailing</span>
	<span class="nx">StorageDealRecovering</span>
	<span class="nx">StorageDealExpired</span>
	<span class="nx">StorageDealNotFound</span>
<span class="p">)</span>
</code></pre></div>




</p>
<p>Details about <code>StorageDealProposal</code> and <code>StorageDeal</code> (which are used in the Storage Market and elsewhere) specifically can be found in <a href="./#systems__filecoin_markets__storage_market__storage_deal___index"></a>.</p>
<h4 id="protocols">Protocols</h4>
<ul>
<li><strong>Name</strong>: Storage Query Protocol</li>
<li><strong>Protocol ID</strong>: <code>/fil/&lt;network-name&gt;/storage/ask/1.0.1</code></li>
</ul>
<p>Request: CBOR Encoded AskProtocolRequest Data Structure
Response: CBOR Encoded AskProtocolResponse Data Structure</p>
<ul>
<li><strong>Name</strong>: Storage Deal Protocol</li>
<li><strong>Protocol ID</strong>: <code>/fil/&lt;network-name&gt;/storage/mk/1.0.1</code></li>
</ul>
<p>Request: CBOR Encoded DealProtocolRequest Data Structure
Response: CBOR Encoded DealProtocolResponse Data Structure</p>


</div>


  
    








<div id="systems__filecoin_markets__storage_market__storage_deal">

<h4 class="section-header">
  Storage Deals
</h4>

<div class="section-content">




































<p>There are two types of deals in Filecoin markets, storage deals and retrieval deals. Storage deals are recorded on the blockchain and enforced by the protocol. Retrieval deals are off chain and enabled by micropayment channel by transacting parties (see <a href="./#systems__filecoin_markets__retrieval_market___index">Retrieval Market</a> for more information).</p>
<p>The lifecycle of a Storage Deal touches several major subsystems, components, and protocols in Filecoin.</p>
<p>This section describes the storage deal data type and a technical outline for deal flow in terms of how all the components involved and the functions they call on each other. For more detail and prose explanations, see <a href="./#systems__filecoin_markets__storage_market___index">Storage Market</a> and <a href="./#systems__filecoin_mining__storage_mining">Storage Miner</a></p>
<h5 id="data-types">Data Types</h5>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_market</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">acrypto</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/crypto&#34;</span>
<span class="p">)</span>

<span class="c1">// Note: Deal Collateral is only released and returned to clients and miners
</span><span class="c1">// when the storage deal stops counting towards power. In the current iteration,
</span><span class="c1">// it will be released when the sector containing the storage deals expires,
</span><span class="c1">// even though some storage deals can expire earlier than the sector does.
</span><span class="c1">// Collaterals are denominated in PerEpoch to incur a cost for self dealing or
</span><span class="c1">// minimal deals that last for a long time.
</span><span class="c1">// Note: ClientCollateralPerEpoch may not be needed and removed pending future confirmation.
</span><span class="c1">// There will be a Minimum value for both client and provider deal collateral.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StorageDealProposal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">PieceCID</span>        <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceCID</span> <span class="c1">// CommP
</span><span class="c1"></span>	<span class="nx">PieceSize</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceSize</span>
	<span class="nx">Client</span>          <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">Provider</span>        <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
	<span class="nx">ClientSignature</span> <span class="nx">acrypto</span><span class="p">.</span><span class="nx">Signature</span>

	<span class="c1">// Nominal start epoch. Deal payment is linear between StartEpoch and EndEpoch,
</span><span class="c1"></span>	<span class="c1">// with total amount StoragePricePerEpoch * (EndEpoch - StartEpoch).
</span><span class="c1"></span>	<span class="c1">// Storage deal must appear in a sealed (proven) sector no later than StartEpoch,
</span><span class="c1"></span>	<span class="c1">// otherwise it is invalid.
</span><span class="c1"></span>	<span class="nx">StartEpoch</span>           <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nx">EndEpoch</span>             <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nx">StoragePricePerEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>

	<span class="nx">ProviderCollateral</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
	<span class="nx">ClientCollateral</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="nf">Duration</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">EndEpoch</span> <span class="o">-</span> <span class="nx">p</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="nf">TotalStorageFee</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">StoragePricePerEpoch</span><span class="p">)</span> <span class="o">*</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nf">Duration</span><span class="p">()))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="nf">ClientBalanceRequirement</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">ClientCollateral</span> <span class="o">+</span> <span class="nx">p</span><span class="p">.</span><span class="nf">TotalStorageFee</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="nf">ProviderBalanceRequirement</span><span class="p">()</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">ProviderCollateral</span>
<span class="p">}</span>

<span class="c1">// Everything in this struct will go on chain
</span><span class="c1">// Provider&#39;s signature is implicit in the message containing this structure.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StorageDeal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Proposal</span> <span class="nx">StorageDealProposal</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">OnChainDeal</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span>               <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span>
	<span class="nx">Deal</span>             <span class="nx">StorageDeal</span>
	<span class="nx">SectorStartEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="c1">// -1 if not yet included in proven sector
</span><span class="c1"></span>	<span class="nx">LastUpdatedEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="c1">// -1 if deal state never updated
</span><span class="c1"></span>	<span class="nx">SlashEpoch</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span> <span class="c1">// -1 if deal never slashed
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_markets__storage_market__storage_deal__storage_deal_flow">

<h5 class="section-header">
  Storage Deal Flow
</h5>

<div class="section-content">
















































<div class="diagram">

<span class="diagram-title">Deal Flow Sequence Diagram</span>




(<a href="docs/systems/filecoin_markets/storage_market/storage_deal/diagrams/deal-flow.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_markets/storage_market/storage_deal/diagrams/deal-flow.mmd.svg" />




</div>

<h6 id="add-storage-deal-and-power">Add Storage Deal and Power</h6>
<ul>
<li>
<ol>
<li><code>StorageClient</code> and <code>StorageProvider</code> call <code>StorageMarketActor.AddBalance</code> to deposit funds into Storage Market.</li>
</ol>
<ul>
<li><code>StorageClient</code> and <code>StorageProvider</code> can call <code>WithdrawBalance</code> before any deal is made.</li>
</ul>
</li>
<li>
<ol start="2">
<li><code>StorageClient</code> and <code>StorageProvider</code> negotiate a deal off chain. <code>StorageClient</code> sends a <code>StorageDealProposal</code> to a <code>StorageProvider</code>.</li>
</ol>
<ul>
<li><code>StorageProvider</code> verifies the <code>StorageDeal</code> by checking address and signature of <code>StorageClient</code>, checking the proposal&rsquo;s <code>StartEpoch</code> is after the current Epoch, checking <code>StorageClient</code> did not call withdraw in the last X Epoch (<code>WithdrawBalance</code> should take at least X Epoch), checking both <code>StorageProvider</code> and <code>StorageClient</code> have sufficient available balances in <code>StorageMarketActor</code>.</li>
</ul>
</li>
<li>
<ol start="3">
<li><code>StorageProvider</code> signs the <code>StorageDealProposal</code>  by constructing an on-chain message.</li>
</ol>
<ul>
<li><code>StorageProvider</code> calls <code>PublishStorageDeals</code> in <code>StorageMarketActor</code> to publish this on-chain message which will generate a <code>DealID</code> for each <code>StorageDeal</code> and store a mapping from <code>DealID</code> to <code>StorageDeal</code>. However, the deals are not active at this point.
<ul>
<li>As a backup, <code>StorageClient</code> may call <code>PublishStorageDeals</code> with the <code>StorageDeal</code>, to activate the deal if they can obtain the signed on-chain message from <code>StorageProvider</code>.</li>
<li>It is possible for either <code>StorageProvider</code> or <code>StorageClient</code> to try to enter into two deals simultaneously with funds available only for one. Only the first deal to commit to the chain will clear, the second will fail with error <code>errorcode.InsufficientFunds</code>.</li>
</ul>
</li>
<li><code>StorageProvider</code> calls <code>HandleStorageDeal</code> in <code>StorageMiningSubsystem</code> which will then add the <code>StorageDeal</code> into a <code>Sector</code>.</li>
</ul>
</li>
</ul>
<h6 id="sealing-sectors">Sealing sectors</h6>
<ul>
<li>
<ol start="4">
<li>Once the miner finishes packing a <code>Sector</code>, it generates a SectorPreCommitInfo and call PreCommitSector with a PreCommitDeposit. It must call ProveCommitSector with SectorProveCommitInfo within some bound to recover the deposit. Expired PreCommit message will result in PreCommitDeposit being burned. There are two types of sectors, Regular Sector and Committed Capacity Sector but all sectors have an explicit expiration epoch declared during PreCommit. For a Regular Sector with storage deals in it, all deals must expire before sector expiration. Miner gains power for this particular sector upon successful ProveCommit.</li>
</ol>
</li>
</ul>
<h6 id="receive-challenge">Receive Challenge</h6>
<ul>
<li>
<ol start="5">
<li>Miners enter the <code>Challenged</code> status when it receives a SurprisePoSt challenge from the chain. Miners will then have X Epoch as the ProvingPeriod to submit a successful PoSt before the chain checks for SurprisePoSt expiry. Miners can only get out the challenge with <code>SubmitSurprisePoStResponse</code>.</li>
</ol>
</li>
<li>
<ol start="6">
<li>Miners are allowed to DeclareTemporaryFault when they are in the <code>Challenged</code> state but this will not change the list of sectors challenged as <code>Challenged</code> state specifies a list of sectors to be challenged which is a snapshot of all Active sectors at the time of challenge. Miners are also allowed to call ProveCommit which will add to their ClaimedPower but their Nominal and Consensus Power are still zero whe  they are in either Challenged or DetectedFault state.</li>
</ol>
</li>
</ul>
<h6 id="declare-and-recover-faults">Declare and Recover Faults</h6>
<ul>
<li>
<ol start="7">
<li>Declared faults are penalized to a smaller degree than DetectedFault. Miners declare failing sectors by invoking <code>DeclareTemporaryFaults</code> with a specified fault duration and associated <code>TemporaryFaultFee</code>. Miner will lose power associated with the sector when the TemporaryFault period begins.</li>
</ol>
</li>
<li>
<ol start="8">
<li>The loss of power associated with TemporaryFault will be restored when the TemporaryFault period has ended and the miner is now expected to prove over that sector. Failure to do so will result in unsuccessful ElectionPoSt or unsuccessful SurprisePoSt that leads to detected faults.</li>
</ol>
</li>
</ul>
<h6 id="detect-faults">Detect Faults</h6>
<ul>
<li>
<ol start="9">
<li><code>CronActor</code> triggers <code>StorageMinerActor._rtCheckSurprisePoStExpiry</code> through <code>StoragePowerActor</code> and checks if SurprisePoSt challenge has expired for a particular miner.</li>
</ol>
<ul>
<li>If no PoSt is submitted by the end of the <code>ProvingPeriod</code>, miner enters <code>DetectedFault</code> state, some <code>PledgeCollateral</code> is slashed, and all power is lost.</li>
<li>Miners will now have to wait for the next SurprisePoSt challenge.</li>
<li>If the faults persist for <code>MAX_CONSECUTIVE_FAULTS</code> then sectors are terminated and provider deal collateral is slashed.</li>
</ul>
</li>
</ul>
<h6 id="sector-expiration">Sector Expiration</h6>
<ul>
<li>
<ol start="10">
<li>Sector expiration is done via a scheduled Cron event <code>_rtCheckSectorExpiry</code>. Sector expires when its Expiration epoch is reached and sector expiration epoch must be greater than all its deal expiration epoch.</li>
</ol>
</li>
</ul>
<h6 id="deal-payment-and-slashing">Deal Payment and slashing</h6>
<ul>
<li>
<ol start="11">
<li>Deal payment and slashing are evaluated lazily through <code>_updatePendingDealState</code> at WithdrawBalance and PublishStorageDeals events. The method is also called at <code>OnEpochTickEnd</code> on StorageMarketActor as a clean up mechanism.</li>
</ol>
</li>
</ul>


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__storage_deal__storage_deal_states">

<h5 class="section-header">
  Storage Deal States
</h5>

<div class="section-content">




































<p>All on-chain economic activities in Filecoin start with the deal. This section aims to explain different states of a deal and their relationship with other concepts in the protocol such as Power, Payment, and Collaterals.</p>
<p>A deal has the following states:</p>
<ul>
<li><code>Unpublished</code>: the deal has yet to be posted on chain.</li>
<li><code>Published</code>: the deal has been published and accepted by the chain but is not yet active as the sector containing the deal has not been proven.</li>
<li><code>Active</code>: the deal has been proven and not yet expired.</li>
<li><code>Deleted</code>: the deal has expired or the sector containing the deal has been terminated because of faults.</li>
</ul>
<p>Note that <code>Unpublished</code> and <code>Deleted</code> states not tracked on chain. To reduce on-chain footprint, an <code>OnChainDeal</code> struct is created when a deal is published and it keeps track of a <code>LastPaymentEpoch</code> which defaults to -1 when a deal is in the <code>Published</code> state. A deal transitions into the <code>Active</code> state when <code>LastPaymentEpoch</code> is positive.</p>
<p>The following describes how a deal transitions between its different states.</p>
<ul>
<li><code>Unpublished -&gt; Published</code>: this is triggered by <code>StorageMarketActor.PublishStorageDeals</code> which validates new storage deals, locks necessary funds, generates deal IDs, and registers the storage deals in <code>StorageMarketActor</code>.</li>
<li><code>Published -&gt; Deleted</code>: this is triggered by <code>StorageMinerActor.ProveCommitSector</code> during InteractivePoRep when the elapsed number of epochs between PreCommit and ProveCommit messages exceeds <code>MAX_PROVE_COMMIT_SECTOR_EPOCH</code>. ProveCommitSector will also trigger garbage collection on the list of published storage deals.</li>
<li><code>Published -&gt; Active</code>: this is triggered by <code>ActivateStorageDeals</code> after successful <code>StorageMinerActor.ProveCommitSector</code>. It is okay for the StorageDeal to have already started (i.e. for <code>StartEpoch</code> to have passed) at this point but it must not have expired.</li>
<li><code>Active -&gt; Deleted</code>: this can happen under the following conditions:
<ul>
<li>The deal itself has expired. This is triggered by <code>StorageMinerActorCode._submitPowerReport</code> which is called whenever a PoSt is submitted. Power associated with the deal will be lost, collaterals returned, and all remaining storage fees unlocked (allowing miners to call <code>WithdrawBalance</code> successfully).</li>
<li>The sector containing the deal has expired. This is triggered by <code>StorageMinerActorCode._submitPowerReport</code> which is called whenver a PoSt is submitted. Power associated with the deals in the sector will be lost, collaterals returned, and all remaining storage fees unlocked.</li>
<li>The sector containing the active deal has been terminated. This is triggered by <code>StorageMinerActor._submitFaultReport</code> for <code>TerminatedFaults</code>. No storage deal collateral will be slashed on fault declaration or detection, only on termination. A terminated fault is triggered when a sector is in the <code>Failing</code> state for <code>MAX_CONSECUTIVE_FAULTS</code> consecutive proving periods.</li>
</ul>
</li>
</ul>
<p>Given deal states and their transitions, the following are the relationships between deal states and other economic states and activities in the protocol.</p>
<ul>
<li><code>Power</code>: only payload data in an Active storage deal counts towards power.</li>
<li><code>Deal Payment</code>: happens on <code>_onSuccessfulPoSt</code> and at deal/sector expiration through <code>_submitPowerReport</code>, paying out <code>StoragePricePerEpoch</code> for each epoch since the last PoSt.</li>
<li><code>Deal Collateral</code>: no storage deal collateral will be slashed for <code>NewDeclaredFaults</code> and <code>NewDetectedFaults</code> but instead some pledge collateral will be slashed given these faults&rsquo; impact on consensus power. In the event of <code>NewTerminatedFaults</code>, all storage deal collateral and some pledge collateral will be slashed. Provider and client storage deal collaterals will be returned when a deal or a sector has expired. If a sector recovers from <code>Failing</code> within the <code>MAX_CONSECUTIVE_FAULTS</code> threshold, deals in that sector are still considered active. However, miners may need to top up pledge collateral when they try to <code>RecoverFaults</code> given the earlier slashing.</li>
</ul>












<div class="diagram">

<span class="diagram-title">Deal States Sequence Diagram</span>




(<a href="docs/systems/filecoin_markets/storage_market/storage_deal/diagrams/deal-payment.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_markets/storage_market/storage_deal/diagrams/deal-payment.mmd.svg" />




</div>



</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__storage_deal__faults">

<h5 class="section-header">
  Faults
</h5>

<div class="section-content">




































<p><div id="systems__filecoin_markets__storage_market__storage_deal__faults__storage_faults"></div>
There are two main categories of faults in the Filecoin network.</p>
<ul>
<li>ConsensusFaults</li>
<li>StorageDealFaults</li>
</ul>
<p>ConsensusFaults are faults that impact network consensus and StorageDealFaults are faults where data in a <code>StorageDeal</code> is not maintained by the providers pursuant to deal terms.</p>
<p><a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__pledge_collateral">Pledge Collateral</a> is slashed for ConsensusFaults and <a href="./#systems__filecoin_markets__storage_market__storage_deal_collateral">Storage Deal Collateral</a> for StorageDealFaults.</p>
<p>Any misbehavior may result in more than one fault thus lead to slashing on both collaterals. For example, missing a <code>PoStProof</code> will incur a penalty on both <code>PledgeCollateral</code> and <code>StorageDealCollateral</code> given it impacts both a given <code>StorageDeal</code> and power derived from the sector commitments in <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a>.</p>
<h6 id="storage-faults">Storage Faults</h6>
<p>TODO: complete this.</p>


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__storage_market_actor">

<h4 class="section-header">
  Storage Market Actor
</h4>

<div class="section-content">




































<p><code>StorageMarketActor</code> is responsible for processing and managing on-chain deals. This is also the entry point of all storage deals and data into the system. It maintains a mapping of <code>StorageDealID</code> to <code>StorageDeal</code> and keeps track of locked balances of <code>StorageClient</code> and <code>StorageProvider</code>. When a deal is posted on chain through the <code>StorageMarketActor</code>, it will first check if both transacting parties have sufficient balances locked up and include the deal on chain.</p>
<h5 id="storagemarketactorstate-implementation"><code>StorageMarketActorState</code> implementation</h5>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_market</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">indices</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime/indices&#34;</span>
	<span class="nx">actor_util</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">epochUndefined</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">ChainEpoch</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">// TODO AMT
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DealsAMT</span> <span class="kd">map</span><span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">]</span><span class="nx">OnChainDeal</span>

<span class="c1">// TODO AMT
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CachedDealIDsByPartyHAMT</span> <span class="kd">map</span><span class="p">[</span><span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">]</span><span class="nx">actor_util</span><span class="p">.</span><span class="nx">DealIDSetHAMT</span>

<span class="c1">// TODO AMT
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">CachedExpirationsPendingHAMT</span> <span class="kd">map</span><span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">]</span><span class="nx">DealIDQueue</span>

<span class="kd">type</span> <span class="nx">StorageMarketActorState</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Deals</span> <span class="nx">DealsAMT</span>

	<span class="c1">// Total amount held in escrow, indexed by actor address (including both locked and unlocked amounts).
</span><span class="c1"></span>	<span class="nx">EscrowTable</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">BalanceTableHAMT</span>

	<span class="c1">// Amount locked, indexed by actor address.
</span><span class="c1"></span>	<span class="c1">// Note: the amounts in this table do not affect the overall amount in escrow:
</span><span class="c1"></span>	<span class="c1">// only the _portion_ of the total escrow amount that is locked.
</span><span class="c1"></span>	<span class="nx">LockedReqTable</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">BalanceTableHAMT</span>

	<span class="nx">NextID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span>

	<span class="c1">// Metadata cached for efficient iteration over deals.
</span><span class="c1"></span>	<span class="nx">CachedDealIDsByParty</span>           <span class="nx">CachedDealIDsByPartyHAMT</span>
	<span class="nx">CachedExpirationsPending</span>       <span class="nx">CachedExpirationsPendingHAMT</span>
	<span class="nx">CachedExpirationsNextProcEpoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
	<span class="nx">CurrEpochNumDealsPublished</span>     <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">CID</span><span class="p">()</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Deal state operations
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_updatePendingDealStates</span><span class="p">(</span><span class="nx">dealIDs</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">amountSlashedTotal</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>

	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="nx">amountSlashedTotal</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span> <span class="p">{</span>
		<span class="nx">amountSlashedCurr</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_updatePendingDealState</span><span class="p">(</span><span class="nx">dealID</span><span class="p">,</span> <span class="nx">epoch</span><span class="p">)</span>
		<span class="nx">amountSlashedTotal</span> <span class="o">+=</span> <span class="nx">amountSlashedCurr</span>
	<span class="p">}</span>

	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_updatePendingDealState</span><span class="p">(</span><span class="nx">dealID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">amountSlashed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>

	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="nx">amountSlashed</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="nx">deal</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getOnChainDealAssert</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>

	<span class="nx">everUpdated</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">LastUpdatedEpoch</span> <span class="o">!=</span> <span class="nx">epochUndefined</span><span class="p">)</span>
	<span class="nx">everSlashed</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">SlashEpoch</span> <span class="o">!=</span> <span class="nx">epochUndefined</span><span class="p">)</span>

	<span class="nf">Assert</span><span class="p">(!</span><span class="nx">everUpdated</span> <span class="o">||</span> <span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">LastUpdatedEpoch</span> <span class="o">&lt;=</span> <span class="nx">epoch</span><span class="p">))</span>
	<span class="k">if</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">LastUpdatedEpoch</span> <span class="o">==</span> <span class="nx">epoch</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">SectorStartEpoch</span> <span class="o">==</span> <span class="nx">epochUndefined</span> <span class="p">{</span>
		<span class="c1">// Not yet appeared in proven sector; check for timeout.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span> <span class="o">&gt;=</span> <span class="nx">epoch</span> <span class="p">{</span>
			<span class="nx">st</span><span class="p">.</span><span class="nf">_processDealInitTimedOut</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nf">Assert</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span> <span class="o">&lt;=</span> <span class="nx">epoch</span><span class="p">)</span>

	<span class="nx">dealEnd</span> <span class="o">:=</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span>
	<span class="k">if</span> <span class="nx">everSlashed</span> <span class="p">{</span>
		<span class="nf">Assert</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">SlashEpoch</span> <span class="o">&lt;=</span> <span class="nx">dealEnd</span><span class="p">)</span>
		<span class="nx">dealEnd</span> <span class="p">=</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">SlashEpoch</span>
	<span class="p">}</span>

	<span class="nx">elapsedStart</span> <span class="o">:=</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span>
	<span class="k">if</span> <span class="nx">everUpdated</span> <span class="o">&amp;&amp;</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">LastUpdatedEpoch</span> <span class="p">&gt;</span> <span class="nx">elapsedStart</span> <span class="p">{</span>
		<span class="nx">elapsedStart</span> <span class="p">=</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">LastUpdatedEpoch</span>
	<span class="p">}</span>

	<span class="nx">elapsedEnd</span> <span class="o">:=</span> <span class="nx">dealEnd</span>
	<span class="k">if</span> <span class="nx">epoch</span> <span class="p">&lt;</span> <span class="nx">elapsedEnd</span> <span class="p">{</span>
		<span class="nx">elapsedEnd</span> <span class="p">=</span> <span class="nx">epoch</span>
	<span class="p">}</span>

	<span class="nx">numEpochsElapsed</span> <span class="o">:=</span> <span class="nx">elapsedEnd</span> <span class="o">-</span> <span class="nx">elapsedStart</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_processDealPaymentEpochsElapsed</span><span class="p">(</span><span class="nx">dealID</span><span class="p">,</span> <span class="nx">numEpochsElapsed</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">everSlashed</span> <span class="p">{</span>
		<span class="nx">amountSlashed</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_processDealSlashed</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">epoch</span> <span class="o">&gt;=</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span> <span class="p">{</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_processDealExpired</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">ocd</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span>
	<span class="nx">ocd</span><span class="p">.</span><span class="nx">LastUpdatedEpoch</span> <span class="p">=</span> <span class="nx">epoch</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ocd</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_deleteDeal</span><span class="p">(</span><span class="nx">dealID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getOnChainDealAssert</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">CachedDealIDsByParty</span><span class="p">[</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span><span class="p">],</span> <span class="nx">dealID</span><span class="p">)</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">CachedDealIDsByParty</span><span class="p">[</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Client</span><span class="p">],</span> <span class="nx">dealID</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Note: only processes deal payments, not deal expiration (even if the deal has expired).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_processDealPaymentEpochsElapsed</span><span class="p">(</span><span class="nx">dealID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">,</span> <span class="nx">numEpochsElapsed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">deal</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getOnChainDealAssert</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">SectorStartEpoch</span> <span class="o">!=</span> <span class="nx">epochUndefined</span><span class="p">)</span>

	<span class="c1">// Process deal payment for the elapsed epochs.
</span><span class="c1"></span>	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="nx">totalPayment</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">numEpochsElapsed</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">StoragePricePerEpoch</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_transferBalance</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nx">totalPayment</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_processDealSlashed</span><span class="p">(</span><span class="nx">dealID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="p">(</span><span class="nx">amountSlashed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">deal</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getOnChainDealAssert</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">SectorStartEpoch</span> <span class="o">!=</span> <span class="nx">epochUndefined</span><span class="p">)</span>

	<span class="nx">slashEpoch</span> <span class="o">:=</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">SlashEpoch</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">slashEpoch</span> <span class="o">!=</span> <span class="nx">epochUndefined</span><span class="p">)</span>

	<span class="c1">// unlock client collateral and locked storage fee
</span><span class="c1"></span>	<span class="nx">clientCollateral</span> <span class="o">:=</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ClientCollateral</span>
	<span class="nx">paymentRemaining</span> <span class="o">:=</span> <span class="nf">_dealGetPaymentRemaining</span><span class="p">(</span><span class="nx">deal</span><span class="p">,</span> <span class="nx">slashEpoch</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_unlockBalance</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">clientCollateral</span><span class="o">+</span><span class="nx">paymentRemaining</span><span class="p">)</span>

	<span class="c1">// slash provider collateral
</span><span class="c1"></span>	<span class="nx">amountSlashed</span> <span class="p">=</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ProviderCollateral</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_slashBalance</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span><span class="p">,</span> <span class="nx">amountSlashed</span><span class="p">)</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">_deleteDeal</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Deal start deadline elapsed without appearing in a proven sector.
</span><span class="c1">// Delete deal, slash a portion of provider&#39;s collateral, and unlock remaining collaterals
</span><span class="c1">// for both provider and client.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_processDealInitTimedOut</span><span class="p">(</span><span class="nx">dealID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="p">(</span><span class="nx">amountSlashed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">deal</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getOnChainDealAssert</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">SectorStartEpoch</span> <span class="o">==</span> <span class="nx">epochUndefined</span><span class="p">)</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">_unlockBalance</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nf">ClientBalanceRequirement</span><span class="p">())</span>

	<span class="nx">amountSlashed</span> <span class="p">=</span> <span class="nx">indices</span><span class="p">.</span><span class="nf">StorageDeal_ProviderInitTimedOutSlashAmount</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">Deal</span><span class="p">.</span><span class="nx">Proposal</span><span class="p">.</span><span class="nx">ProviderCollateral</span><span class="p">)</span>
	<span class="nx">amountRemaining</span> <span class="o">:=</span> <span class="nx">dealP</span><span class="p">.</span><span class="nf">ProviderBalanceRequirement</span><span class="p">()</span> <span class="o">-</span> <span class="nx">amountSlashed</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">_slashBalance</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span><span class="p">,</span> <span class="nx">amountSlashed</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_unlockBalance</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span><span class="p">,</span> <span class="nx">amountRemaining</span><span class="p">)</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">_deleteDeal</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="c1">// Normal expiration. Delete deal and unlock collaterals for both miner and client.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_processDealExpired</span><span class="p">(</span><span class="nx">dealID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">deal</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getOnChainDealAssert</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">deal</span><span class="p">.</span><span class="nx">SectorStartEpoch</span> <span class="o">!=</span> <span class="nx">epochUndefined</span><span class="p">)</span>

	<span class="c1">// Note: payment has already been completed at this point (_rtProcessDealPaymentEpochsElapsed)
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nf">_unlockBalance</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ProviderCollateral</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_unlockBalance</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ClientCollateral</span><span class="p">)</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">_deleteDeal</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_generateStorageDealID</span><span class="p">(</span><span class="nx">storageDeal</span> <span class="nx">StorageDeal</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span> <span class="p">{</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">NextID</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">NextID</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">NextID</span> <span class="o">+</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">DealID</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Balance table operations
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_addressEntryExists</span><span class="p">(</span><span class="nx">address</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">foundEscrow</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_GetEntry</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">address</span><span class="p">)</span>
	<span class="nx">_</span><span class="p">,</span> <span class="nx">foundLocked</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_GetEntry</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">LockedReqTable</span><span class="p">,</span> <span class="nx">address</span><span class="p">)</span>
	<span class="c1">// Check that the tables are consistent (i.e. the address is found in one
</span><span class="c1"></span>	<span class="c1">// if and only if it is found in the other).
</span><span class="c1"></span>	<span class="nf">Assert</span><span class="p">(</span><span class="nx">foundEscrow</span> <span class="o">==</span> <span class="nx">foundLocked</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">foundEscrow</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_getTotalEscrowBalanceInternal</span><span class="p">(</span><span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">_addressEntryExists</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
	<span class="nx">ret</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_GetEntry</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_getLockedReqBalanceInternal</span><span class="p">(</span><span class="nx">a</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">_addressEntryExists</span><span class="p">(</span><span class="nx">a</span><span class="p">))</span>
	<span class="nx">ret</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_GetEntry</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">LockedReqTable</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_lockBalanceMaybe</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">lockBalanceOK</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>

	<span class="nf">Assert</span><span class="p">(</span><span class="nx">amount</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">_addressEntryExists</span><span class="p">(</span><span class="nx">addr</span><span class="p">))</span>

	<span class="nx">prevLocked</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getLockedReqBalanceInternal</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">prevLocked</span><span class="o">+</span><span class="nx">amount</span> <span class="p">&gt;</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getTotalEscrowBalanceInternal</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">lockBalanceOK</span> <span class="p">=</span> <span class="kc">false</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">newLockedReqTable</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_WithAdd</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">LockedReqTable</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">LockedReqTable</span> <span class="p">=</span> <span class="nx">newLockedReqTable</span>

	<span class="nx">lockBalanceOK</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_unlockBalance</span><span class="p">(</span>
	<span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">unlockAmountRequested</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>

	<span class="nf">Assert</span><span class="p">(</span><span class="nx">unlockAmountRequested</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">_addressEntryExists</span><span class="p">(</span><span class="nx">addr</span><span class="p">))</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">LockedReqTable</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_tableWithDeductBalanceExact</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">LockedReqTable</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">unlockAmountRequested</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_tableWithAddBalance</span><span class="p">(</span>
	<span class="nx">table</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">BalanceTableHAMT</span><span class="p">,</span> <span class="nx">toAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amountToAdd</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">BalanceTableHAMT</span> <span class="p">{</span>

	<span class="nf">Assert</span><span class="p">(</span><span class="nx">amountToAdd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_WithAdd</span><span class="p">(</span><span class="nx">table</span><span class="p">,</span> <span class="nx">toAddr</span><span class="p">,</span> <span class="nx">amountToAdd</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">newTable</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_tableWithDeductBalanceExact</span><span class="p">(</span>
	<span class="nx">table</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">BalanceTableHAMT</span><span class="p">,</span> <span class="nx">fromAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amountRequested</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nx">BalanceTableHAMT</span> <span class="p">{</span>

	<span class="nf">Assert</span><span class="p">(</span><span class="nx">amountRequested</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">amountDeducted</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_WithSubtractPreservingNonnegative</span><span class="p">(</span>
		<span class="nx">table</span><span class="p">,</span> <span class="nx">fromAddr</span><span class="p">,</span> <span class="nx">amountRequested</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">amountDeducted</span> <span class="o">==</span> <span class="nx">amountRequested</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">newTable</span>
<span class="p">}</span>

<span class="c1">// move funds from locked in client to available in provider
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_transferBalance</span><span class="p">(</span>
	<span class="nx">fromAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">toAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">transferAmountRequested</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>

	<span class="nf">Assert</span><span class="p">(</span><span class="nx">transferAmountRequested</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">_addressEntryExists</span><span class="p">(</span><span class="nx">fromAddr</span><span class="p">))</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">_addressEntryExists</span><span class="p">(</span><span class="nx">toAddr</span><span class="p">))</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_tableWithDeductBalanceExact</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">fromAddr</span><span class="p">,</span> <span class="nx">transferAmountRequested</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">LockedReqTable</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_tableWithDeductBalanceExact</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">LockedReqTable</span><span class="p">,</span> <span class="nx">fromAddr</span><span class="p">,</span> <span class="nx">transferAmountRequested</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_tableWithAddBalance</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">toAddr</span><span class="p">,</span> <span class="nx">transferAmountRequested</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_slashBalance</span><span class="p">(</span><span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">slashAmount</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nf">_addressEntryExists</span><span class="p">(</span><span class="nx">addr</span><span class="p">))</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">slashAmount</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_tableWithDeductBalanceExact</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">slashAmount</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">LockedReqTable</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_tableWithDeductBalanceExact</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">LockedReqTable</span><span class="p">,</span> <span class="nx">addr</span><span class="p">,</span> <span class="nx">slashAmount</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Method utility functions
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_rtAbortIfAddressEntryDoesNotExist</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">entryAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">st</span><span class="p">.</span><span class="nf">_addressEntryExists</span><span class="p">(</span><span class="nx">entryAddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Address entry does not exist&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_rtUpdatePendingDealStatesForParty</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">amountSlashedTotal</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>

	<span class="c1">// For consistency with OnEpochTickEnd, only process updates up to the end of the _previous_ epoch.
</span><span class="c1"></span>	<span class="nx">epoch</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>

	<span class="nx">cachedRes</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedDealIDsByParty</span><span class="p">[</span><span class="nx">addr</span><span class="p">]</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">extractedDealIDs</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">cachedDealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cachedRes</span> <span class="p">{</span>
		<span class="nx">extractedDealIDs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">extractedDealIDs</span><span class="p">,</span> <span class="nx">cachedDealID</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">amountSlashedTotal</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_updatePendingDealStates</span><span class="p">(</span><span class="nx">extractedDealIDs</span><span class="p">,</span> <span class="nx">epoch</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_rtGetOnChainDealOrAbort</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="p">(</span><span class="nx">deal</span> <span class="nx">OnChainDeal</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">found</span> <span class="kt">bool</span>
	<span class="nx">deal</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">,</span> <span class="nx">found</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getOnChainDeal</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;dealID not found in Deals.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_rtLockBalanceOrAbort</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">addr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">amount</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Negative amount&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">st</span><span class="p">.</span><span class="nf">_rtAbortIfAddressEntryDoesNotExist</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>

	<span class="nx">ok</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_lockBalanceMaybe</span><span class="p">(</span><span class="nx">addr</span><span class="p">,</span> <span class="nx">amount</span><span class="p">)</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortFundsMsg</span><span class="p">(</span><span class="s">&#34;Insufficient funds available to lock.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// State utility functions
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">_rtDealProposalIsInternallyValid</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span> <span class="o">&lt;=</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nf">Duration</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="o">-</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="c1">// Determine which subset of DealProposal to use as the message to be signed by the client.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">m</span> <span class="p">[]</span><span class="kt">byte</span>

	<span class="c1">// Note: we do not verify the provider signature here, since this is implicit in the
</span><span class="c1"></span>	<span class="c1">// authenticity of the on-chain message publishing the deal.
</span><span class="c1"></span>	<span class="nx">sigVerified</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">Syscalls</span><span class="p">().</span><span class="nf">VerifySignature</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">ClientSignature</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">sigVerified</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_dealGetPaymentRemaining</span><span class="p">(</span><span class="nx">deal</span> <span class="nx">OnChainDeal</span><span class="p">,</span> <span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span> <span class="p">{</span>
	<span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">Deal</span><span class="p">.</span><span class="nx">Proposal</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">epoch</span> <span class="o">&lt;=</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">)</span>

	<span class="nx">durationRemaining</span> <span class="o">:=</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span> <span class="o">-</span> <span class="p">(</span><span class="nx">epoch</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">durationRemaining</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>

	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">durationRemaining</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">StoragePricePerEpoch</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_getOnChainDeal</span><span class="p">(</span><span class="nx">dealID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">deal</span> <span class="nx">OnChainDeal</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>

	<span class="kd">var</span> <span class="nx">found</span> <span class="kt">bool</span>
	<span class="nx">deal</span><span class="p">,</span> <span class="nx">found</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">found</span> <span class="p">{</span>
		<span class="nx">dealP</span> <span class="p">=</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">Deal</span><span class="p">.</span><span class="nx">Proposal</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">deal</span> <span class="p">=</span> <span class="nx">OnChainDeal</span><span class="p">{}</span>
		<span class="nx">dealP</span> <span class="p">=</span> <span class="nx">StorageDealProposal</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">st</span> <span class="o">*</span><span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="nf">_getOnChainDealAssert</span><span class="p">(</span><span class="nx">dealID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">)</span> <span class="p">(</span>
	<span class="nx">deal</span> <span class="nx">OnChainDeal</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>

	<span class="kd">var</span> <span class="nx">ok</span> <span class="kt">bool</span>
	<span class="nx">deal</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getOnChainDeal</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="k">return</span>
<span class="p">}</span>
</code></pre></div>





<h5 id="storagemarketactor-implementation"><code>StorageMarketActor</code> implementation</h5>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_market</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">storage_miner</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_miner&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
	<span class="nx">actor_util</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">DealWeight</span> <span class="kt">int64</span>

<span class="kd">type</span> <span class="nx">StorageMarketActor</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">state</span> <span class="nx">StorageMarketActorState</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">())</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;state not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Actor methods
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="c1">// Terminate a set of deals in response to their containing sector being terminated.
</span><span class="c1">// Slash provider collateral, refund client collateral, and refund partial unpaid escrow
</span><span class="c1">// amount to client.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">TerminateDealsOnSlashProviderSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Attempt to withdraw the specified amount from the balance held in escrow.
</span><span class="c1">// If less than the specified amount is available, yields the entire available balance.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">WithdrawBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">entryAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amountRequested</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="nx">amountSlashedTotal</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">amountRequested</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Negative amount.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">recipientAddr</span> <span class="o">:=</span> <span class="nf">RT_MinerEntry_ValidateCaller_DetermineFundsLocation</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">,</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">MinerEntrySpec_MinerOrSignable</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_rtAbortIfAddressEntryDoesNotExist</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">)</span>

	<span class="c1">// Before any operations that check the balance tables for funds, execute all deferred
</span><span class="c1"></span>	<span class="c1">// deal state updates.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Note: as an optimization, implementations may cache efficient data structures indicating
</span><span class="c1"></span>	<span class="c1">// which of the following set of updates are redundant and can be skipped.
</span><span class="c1"></span>	<span class="nx">amountSlashedTotal</span> <span class="o">+=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtUpdatePendingDealStatesForParty</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">)</span>

	<span class="nx">minBalance</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getLockedReqBalanceInternal</span><span class="p">(</span><span class="nx">entryAddr</span><span class="p">)</span>
	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">amountExtracted</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_WithExtractPartial</span><span class="p">(</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">,</span> <span class="nx">amountRequested</span><span class="p">,</span> <span class="nx">minBalance</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">newTable</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">amountSlashedTotal</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">recipientAddr</span><span class="p">,</span> <span class="nx">amountExtracted</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Deposits the specified amount into the balance held in escrow.
</span><span class="c1">// Note: the amount is included implicitly in the message.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">AddBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">entryAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">RT_MinerEntry_ValidateCaller_DetermineFundsLocation</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">,</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">MinerEntrySpec_MinerOrSignable</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_rtAbortIfAddressEntryDoesNotExist</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">)</span>

	<span class="nx">msgValue</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReceived</span><span class="p">()</span>
	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_WithAdd</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">,</span> <span class="nx">msgValue</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// Entry not found; create implicitly.
</span><span class="c1"></span>		<span class="nx">newTable</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_WithNewAddressEntry</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">,</span> <span class="nx">msgValue</span><span class="p">)</span>
		<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">newTable</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Publish a new set of storage deals (not yet included in a sector).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">PublishStorageDeals</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">newStorageDeals</span> <span class="p">[]</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="nx">amountSlashedTotal</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1">// Deal message must have a From field identical to the provider of all the deals.
</span><span class="c1"></span>	<span class="c1">// This allows us to retain and verify only the client&#39;s signature in each deal proposal itself.
</span><span class="c1"></span>	<span class="nf">RT_ValidateImmediateCallerIsSignable</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">providerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// All storage deals will be added in an atomic transaction; this operation will be unrolled if any of them fails.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">newDeal</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newStorageDeals</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">newDeal</span><span class="p">.</span><span class="nx">Proposal</span>

		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Provider</span> <span class="o">!=</span> <span class="nx">providerAddr</span> <span class="p">{</span>
			<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Incorrect provider listed in deal&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nf">_rtAbortIfNewDealInvalid</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">newDeal</span><span class="p">)</span>

		<span class="c1">// Before any operations that check the balance tables for funds, execute all deferred
</span><span class="c1"></span>		<span class="c1">// deal state updates.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Note: as an optimization, implementations may cache efficient data structures indicating
</span><span class="c1"></span>		<span class="c1">// which of the following set of updates are redundant and can be skipped.
</span><span class="c1"></span>		<span class="nx">amountSlashedTotal</span> <span class="o">+=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtUpdatePendingDealStatesForParty</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Client</span><span class="p">)</span>
		<span class="nx">amountSlashedTotal</span> <span class="o">+=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtUpdatePendingDealStatesForParty</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Provider</span><span class="p">)</span>

		<span class="nx">st</span><span class="p">.</span><span class="nf">_rtLockBalanceOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">ClientBalanceRequirement</span><span class="p">())</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_rtLockBalanceOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Provider</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">ProviderBalanceRequirement</span><span class="p">())</span>

		<span class="nx">id</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_generateStorageDealID</span><span class="p">(</span><span class="nx">newDeal</span><span class="p">)</span>

		<span class="nx">onchainDeal</span> <span class="o">:=</span> <span class="nx">OnChainDeal</span><span class="p">{</span>
			<span class="nx">ID</span><span class="p">:</span>               <span class="nx">id</span><span class="p">,</span>
			<span class="nx">Deal</span><span class="p">:</span>             <span class="nx">newDeal</span><span class="p">,</span>
			<span class="nx">SectorStartEpoch</span><span class="p">:</span> <span class="nx">epochUndefined</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="p">=</span> <span class="nx">onchainDeal</span>

		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsPending</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">];</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsPending</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">DealIDQueue_Empty</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">cep</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsPending</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">]</span>
		<span class="nx">cep</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">CurrEpochNumDealsPublished</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newStorageDeals</span><span class="p">)</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">amountSlashedTotal</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Verify that a given set of storage deals is valid for a sector currently being PreCommitted.
</span><span class="c1">// Note: in the case of a capacity-commitment sector (one with zero deals), this function should succeed vacuously.
</span><span class="c1">// TODO: replace SectorPreCommitInfo parameter with just the expiration
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">VerifyDealsOnSectorPreCommit</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">,</span> <span class="nx">sectorInfo</span> <span class="nx">storage_miner</span><span class="p">.</span><span class="nx">SectorPreCommitInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">deal</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtGetOnChainDealOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
		<span class="nf">_rtAbortIfDealInvalidForNewSectorSeal</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">Expiration</span><span class="p">,</span> <span class="nx">deal</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Verify that a given set of storage deals is valid for a sector currently being ProveCommitted,
</span><span class="c1">// and update the market&#39;s internal state accordingly.
</span><span class="c1">// TODO: replace SectorProveCommitInfo parameter with just the expiration
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">UpdateDealsOnSectorProveCommit</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">,</span> <span class="nx">sectorInfo</span> <span class="nx">storage_miner</span><span class="p">.</span><span class="nx">SectorProveCommitInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">deal</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtGetOnChainDealOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
		<span class="nf">_rtAbortIfDealInvalidForNewSectorSeal</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">Expiration</span><span class="p">,</span> <span class="nx">deal</span><span class="p">)</span>
		<span class="nx">ocd</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span>
		<span class="nx">ocd</span><span class="p">.</span><span class="nx">SectorStartEpoch</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ocd</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">GetPieceInfosForDealIDs</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfos</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>

	<span class="nx">ret</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">{}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtGetOnChainDealOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">{</span>
			<span class="nx">PieceCID</span><span class="p">:</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">,</span>
			<span class="nx">Size</span><span class="p">:</span>     <span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">.</span><span class="nf">Total</span><span class="p">(),</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfos</span><span class="p">{</span><span class="nx">Items</span><span class="p">:</span> <span class="nx">ret</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Get the weight for a given set of storage deals.
</span><span class="c1">// The weight is defined as the sum, over all deals in the set, of the product of its size
</span><span class="c1">// with its duration. This quantity may be an input into the functions specifying block reward,
</span><span class="c1">// sector power, collateral, and/or other parameters.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">GetWeightForDealSet</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealWeight</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="nx">ret</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getOnChainDealAssert</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
		<span class="nf">Assert</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span> <span class="o">==</span> <span class="nx">minerAddr</span><span class="p">)</span>

		<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>		<span class="nx">ret</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nf">Duration</span><span class="p">())</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">.</span><span class="nf">Total</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">DealWeight</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">OnMinerSectorsTerminate</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtGetOnChainDealOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
		<span class="nf">Assert</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span> <span class="o">==</span> <span class="nx">minerAddr</span><span class="p">)</span>

		<span class="c1">// Note: we do not perform the balance transfers here, but rather simply record the flag
</span><span class="c1"></span>		<span class="c1">// to indicate that _processDealSlashed should be called when the deferred state computation
</span><span class="c1"></span>		<span class="c1">// is performed.
</span><span class="c1"></span>		<span class="nx">ocd</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span>
		<span class="nx">ocd</span><span class="p">.</span><span class="nx">SlashEpoch</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ocd</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">OnEpochTickEnd</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">CronActorAddr</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// Some deals may never be affected by the normal calls to _rtUpdatePendingDealStatesForParty
</span><span class="c1"></span>	<span class="c1">// (notably, if the relevant party never checks its balance).
</span><span class="c1"></span>	<span class="c1">// Without some cleanup mechanism, these deals may gradually accumulate and cause
</span><span class="c1"></span>	<span class="c1">// the StorageMarketActor state to grow without bound.
</span><span class="c1"></span>	<span class="c1">// To prevent this, we amortize the cost of this cleanup by processing a relatively
</span><span class="c1"></span>	<span class="c1">// small number of deals every epoch, independent of the calls above.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// More specifically, we process deals:
</span><span class="c1"></span>	<span class="c1">//   (a) In priority order of expiration epoch, up until the current epoch
</span><span class="c1"></span>	<span class="c1">//   (b) Within a given expiration epoch, in order of original publishing.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We stop once we have exhausted this valid set, or when we have hit a certain target
</span><span class="c1"></span>	<span class="c1">// (DEAL_PROC_AMORTIZED_SCALE_FACTOR times the number of deals freshly published in the
</span><span class="c1"></span>	<span class="c1">// current epoch) of deals dequeued, whichever comes first.
</span><span class="c1"></span>
	<span class="kd">const</span> <span class="nx">DEAL_PROC_AMORTIZED_SCALE_FACTOR</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">numDequeuedTarget</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CurrEpochNumDealsPublished</span> <span class="o">*</span> <span class="nx">DEAL_PROC_AMORTIZED_SCALE_FACTOR</span>

	<span class="nx">numDequeued</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">extractedDealIDs</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">{}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsNextProcEpoch</span> <span class="p">&gt;</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">numDequeued</span> <span class="o">&gt;=</span> <span class="nx">numDequeuedTarget</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="nx">queue</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsPending</span><span class="p">[</span><span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsNextProcEpoch</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsNextProcEpoch</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">queueDepleted</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">dealID</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">()</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">queueDepleted</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">numDequeued</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">];</span> <span class="nx">found</span> <span class="p">{</span>
				<span class="c1">// May have already processed expiration, independently, via _rtUpdatePendingDealStatesForParty.
</span><span class="c1"></span>				<span class="c1">// If not, add it to the list to be processed.
</span><span class="c1"></span>				<span class="nx">extractedDealIDs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">extractedDealIDs</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">!</span><span class="nx">queueDepleted</span> <span class="p">{</span>
			<span class="nf">Assert</span><span class="p">(</span><span class="nx">numDequeued</span> <span class="o">&gt;=</span> <span class="nx">numDequeuedTarget</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsPending</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsNextProcEpoch</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsNextProcEpoch</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">amountSlashedTotal</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_updatePendingDealStates</span><span class="p">(</span><span class="nx">extractedDealIDs</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">())</span>

	<span class="c1">// Reset for next epoch.
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nx">CurrEpochNumDealsPublished</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">amountSlashedTotal</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>

	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">StorageMarketActorState</span><span class="p">{</span>
		<span class="nx">Deals</span><span class="p">:</span>                          <span class="nf">DealsAMT_Empty</span><span class="p">(),</span>
		<span class="nx">EscrowTable</span><span class="p">:</span>                    <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTableHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">LockedReqTable</span><span class="p">:</span>                 <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTableHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">NextID</span><span class="p">:</span>                         <span class="nx">abi</span><span class="p">.</span><span class="nf">DealID</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">CachedDealIDsByParty</span><span class="p">:</span>           <span class="nf">CachedDealIDsByPartyHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">CachedExpirationsPending</span><span class="p">:</span>       <span class="nf">CachedExpirationsPendingHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">CachedExpirationsNextProcEpoch</span><span class="p">:</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">ChainEpoch</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Method utility functions
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">_rtAbortIfDealAlreadyProven</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">OnChainDeal</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">SectorStartEpoch</span> <span class="o">!=</span> <span class="nx">epochUndefined</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal has already appeared in proven sector.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealNotFromProvider</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span> <span class="o">!=</span> <span class="nx">minerAddr</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal has incorrect miner as its provider.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealStartElapsed</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal start epoch has already elapsed.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealEndElapsed</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span> <span class="p">&gt;</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal end epoch has already elapsed.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealExceedsSectorLifetime</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">sectorExpiration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span> <span class="p">&gt;</span> <span class="nx">sectorExpiration</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal would outlive its containing sector.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealInvalidForNewSectorSeal</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">sectorExpiration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">OnChainDeal</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">Deal</span><span class="p">.</span><span class="nx">Proposal</span>

	<span class="nf">_rtAbortIfDealNotFromProvider</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nf">_rtAbortIfDealAlreadyProven</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">deal</span><span class="p">)</span>
	<span class="nf">_rtAbortIfDealStartElapsed</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">)</span>
	<span class="nf">_rtAbortIfDealExceedsSectorLifetime</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">,</span> <span class="nx">sectorExpiration</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfNewDealInvalid</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">StorageDeal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">Proposal</span>

	<span class="k">if</span> <span class="p">!</span><span class="nf">_rtDealProposalIsInternallyValid</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Invalid deal proposal.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">_rtAbortIfDealStartElapsed</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">)</span>
	<span class="nf">_rtAbortIfDealFailsParamBounds</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealFailsParamBounds</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">inds</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrIndices</span><span class="p">()</span>

	<span class="nx">minDuration</span><span class="p">,</span> <span class="nx">maxDuration</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">StorageDeal_DurationBounds</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nf">Duration</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">minDuration</span> <span class="o">||</span> <span class="nx">dealP</span><span class="p">.</span><span class="nf">Duration</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">maxDuration</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal duration out of bounds.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">minPrice</span><span class="p">,</span> <span class="nx">maxPrice</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">StorageDeal_StoragePricePerEpochBounds</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StoragePricePerEpoch</span> <span class="p">&lt;</span> <span class="nx">minPrice</span> <span class="o">||</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StoragePricePerEpoch</span> <span class="p">&gt;</span> <span class="nx">maxPrice</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Storage price out of bounds.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">minProviderCollateral</span><span class="p">,</span> <span class="nx">maxProviderCollateral</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">StorageDeal_ProviderCollateralBounds</span><span class="p">(</span>
		<span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ProviderCollateral</span> <span class="p">&lt;</span> <span class="nx">minProviderCollateral</span> <span class="o">||</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ProviderCollateral</span> <span class="p">&gt;</span> <span class="nx">maxProviderCollateral</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Provider collateral out of bounds.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">minClientCollateral</span><span class="p">,</span> <span class="nx">maxClientCollateral</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">StorageDeal_ClientCollateralBounds</span><span class="p">(</span>
		<span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ClientCollateral</span> <span class="p">&lt;</span> <span class="nx">minClientCollateral</span> <span class="o">||</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ClientCollateral</span> <span class="p">&gt;</span> <span class="nx">maxClientCollateral</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Client collateral out of bounds.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>





<h5 id="storagemarketactor-implementation-1"><code>StorageMarketActor</code> implementation</h5>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_market</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">storage_miner</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_miner&#34;</span>
	<span class="nx">vmr</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/runtime&#34;</span>
	<span class="nx">actor_util</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">DealWeight</span> <span class="kt">int64</span>

<span class="kd">type</span> <span class="nx">StorageMarketActor</span> <span class="kd">struct</span><span class="p">{}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">State</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">(</span><span class="nx">vmr</span><span class="p">.</span><span class="nx">ActorStateHandle</span><span class="p">,</span> <span class="nx">StorageMarketActorState</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">state</span> <span class="nx">StorageMarketActorState</span>
	<span class="nx">stateCID</span> <span class="o">:=</span> <span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nf">Take</span><span class="p">())</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">rt</span><span class="p">.</span><span class="nf">IpldGet</span><span class="p">(</span><span class="nx">stateCID</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortAPI</span><span class="p">(</span><span class="s">&#34;state not found&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">state</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Actor methods
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="c1">// Terminate a set of deals in response to their containing sector being terminated.
</span><span class="c1">// Slash provider collateral, refund client collateral, and refund partial unpaid escrow
</span><span class="c1">// amount to client.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">TerminateDealsOnSlashProviderSector</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Attempt to withdraw the specified amount from the balance held in escrow.
</span><span class="c1">// If less than the specified amount is available, yields the entire available balance.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">WithdrawBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">entryAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">amountRequested</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="nx">amountSlashedTotal</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">amountRequested</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Negative amount.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">recipientAddr</span> <span class="o">:=</span> <span class="nf">RT_MinerEntry_ValidateCaller_DetermineFundsLocation</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">,</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">MinerEntrySpec_MinerOrSignable</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_rtAbortIfAddressEntryDoesNotExist</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">)</span>

	<span class="c1">// Before any operations that check the balance tables for funds, execute all deferred
</span><span class="c1"></span>	<span class="c1">// deal state updates.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// Note: as an optimization, implementations may cache efficient data structures indicating
</span><span class="c1"></span>	<span class="c1">// which of the following set of updates are redundant and can be skipped.
</span><span class="c1"></span>	<span class="nx">amountSlashedTotal</span> <span class="o">+=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtUpdatePendingDealStatesForParty</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">)</span>

	<span class="nx">minBalance</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getLockedReqBalanceInternal</span><span class="p">(</span><span class="nx">entryAddr</span><span class="p">)</span>
	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">amountExtracted</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_WithExtractPartial</span><span class="p">(</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">,</span> <span class="nx">amountRequested</span><span class="p">,</span> <span class="nx">minBalance</span><span class="p">)</span>
	<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">newTable</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">amountSlashedTotal</span><span class="p">)</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">recipientAddr</span><span class="p">,</span> <span class="nx">amountExtracted</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Deposits the specified amount into the balance held in escrow.
</span><span class="c1">// Note: the amount is included implicitly in the message.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">AddBalance</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">entryAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">RT_MinerEntry_ValidateCaller_DetermineFundsLocation</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">,</span> <span class="nx">vmr</span><span class="p">.</span><span class="nx">MinerEntrySpec_MinerOrSignable</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">st</span><span class="p">.</span><span class="nf">_rtAbortIfAddressEntryDoesNotExist</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">)</span>

	<span class="nx">msgValue</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ValueReceived</span><span class="p">()</span>
	<span class="nx">newTable</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_WithAdd</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">,</span> <span class="nx">msgValue</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="c1">// Entry not found; create implicitly.
</span><span class="c1"></span>		<span class="nx">newTable</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTable_WithNewAddressEntry</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span><span class="p">,</span> <span class="nx">entryAddr</span><span class="p">,</span> <span class="nx">msgValue</span><span class="p">)</span>
		<span class="nf">Assert</span><span class="p">(</span><span class="nx">ok</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">st</span><span class="p">.</span><span class="nx">EscrowTable</span> <span class="p">=</span> <span class="nx">newTable</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Publish a new set of storage deals (not yet included in a sector).
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">PublishStorageDeals</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">newStorageDeals</span> <span class="p">[]</span><span class="nx">StorageDeal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="nx">amountSlashedTotal</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">TokenAmount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

	<span class="c1">// Deal message must have a From field identical to the provider of all the deals.
</span><span class="c1"></span>	<span class="c1">// This allows us to retain and verify only the client&#39;s signature in each deal proposal itself.
</span><span class="c1"></span>	<span class="nf">RT_ValidateImmediateCallerIsSignable</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>
	<span class="nx">providerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// All storage deals will be added in an atomic transaction; this operation will be unrolled if any of them fails.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">newDeal</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newStorageDeals</span> <span class="p">{</span>
		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">newDeal</span><span class="p">.</span><span class="nx">Proposal</span>

		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Provider</span> <span class="o">!=</span> <span class="nx">providerAddr</span> <span class="p">{</span>
			<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortArgMsg</span><span class="p">(</span><span class="s">&#34;Incorrect provider listed in deal&#34;</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="nf">_rtAbortIfNewDealInvalid</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">newDeal</span><span class="p">)</span>

		<span class="c1">// Before any operations that check the balance tables for funds, execute all deferred
</span><span class="c1"></span>		<span class="c1">// deal state updates.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// Note: as an optimization, implementations may cache efficient data structures indicating
</span><span class="c1"></span>		<span class="c1">// which of the following set of updates are redundant and can be skipped.
</span><span class="c1"></span>		<span class="nx">amountSlashedTotal</span> <span class="o">+=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtUpdatePendingDealStatesForParty</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Client</span><span class="p">)</span>
		<span class="nx">amountSlashedTotal</span> <span class="o">+=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtUpdatePendingDealStatesForParty</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Provider</span><span class="p">)</span>

		<span class="nx">st</span><span class="p">.</span><span class="nf">_rtLockBalanceOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Client</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">ClientBalanceRequirement</span><span class="p">())</span>
		<span class="nx">st</span><span class="p">.</span><span class="nf">_rtLockBalanceOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Provider</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nf">ProviderBalanceRequirement</span><span class="p">())</span>

		<span class="nx">id</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_generateStorageDealID</span><span class="p">(</span><span class="nx">newDeal</span><span class="p">)</span>

		<span class="nx">onchainDeal</span> <span class="o">:=</span> <span class="nx">OnChainDeal</span><span class="p">{</span>
			<span class="nx">ID</span><span class="p">:</span>               <span class="nx">id</span><span class="p">,</span>
			<span class="nx">Deal</span><span class="p">:</span>             <span class="nx">newDeal</span><span class="p">,</span>
			<span class="nx">SectorStartEpoch</span><span class="p">:</span> <span class="nx">epochUndefined</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span> <span class="p">=</span> <span class="nx">onchainDeal</span>

		<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsPending</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">];</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsPending</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">]</span> <span class="p">=</span> <span class="nx">actor_util</span><span class="p">.</span><span class="nf">DealIDQueue_Empty</span><span class="p">()</span>
		<span class="p">}</span>
		<span class="nx">cep</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsPending</span><span class="p">[</span><span class="nx">p</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">]</span>
		<span class="nx">cep</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">st</span><span class="p">.</span><span class="nx">CurrEpochNumDealsPublished</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newStorageDeals</span><span class="p">)</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">amountSlashedTotal</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Verify that a given set of storage deals is valid for a sector currently being PreCommitted.
</span><span class="c1">// Note: in the case of a capacity-commitment sector (one with zero deals), this function should succeed vacuously.
</span><span class="c1">// TODO: replace SectorPreCommitInfo parameter with just the expiration
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">VerifyDealsOnSectorPreCommit</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">,</span> <span class="nx">sectorInfo</span> <span class="nx">storage_miner</span><span class="p">.</span><span class="nx">SectorPreCommitInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">deal</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtGetOnChainDealOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
		<span class="nf">_rtAbortIfDealInvalidForNewSectorSeal</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">Expiration</span><span class="p">,</span> <span class="nx">deal</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Verify that a given set of storage deals is valid for a sector currently being ProveCommitted,
</span><span class="c1">// and update the market&#39;s internal state accordingly.
</span><span class="c1">// TODO: replace SectorProveCommitInfo parameter with just the expiration
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">UpdateDealsOnSectorProveCommit</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">,</span> <span class="nx">sectorInfo</span> <span class="nx">storage_miner</span><span class="p">.</span><span class="nx">SectorProveCommitInfo</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">deal</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtGetOnChainDealOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
		<span class="nf">_rtAbortIfDealInvalidForNewSectorSeal</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">,</span> <span class="nx">sectorInfo</span><span class="p">.</span><span class="nx">Expiration</span><span class="p">,</span> <span class="nx">deal</span><span class="p">)</span>
		<span class="nx">ocd</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span>
		<span class="nx">ocd</span><span class="p">.</span><span class="nx">SectorStartEpoch</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ocd</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">GetPieceInfosForDealIDs</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfos</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>

	<span class="nx">ret</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">{}</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtGetOnChainDealOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
		<span class="nx">ret</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">{</span>
			<span class="nx">PieceCID</span><span class="p">:</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">,</span>
			<span class="nx">Size</span><span class="p">:</span>     <span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">.</span><span class="nf">Total</span><span class="p">(),</span>
		<span class="p">})</span>
	<span class="p">}</span>

	<span class="nf">Release</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfos</span><span class="p">{</span><span class="nx">Items</span><span class="p">:</span> <span class="nx">ret</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Get the weight for a given set of storage deals.
</span><span class="c1">// The weight is defined as the sum, over all deals in the set, of the product of its size
</span><span class="c1">// with its duration. This quantity may be an input into the functions specifying block reward,
</span><span class="c1">// sector power, collateral, and/or other parameters.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">GetWeightForDealSet</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealWeight</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>	<span class="nx">ret</span> <span class="o">:=</span> <span class="mi">0</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_getOnChainDealAssert</span><span class="p">(</span><span class="nx">dealID</span><span class="p">)</span>
		<span class="nf">Assert</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span> <span class="o">==</span> <span class="nx">minerAddr</span><span class="p">)</span>

		<span class="nf">IMPL_FINISH</span><span class="p">()</span> <span class="c1">// BigInt arithmetic
</span><span class="c1"></span>		<span class="nx">ret</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nf">Duration</span><span class="p">())</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">.</span><span class="nf">Total</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">DealWeight</span><span class="p">(</span><span class="nx">ret</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">OnMinerSectorsTerminate</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealIDs</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">DealIDs</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerAcceptAnyOfType</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">StorageMinerActorCodeID</span><span class="p">)</span>
	<span class="nx">minerAddr</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">ImmediateCaller</span><span class="p">()</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dealID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dealIDs</span><span class="p">.</span><span class="nx">Items</span> <span class="p">{</span>
		<span class="nx">_</span><span class="p">,</span> <span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_rtGetOnChainDealOrAbort</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
		<span class="nf">Assert</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span> <span class="o">==</span> <span class="nx">minerAddr</span><span class="p">)</span>

		<span class="c1">// Note: we do not perform the balance transfers here, but rather simply record the flag
</span><span class="c1"></span>		<span class="c1">// to indicate that _processDealSlashed should be called when the deferred state computation
</span><span class="c1"></span>		<span class="c1">// is performed.
</span><span class="c1"></span>		<span class="nx">ocd</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span>
		<span class="nx">ocd</span><span class="p">.</span><span class="nx">SlashEpoch</span> <span class="p">=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">]</span> <span class="p">=</span> <span class="nx">ocd</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">OnEpochTickEnd</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">CronActorAddr</span><span class="p">)</span>

	<span class="nx">h</span><span class="p">,</span> <span class="nx">st</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">.</span><span class="nf">State</span><span class="p">(</span><span class="nx">rt</span><span class="p">)</span>

	<span class="c1">// Some deals may never be affected by the normal calls to _rtUpdatePendingDealStatesForParty
</span><span class="c1"></span>	<span class="c1">// (notably, if the relevant party never checks its balance).
</span><span class="c1"></span>	<span class="c1">// Without some cleanup mechanism, these deals may gradually accumulate and cause
</span><span class="c1"></span>	<span class="c1">// the StorageMarketActor state to grow without bound.
</span><span class="c1"></span>	<span class="c1">// To prevent this, we amortize the cost of this cleanup by processing a relatively
</span><span class="c1"></span>	<span class="c1">// small number of deals every epoch, independent of the calls above.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// More specifically, we process deals:
</span><span class="c1"></span>	<span class="c1">//   (a) In priority order of expiration epoch, up until the current epoch
</span><span class="c1"></span>	<span class="c1">//   (b) Within a given expiration epoch, in order of original publishing.
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// We stop once we have exhausted this valid set, or when we have hit a certain target
</span><span class="c1"></span>	<span class="c1">// (DEAL_PROC_AMORTIZED_SCALE_FACTOR times the number of deals freshly published in the
</span><span class="c1"></span>	<span class="c1">// current epoch) of deals dequeued, whichever comes first.
</span><span class="c1"></span>
	<span class="kd">const</span> <span class="nx">DEAL_PROC_AMORTIZED_SCALE_FACTOR</span> <span class="p">=</span> <span class="mi">2</span>
	<span class="nx">numDequeuedTarget</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CurrEpochNumDealsPublished</span> <span class="o">*</span> <span class="nx">DEAL_PROC_AMORTIZED_SCALE_FACTOR</span>

	<span class="nx">numDequeued</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="nx">extractedDealIDs</span> <span class="o">:=</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span><span class="p">{}</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsNextProcEpoch</span> <span class="p">&gt;</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">numDequeued</span> <span class="o">&gt;=</span> <span class="nx">numDequeuedTarget</span> <span class="p">{</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="nx">queue</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsPending</span><span class="p">[</span><span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsNextProcEpoch</span><span class="p">]</span>
		<span class="k">if</span> <span class="p">!</span><span class="nx">found</span> <span class="p">{</span>
			<span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsNextProcEpoch</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="k">continue</span>
		<span class="p">}</span>

		<span class="nx">queueDepleted</span> <span class="o">:=</span> <span class="kc">false</span>
		<span class="k">for</span> <span class="p">{</span>
			<span class="nx">dealID</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">queue</span><span class="p">.</span><span class="nf">Dequeue</span><span class="p">()</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="nx">queueDepleted</span> <span class="p">=</span> <span class="kc">true</span>
				<span class="k">break</span>
			<span class="p">}</span>
			<span class="nx">numDequeued</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">found</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">Deals</span><span class="p">[</span><span class="nx">dealID</span><span class="p">];</span> <span class="nx">found</span> <span class="p">{</span>
				<span class="c1">// May have already processed expiration, independently, via _rtUpdatePendingDealStatesForParty.
</span><span class="c1"></span>				<span class="c1">// If not, add it to the list to be processed.
</span><span class="c1"></span>				<span class="nx">extractedDealIDs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">extractedDealIDs</span><span class="p">,</span> <span class="nx">dealID</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">!</span><span class="nx">queueDepleted</span> <span class="p">{</span>
			<span class="nf">Assert</span><span class="p">(</span><span class="nx">numDequeued</span> <span class="o">&gt;=</span> <span class="nx">numDequeuedTarget</span><span class="p">)</span>
			<span class="k">break</span>
		<span class="p">}</span>

		<span class="nb">delete</span><span class="p">(</span><span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsPending</span><span class="p">,</span> <span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsNextProcEpoch</span><span class="p">)</span>
		<span class="nx">st</span><span class="p">.</span><span class="nx">CachedExpirationsNextProcEpoch</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="p">}</span>

	<span class="nx">amountSlashedTotal</span> <span class="o">:=</span> <span class="nx">st</span><span class="p">.</span><span class="nf">_updatePendingDealStates</span><span class="p">(</span><span class="nx">extractedDealIDs</span><span class="p">,</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">())</span>

	<span class="c1">// Reset for next epoch.
</span><span class="c1"></span>	<span class="nx">st</span><span class="p">.</span><span class="nx">CurrEpochNumDealsPublished</span> <span class="p">=</span> <span class="mi">0</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>

	<span class="nx">rt</span><span class="p">.</span><span class="nf">SendFunds</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">BurntFundsActorAddr</span><span class="p">,</span> <span class="nx">amountSlashedTotal</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">StorageMarketActor</span><span class="p">)</span> <span class="nf">Constructor</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rt</span><span class="p">.</span><span class="nf">ValidateImmediateCallerIs</span><span class="p">(</span><span class="nx">builtin</span><span class="p">.</span><span class="nx">SystemActorAddr</span><span class="p">)</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">AcquireState</span><span class="p">()</span>

	<span class="nx">st</span> <span class="o">:=</span> <span class="nx">StorageMarketActorState</span><span class="p">{</span>
		<span class="nx">Deals</span><span class="p">:</span>                          <span class="nf">DealsAMT_Empty</span><span class="p">(),</span>
		<span class="nx">EscrowTable</span><span class="p">:</span>                    <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTableHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">LockedReqTable</span><span class="p">:</span>                 <span class="nx">actor_util</span><span class="p">.</span><span class="nf">BalanceTableHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">NextID</span><span class="p">:</span>                         <span class="nx">abi</span><span class="p">.</span><span class="nf">DealID</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="nx">CachedDealIDsByParty</span><span class="p">:</span>           <span class="nf">CachedDealIDsByPartyHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">CachedExpirationsPending</span><span class="p">:</span>       <span class="nf">CachedExpirationsPendingHAMT_Empty</span><span class="p">(),</span>
		<span class="nx">CachedExpirationsNextProcEpoch</span><span class="p">:</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">ChainEpoch</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="nf">UpdateRelease</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">st</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Method utility functions
</span><span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">_rtAbortIfDealAlreadyProven</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">OnChainDeal</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">SectorStartEpoch</span> <span class="o">!=</span> <span class="nx">epochUndefined</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal has already appeared in proven sector.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealNotFromProvider</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">Provider</span> <span class="o">!=</span> <span class="nx">minerAddr</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal has incorrect miner as its provider.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealStartElapsed</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal start epoch has already elapsed.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealEndElapsed</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span> <span class="p">&gt;</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrEpoch</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal end epoch has already elapsed.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealExceedsSectorLifetime</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">,</span> <span class="nx">sectorExpiration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span> <span class="p">&gt;</span> <span class="nx">sectorExpiration</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal would outlive its containing sector.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealInvalidForNewSectorSeal</span><span class="p">(</span>
	<span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">,</span> <span class="nx">sectorExpiration</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">OnChainDeal</span><span class="p">)</span> <span class="p">{</span>

	<span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">Deal</span><span class="p">.</span><span class="nx">Proposal</span>

	<span class="nf">_rtAbortIfDealNotFromProvider</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">,</span> <span class="nx">minerAddr</span><span class="p">)</span>
	<span class="nf">_rtAbortIfDealAlreadyProven</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">deal</span><span class="p">)</span>
	<span class="nf">_rtAbortIfDealStartElapsed</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">)</span>
	<span class="nf">_rtAbortIfDealExceedsSectorLifetime</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">,</span> <span class="nx">sectorExpiration</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfNewDealInvalid</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">deal</span> <span class="nx">StorageDeal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">dealP</span> <span class="o">:=</span> <span class="nx">deal</span><span class="p">.</span><span class="nx">Proposal</span>

	<span class="k">if</span> <span class="p">!</span><span class="nf">_rtDealProposalIsInternallyValid</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Invalid deal proposal.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nf">_rtAbortIfDealStartElapsed</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">)</span>
	<span class="nf">_rtAbortIfDealFailsParamBounds</span><span class="p">(</span><span class="nx">rt</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_rtAbortIfDealFailsParamBounds</span><span class="p">(</span><span class="nx">rt</span> <span class="nx">Runtime</span><span class="p">,</span> <span class="nx">dealP</span> <span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">inds</span> <span class="o">:=</span> <span class="nx">rt</span><span class="p">.</span><span class="nf">CurrIndices</span><span class="p">()</span>

	<span class="nx">minDuration</span><span class="p">,</span> <span class="nx">maxDuration</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">StorageDeal_DurationBounds</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nf">Duration</span><span class="p">()</span> <span class="p">&lt;</span> <span class="nx">minDuration</span> <span class="o">||</span> <span class="nx">dealP</span><span class="p">.</span><span class="nf">Duration</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">maxDuration</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Deal duration out of bounds.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">minPrice</span><span class="p">,</span> <span class="nx">maxPrice</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">StorageDeal_StoragePricePerEpochBounds</span><span class="p">(</span><span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StoragePricePerEpoch</span> <span class="p">&lt;</span> <span class="nx">minPrice</span> <span class="o">||</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StoragePricePerEpoch</span> <span class="p">&gt;</span> <span class="nx">maxPrice</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Storage price out of bounds.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">minProviderCollateral</span><span class="p">,</span> <span class="nx">maxProviderCollateral</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">StorageDeal_ProviderCollateralBounds</span><span class="p">(</span>
		<span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ProviderCollateral</span> <span class="p">&lt;</span> <span class="nx">minProviderCollateral</span> <span class="o">||</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ProviderCollateral</span> <span class="p">&gt;</span> <span class="nx">maxProviderCollateral</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Provider collateral out of bounds.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">minClientCollateral</span><span class="p">,</span> <span class="nx">maxClientCollateral</span> <span class="o">:=</span> <span class="nx">inds</span><span class="p">.</span><span class="nf">StorageDeal_ClientCollateralBounds</span><span class="p">(</span>
		<span class="nx">dealP</span><span class="p">.</span><span class="nx">PieceSize</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">StartEpoch</span><span class="p">,</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">EndEpoch</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ClientCollateral</span> <span class="p">&lt;</span> <span class="nx">minClientCollateral</span> <span class="o">||</span> <span class="nx">dealP</span><span class="p">.</span><span class="nx">ClientCollateral</span> <span class="p">&gt;</span> <span class="nx">maxClientCollateral</span> <span class="p">{</span>
		<span class="nx">rt</span><span class="p">.</span><span class="nf">AbortStateMsg</span><span class="p">(</span><span class="s">&#34;Client collateral out of bounds.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>





<div id="systems__filecoin_markets__storage_market__storage_market_actor__storage_deal_collateral"></div>
<h5 id="storage-deal-collateral">Storage Deal Collateral</h5>
<p>There are two types of Storage Deal Collateral, ProviderDealCollateral and ClientDealCollateral. Both types of <code>StorageDealCollateral</code> are held in the <code>StorageMarketActor</code>.
Their values are agreed upon by the storage provider and client off-chain, but must be greater than a protocol-defined minimum in any deal. Storage providers will choose to offer greater provider deal collateral to signal high-quality storage to clients. Provider deal collateral is only slashed when a sector is terminated other than normal expiration. If a miner enters Temporary Fault for a sector and later recovers from it, no deal collateral will be slashed.</p>
<p>Upon graceful deal expiration, storage providers must wait for finality number of epochs (as defined in <a href="./#algorithms__expected_consensus__finality">EC Finality</a>) before being able to withdraw their <code>StorageDealCollateral</code> from the <code>StorageMarketActor</code>.</p>


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__storage_provider">

<h4 class="section-header">
  Storage Provider
</h4>

<div class="section-content">




































<p>The <code>StorageProvider</code> is a module that handles incoming queries for Asks and proposals for Deals from a <code>StorageClient</code>. It also tracks deals as they move through the deal flow, handling off chain actions during the negotiation phases of the deal and ultimately telling the <code>StorageMarketActor</code> to publish on chain. The <code>StorageProvider</code>'s last action is to handoff a published deal for storage and sealing to the Storage Mining Subsystem. Note that any address registered as a <code>StorageMarketParticipant</code> with the <code>StorageMarketActor</code> can be used with the <code>StorageClient</code>. A single participant can be a client, provider, or both at the same time.</p>
<p>Because most of what a Storage Provider does is respond to actions initiated by a <code>StorageClient</code>, most of its public facing methods relate to getting current status on deals, as opposed to initiating new actions. However, a user of the <code>StorageProvider</code> module can update the current Ask for the provider.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">dt</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/data_transfer&#34;</span>
<span class="kn">import</span> <span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>
<span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="kn">import</span> <span class="nx">smarkact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_market&#34;</span>

<span class="c1">// ProviderLocalDealInfo is the information that a storage provider tracks locally about
</span><span class="c1">// a deal. It contains not only the storage proposal but the state of the deal
</span><span class="c1">// as it moves throught the system. It is persisted to local storage and updated 
</span><span class="c1">// as the deal goes through stages leading up to its being published (and afterward)
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ProviderLocalDealInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ProposalCid</span>   <span class="o">&amp;</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDealProposal</span>
    <span class="nx">Proposal</span>      <span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDealProposal</span>
    <span class="nx">MinerPeerID</span>   <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
    <span class="nx">ClientPeerID</span>  <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
    <span class="nx">Status</span>        <span class="nx">StorageDealStatus</span>

    <span class="nx">PayloadID</span>     <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>

    <span class="nx">DealID</span>        <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span>
    <span class="nx">SectorID</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span>  <span class="c1">// Set when State &gt;= DealStaged
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// The interface provided for storage providers
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">StorageProvider</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">AddAsk</span><span class="p">(</span><span class="nx">price</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">ttlsecs</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// ListAsks lists current asks
</span><span class="c1"></span>    <span class="nf">ListAsks</span><span class="p">(</span><span class="nx">addrress</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="p">[</span><span class="nx">StorageAsk</span><span class="p">]</span>

    <span class="c1">// ListDeals lists on-chain deals associated with this provider
</span><span class="c1"></span>    <span class="nf">ListDeals</span><span class="p">()</span>            <span class="p">(</span><span class="nx">deals</span> <span class="p">[</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">],</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// ListIncompleteDeals lists deals that are in progress or rejected
</span><span class="c1"></span>    <span class="nf">ListIncompleteDeals</span><span class="p">()</span>  <span class="p">(</span><span class="nx">deals</span> <span class="p">[</span><span class="nx">ProviderLocalDealInfo</span><span class="p">],</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// AddStorageCollateral adds storage collateral
</span><span class="c1"></span>    <span class="nf">AddStorageCollateral</span><span class="p">(</span><span class="nx">amount</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="kt">error</span>

    <span class="c1">// GetStorageCollateral returns the current collateral balance
</span><span class="c1"></span>    <span class="nf">GetStorageCollateral</span><span class="p">()</span> <span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// DataTransferValidator methods
</span><span class="c1"></span>    <span class="nf">ValidatePush</span><span class="p">(</span>
        <span class="nx">sender</span>    <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
        <span class="nx">voucher</span>   <span class="nx">dt</span><span class="p">.</span><span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>  <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
        <span class="nx">Selector</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span>
    <span class="nf">ValidatePull</span><span class="p">(</span>
        <span class="nx">receiver</span>  <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
        <span class="nx">voucher</span>   <span class="nx">dt</span><span class="p">.</span><span class="nx">DataTransferVoucher</span>
        <span class="nx">PieceRef</span>  <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
        <span class="nx">Selector</span>  <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>
    <span class="p">)</span>

    <span class="c1">// Data Transfer Listener
</span><span class="c1"></span>    <span class="nf">OnDataTransferEvent</span><span class="p">(</span><span class="nx">event</span> <span class="nx">dt</span><span class="p">.</span><span class="nx">DataTransferEvent</span><span class="p">,</span> <span class="nx">channelState</span> <span class="nx">dt</span><span class="p">.</span><span class="nx">DataTransferState</span><span class="p">)</span>

    <span class="c1">// libp2p listener on storage deal query
</span><span class="c1"></span>    <span class="nf">OnStorageQueryAsk</span><span class="p">(</span><span class="nx">request</span> <span class="nx">AskProtocolRequest</span><span class="p">)</span>
    <span class="nf">OnStorageDealProposal</span><span class="p">(</span><span class="nx">response</span> <span class="nx">DealProtocolRequest</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>





<!-- raw HTML omitted -->


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__storage_market__storage_client">

<h4 class="section-header">
  Storage Client
</h4>

<div class="section-content">




































<p>The <code>StorageClient</code> is a module that discovers miners, determines their asks, and proposes deals to <code>StorageProviders</code>. It also tracks deals as they move through the deal flow. Note that any address registered as a <code>StorageMarketParticipant</code> with the <code>StorageMarketActor</code> can be used with the <code>StorageClient</code>. A single participant can be a client, provider, or both at the same time.</p>
<p>&ndash;</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">message</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_vm/message&#34;</span>
<span class="kn">import</span> <span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>
<span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="kn">import</span> <span class="nx">smarkact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_market&#34;</span>

<span class="c1">// ClientLocalDealInfo is the information about a storage deal that storage client tracks
</span><span class="c1">// locally about a deal until it goes on chain. It is persisted to local storage
</span><span class="c1">// and updated as the deal goes through stages leading up to its being published
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ClientLocalDealInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ProposalCid</span>     <span class="o">&amp;</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDealProposal</span>
    <span class="nx">Proposal</span>        <span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDealProposal</span>
    <span class="nx">State</span>           <span class="nx">StorageDealStatus</span>
    <span class="nx">MinerPeerID</span>     <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
    <span class="nx">MinerWorker</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">DealID</span>          <span class="nx">abi</span><span class="p">.</span><span class="nx">DealID</span>
    <span class="nx">PublishMessage</span>  <span class="o">&amp;</span><span class="nx">message</span><span class="p">.</span><span class="nx">SignedMessage</span>
<span class="p">}</span>

<span class="c1">// ProposeStorageDealResult is the returned data when ProposeStorageDeal
</span><span class="c1">// is called on a storage client
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ProposeStorageDealResult</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ProposalCid</span> <span class="o">&amp;</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDealProposal</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageProviderInfo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Address</span>     <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>  <span class="c1">// actor address
</span><span class="c1"></span>    <span class="nx">SectorSize</span>  <span class="kt">uint64</span>
    <span class="nx">PeerID</span>      <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StorageClient</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// ListProviders queries chain state and returns active storage providers
</span><span class="c1"></span>    <span class="nf">ListProviders</span><span class="p">()</span>   <span class="p">(</span><span class="nx">providers</span> <span class="p">[</span><span class="nx">StorageProviderInfo</span><span class="p">],</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// ListDeals lists on-chain deals associated with this client
</span><span class="c1"></span>    <span class="nf">ListDeals</span><span class="p">()</span>       <span class="p">(</span><span class="nx">deals</span> <span class="p">[</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDeal</span><span class="p">],</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// ListInProgressDeals lists deals that are in progress or rejected
</span><span class="c1"></span>    <span class="c1">// - but not on chain
</span><span class="c1"></span>    <span class="nf">ListLocalDeals</span><span class="p">()</span>  <span class="p">(</span><span class="nx">deals</span> <span class="p">[</span><span class="nx">ClientLocalDealInfo</span><span class="p">],</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// GetInProgressDeal looks up an in progress deal by proposal CID
</span><span class="c1"></span>    <span class="nf">GetInProgressDeal</span><span class="p">(</span><span class="nx">proposalCID</span> <span class="o">&amp;</span><span class="nx">smarkact</span><span class="p">.</span><span class="nx">StorageDealProposal</span><span class="p">)</span> <span class="p">(</span><span class="nx">ClientLocalDealInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// GetAsk returns the current ask for a storage provider
</span><span class="c1"></span>    <span class="nf">GetAsk</span><span class="p">(</span><span class="nx">info</span> <span class="nx">StorageProviderInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">StorageAsk</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// ProposeStorageDeal initiates deal negotiation with a Storage Provider
</span><span class="c1"></span>    <span class="nf">ProposeStorageDeal</span><span class="p">(</span>
        <span class="nx">info</span>                <span class="nx">StorageProviderInfo</span>
        <span class="nx">payloadCid</span>          <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>
        <span class="nx">proposalExpiration</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
        <span class="nx">duration</span>            <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span>
        <span class="nx">price</span>               <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
        <span class="nx">collateral</span>          <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="p">)</span> <span class="p">(</span><span class="nx">ProposeStorageDealResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// GetPaymentEscrow returns the current funds available for deal payment
</span><span class="c1"></span>    <span class="nf">GetPaymentEscrow</span><span class="p">()</span> <span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>

    <span class="c1">// AddPaymentEscrow adds storage collateral
</span><span class="c1"></span>    <span class="nf">AddPaymentEscrow</span><span class="p">(</span><span class="nx">amount</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div>





<!-- raw HTML omitted -->


</div>



</div>

  


</div>

  

  
    








<div id="systems__filecoin_markets__retrieval_market">

<h3 class="section-header">
  Retrieval Market in Filecoin
</h3>

<div class="section-content">




































<h4 id="components">Components</h4>
<p>The <code>retrieval market</code> refers to the process of negotiating deals for a provider to serve stored data to a client.</p>
<p>The main components are as follows:</p>
<ul>
<li>A payment channel actor (See <a href="./#systems__filecoin_token__payment_channels__payment_channel_actor">Payment Channel Actor</a> for details)</li>
<li>2 <code>libp2p</code> services -
<ul>
<li>a protocol for making queries</li>
<li>a protocol for negotiating and carrying out retrieval deals (will disappear as a seperate libp2p protocol as retrieval markets evolve)</li>
</ul>
</li>
<li>A chain-based content routing interface</li>
<li>A client module to query retrieval miners and initiate deals for retrieval</li>
<li>A provider module to respond to queries and deal proposals</li>
</ul>
<h4 id="vo--v1">VO &amp; V1</h4>
<p>V0 of the protocol has participants send data over the retrieval protocol itself in a series of Blocks encoded in Bitswap format and verify received blocks manually. It will only support fetching the payload CID which is at the root of PieceCID&rsquo;s <code>.car</code> File, and will only support fetching the whole DAG.</p>
<p>In V1, the retrieval markets will evolve to support sending arbitrary payload CID&rsquo;s &amp; selectors within a piece. Further, it will piggy back on the Data Transfer system and Graphsync to handle transfer and verification, to support arbitrary selectors, and to reduce round trips.
The Data Transfer System will accordingly be augmented to support pausing/resuming and sending intermediate vouchers to facilitate this.
V1 will also include additional mechanisms for timeouts and cancellations. (to be specified)</p>
<p>Though the underlying protocols will change, the API interfaces for the client &amp; provider will not change from V0 to V1.</p>
<h4 id="deal-flow-v0">Deal Flow (V0)</h4>












<div class="diagram">

<span class="diagram-title">Retrieval Flow - V0</span>




(<a href="docs/systems/filecoin_markets/retrieval_market/retrieval_flow_v0.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_markets/retrieval_market/retrieval_flow_v0.mmd.svg" />




</div>

<p>The baseline version of proposing and accepting a deal will work as follows:</p>
<ul>
<li>The client finds a provider of a given piece with <code>FindProviders()</code>.</li>
<li>The client queries a provider to see if it meets its retrieval criteria (via Query Protocol)</li>
<li>The client sends a RetrievalDealProposal to the retrieval miner. (via RetrievalProtocol)</li>
<li>The provider validates the proposal and rejects it if it is invalid</li>
<li>If the request is valid, the provider responds to it with an accept message</li>
<li>The client creates a payment channel as neccesary and a lane, ensures there are free funds in the channel</li>
<li>The provider unseals the sector as neccesary</li>
<li>The provider sends blocks over the protocol until it requires payment</li>
<li>The client consumes blocks over the retrieval protocol and manually verifies them</li>
<li>When the provider requires payment to proceed, it sends payment request and does not send any more blocks</li>
<li>The client creates and stores a payment voucher off-chain</li>
<li>The client responds to the provider with a reference to the payment voucher</li>
<li>The provider redeems the payment voucher off-chain</li>
<li>The provider resumes sending blocks</li>
<li>The client consumes blocks until payment is required again</li>
<li>The process continues until the end of the query</li>
</ul>
<h4 id="deal-flow-v1">Deal Flow (V1)</h4>












<div class="diagram">

<span class="diagram-title">Retrieval Flow - V1</span>




(<a href="docs/systems/filecoin_markets/retrieval_market/retrieval_flow_v1.mmd.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/systems/filecoin_markets/retrieval_market/retrieval_flow_v1.mmd.svg" />




</div>

<p>The evolved protocol for proposing and accepting a deal will work as follows:</p>
<ul>
<li>The client finds a provider of a given piece with <code>FindProviders()</code>.</li>
<li>The client queries a provider to see if it meets its retrieval criteria (via Query Protocol)</li>
<li>The client schedules a <code>Data Transfer Pull Request</code> passing the <code>RetrievalDealProposal</code> as a voucher.</li>
<li>The provider validates the proposal and rejects it if it is invalid</li>
<li>If the proposal is valid, the provider responds with an accept message and begins monitoring the data transfer process</li>
<li>The client creates a payment channel as necessary and a lane, ensures there are free funds in the channel</li>
<li>The provider unseals the sector as necessary</li>
<li>The provider monitors data transfer as it sends blocks over the protocol, until it requires payment</li>
<li>When the provider requires payment, it pauses the data transfer and sends a request for payment as an intermediate voucher</li>
<li>The client receives the request for payment</li>
<li>The client creates and stores payment voucher off-chain</li>
<li>The client responds to provider with a reference to the payment voucher, sent as an intermediate voucher</li>
<li>The provider redeems the payment voucher off-chain</li>
<li>The provider resumes both the request and sending data</li>
<li>The process continues until the end of the query</li>
</ul>
<h4 id="bootstrapping-trust">Bootstrapping Trust</h4>
<p>Neither the client nor the provider have any specific reason to trust the other. Therefore, payment for a retrieval deal is done incrementally, sending vouchers as bytes are sent and verified.</p>
<p>The trust process is as follows:</p>
<ul>
<li>When the deal is created, client &amp; provider agree to a &ldquo;payment interval&rdquo; in bytes, which is the <em>minimum</em> amount of data the provider will send before each required increment</li>
<li>They also agree to a &ldquo;payment interval increase&rdquo; &ndash; the interval will increase by this value after each successful transfer and payment, as trust develops</li>
<li>Example:
<ul>
<li>If my &ldquo;payment interval&rdquo; is 1000, and my &ldquo;payment interval increase&rdquo; is 300:</li>
<li>The provider must send at least 1000 bytes before it requires any payment (it may send more cause block boundaries are uneven)</li>
<li>The client must pay for all bytes sent when the provider requests payment, if the provider has sent at least 1000 bytes</li>
<li>The provider now must send at least 1300 bytes before it requests payment again</li>
<li>The client must pay for all bytes it hasn&rsquo;t yet paid for when the provider
requests payment, assuming it&rsquo;s received at least 1300 bytes since last payment</li>
<li>The process continues till the end of the retrieval, when the last payment will simply be for the remainder of bytes</li>
</ul>
</li>
<li>Additional trust mechanisms in the V1 version of the protocol will include agreed upon timeouts and cancellation fees</li>
</ul>
<h4 id="common-data-types">Common Data Types</h4>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">ipld</span> <span class="s">&#34;github.com/filecoin-project/specs/libraries/ipld&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>
<span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>

<span class="kd">type</span> <span class="nx">PaymentVoucher</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">RetrievalPeer</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Address</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">ID</span>       <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>  <span class="c1">// optional
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Available</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Unavailable</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Unknown</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">RetrievalQueryResponseStatus</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Available</span>
    <span class="nx">Unavailable</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalQueryItemStatus</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Available</span>
    <span class="nx">Unavailable</span>
    <span class="nx">Unknown</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalQueryParams</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PayloadCID</span>                  <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>  <span class="c1">// optional, query if miner has this cid in this piece. some miners may not be able to respond.
</span><span class="c1"></span>    <span class="nx">Selector</span>                    <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>  <span class="c1">// optional, query if miner has this cid in this piece. some miners may not be able to respond.
</span><span class="c1"></span>    <span class="nx">MaxPricePerByte</span>             <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>  <span class="c1">// optional, tell miner uninterested if more expensive than this
</span><span class="c1"></span>    <span class="nx">MinPaymentInterval</span>          <span class="nx">UInt</span>  <span class="c1">// optional, tell miner uninterested unless payment interval is greater than this
</span><span class="c1"></span>    <span class="nx">MinPaymentIntervalIncrease</span>  <span class="nx">UInt</span>  <span class="c1">// optional, tell miner uninterested unless payment interval increase is greater than this
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalQuery</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PieceCID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceCID</span>  <span class="c1">// V0
</span><span class="c1"></span>    <span class="nx">RetrievalQueryParams</span>  <span class="c1">// V1
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalQueryResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Status</span>                      <span class="nx">RetrievalQueryResponseStatus</span>
    <span class="nx">PayloadCIDFound</span>             <span class="nx">RetrievalQueryItemStatus</span>  <span class="c1">// V1 - if a PayloadCid was requested, the result
</span><span class="c1"></span>    <span class="nx">SelectorFound</span>               <span class="nx">RetrievalQueryItemStatus</span>  <span class="c1">// V1 - if a Selector was requested, the result
</span><span class="c1"></span>
    <span class="nx">Size</span>                        <span class="kt">uint64</span>  <span class="c1">// Total size of piece in bytes
</span><span class="c1"></span>    <span class="nx">ExpectedPayloadSize</span>         <span class="kt">uint64</span>  <span class="c1">// V1 - optional, if PayloadCID + selector are specified and miner knows, can offer an expected size
</span><span class="c1"></span>
    <span class="nx">PaymentAddress</span>              <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>  <span class="c1">// address to send funds to -- may be different than miner addr
</span><span class="c1"></span>    <span class="nx">MinPricePerByte</span>             <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">MaxPaymentInterval</span>          <span class="nx">UInt</span>
    <span class="nx">MaxPaymentIntervalIncrease</span>  <span class="nx">UInt</span>

    <span class="nf">PieceRetrievalPrice</span><span class="p">()</span>  <span class="c1">// == MinPricePerByte * Size
</span><span class="c1"></span>    <span class="nf">PayloadRetrievalPrice</span><span class="p">()</span>  <span class="c1">// V1 - optional == MinPricePerByte * ExpectedPayloadSize
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Accepted</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Failed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Rejected</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Unsealing</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">FundsNeeded</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Ongoing</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">FundsNeededLastPayment</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Completed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DealNotFound</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">DealStatus</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Accepted</span>
    <span class="nx">Failed</span>
    <span class="nx">Rejected</span>
    <span class="nx">Unsealing</span>
    <span class="nx">FundsNeeded</span>
    <span class="nx">Ongoing</span>
    <span class="nx">FundsNeededLastPayment</span>
    <span class="nx">Completed</span>
    <span class="nx">DealNotFound</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalParams</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PayloadCID</span>               <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>  <span class="c1">// V1
</span><span class="c1"></span>    <span class="nx">Selector</span>                 <span class="nx">ipld</span><span class="p">.</span><span class="nx">Selector</span>  <span class="c1">// V1
</span><span class="c1"></span>    <span class="nx">PricePerByte</span>             <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
    <span class="nx">PaymentInterval</span>          <span class="nx">UInt</span>
    <span class="nx">PaymentIntervalIncrease</span>  <span class="nx">UInt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalDealID</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">RetrievalDealProposal</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PieceCID</span>         <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceCID</span>
    <span class="nx">ID</span>               <span class="nx">RetrievalDealID</span>  <span class="c1">// V1 - an identifier for the retrieval
</span><span class="c1"></span>    <span class="nx">RetrievalParams</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Prefix</span>  <span class="nx">Bytes</span>
    <span class="nx">Data</span>    <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalDealResponse</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Status</span>       <span class="nx">DealStatus</span>
    <span class="nx">ID</span>           <span class="nx">RetrievalDealID</span>  <span class="c1">// V1 - an identifier for the retrieval
</span><span class="c1"></span>
    <span class="c1">// payment required to proceed
</span><span class="c1"></span>    <span class="nx">PaymentOwed</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>

    <span class="nx">Message</span>      <span class="kt">string</span>
    <span class="nx">Blocks</span>       <span class="p">[</span><span class="nx">Block</span><span class="p">]</span>  <span class="c1">// V0 only
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalDealPayment</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>              <span class="nx">RetrievalDealID</span>  <span class="c1">// V1 - an identifier for the retrieval
</span><span class="c1"></span>    <span class="nx">PaymentChannel</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="nx">PaymentVoucher</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="systems__filecoin_markets__retrieval_market__retrieval_peer_resolver">

<h4 class="section-header">
  Retrieval Peer Resolver
</h4>

<div class="section-content">




































<p>The <code>peer resolver</code> is a content routing interface to discover retrieval miners that have a given Piece.</p>
<p>It can be backed by both a local store of previous storage deals or by querying the chain.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>

<span class="kd">type</span> <span class="nx">RetrievalPeerResolver</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">GetPeers</span><span class="p">(</span><span class="nx">PieceCID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">)</span> <span class="p">[</span><span class="nx">RetrievalPeer</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_markets__retrieval_market__retrieval_protocols">

<h4 class="section-header">
  Retrieval Protocols
</h4>

<div class="section-content">




































<p>The <code>retrieval market</code> will initially be implemented as two <code>libp2p</code> services.</p>
<ul>
<li><strong>Name</strong>: Query Protocol</li>
<li><strong>Protocol ID V0</strong>: <code>/fil/&lt;network-name&gt;/retrieval/qry/0.0.1</code></li>
<li><strong>Protocol ID V1</strong>: <code>/fil/&lt;network-name&gt;/retrieval/qry/1.0.0</code></li>
</ul>
<p>Request: CBOR Encoded RetrievalQuery Data Structure
Response: CBOR Encoded RetrievalQueryResponse Data Structure</p>
<ul>
<li><strong>Name</strong>: Retrieval Protocol</li>
<li><strong>Protocol ID V0</strong>: <code>/fil/&lt;network-name&gt;/retrieval/0.0.1</code></li>
</ul>
<p>V0:
Request: CBOR Encoded RetrievalDealProposal Data Structure
Response: CBOR Encoded RetrievalDealResponse Data Structure
&ndash; Following
Request: CBOR Encoded RetrievalPayment Data Structure
Response: CBOR Encoded RetrievalDealResponse Data Structure w/ Blocks</p>
<p>V1: Protocol does not exist in this version</p>


</div>



</div>

  

  
    








<div id="systems__filecoin_markets__retrieval_market__retrieval_client">

<h4 class="section-header">
  Retrieval Client
</h4>

<div class="section-content">




































<h5 id="client-dependencies">Client Dependencies</h5>
<p>The Retrieval Client Depends On The Following Dependencies</p>
<ul>
<li><strong>Host</strong>: A libp2p host (set setup the libp2p protocols)</li>
<li><strong>Filecoin Node</strong>: A node implementation to query the chain for pieces and to setup and manage payment channels</li>
<li><strong>BlockStore</strong>: Same as one used by data transfer module</li>
<li><strong>Data Transfer</strong>: V1 only &ndash;Module used for transferring payload. Writes to the blockstore.</li>
</ul>
<h5 id="api">API</h5>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="kn">import</span> <span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>

<span class="kd">type</span> <span class="nx">RetrievalClientDealState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">RetrievalDealProposal</span>
    <span class="nx">Status</span>                 <span class="nx">DealStatus</span>
    <span class="nx">Sender</span>                 <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
    <span class="nx">TotalReceived</span>          <span class="nx">UInt</span>
    <span class="nx">FundsSpent</span>             <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Open</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">FundsExpended</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Progress</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Error</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Complete</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">RetrievalClientEvent</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Open</span>
    <span class="nx">FundsExpended</span>  <span class="c1">// when totalFunds is expended
</span><span class="c1"></span>    <span class="nx">Progress</span>
    <span class="nx">Error</span>
    <span class="nx">Complete</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalClientSubscriber</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">OnEvent</span><span class="p">(</span><span class="nx">event</span> <span class="nx">RetrievalClientEvent</span><span class="p">,</span> <span class="nx">RetrievalClientDealState</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalClient</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// V0
</span><span class="c1"></span>    <span class="nf">FindProviders</span><span class="p">(</span><span class="nx">pieceCID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">)</span> <span class="p">[</span><span class="nx">RetrievalPeer</span><span class="p">]</span>
    <span class="nf">Query</span><span class="p">(</span>
        <span class="nx">p</span>         <span class="nx">RetrievalPeer</span>
        <span class="nx">pieceCID</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceCID</span>
        <span class="nx">params</span>    <span class="nx">RetrievalQueryParams</span>
    <span class="p">)</span> <span class="nx">RetrievalQueryResponse</span>
    <span class="nf">Retrieve</span><span class="p">(</span>
        <span class="nx">pieceCID</span>      <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceCID</span>
        <span class="nx">params</span>        <span class="nx">RetrievalParams</span>
        <span class="nx">totalFunds</span>    <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
        <span class="nx">miner</span>         <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
        <span class="nx">clientWallet</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
        <span class="nx">minerWallet</span>   <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="nx">RetrievalDealID</span>
    <span class="nf">SubscribeToEvents</span><span class="p">(</span><span class="nx">subscriber</span> <span class="nx">RetrievalClientSubscriber</span><span class="p">)</span>

    <span class="c1">// V1
</span><span class="c1"></span>    <span class="nf">AddMoreFunds</span><span class="p">(</span><span class="nx">id</span> <span class="nx">RetrievalDealID</span><span class="p">,</span> <span class="nx">amount</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span> <span class="kt">error</span>
    <span class="nf">CancelDeal</span><span class="p">(</span><span class="nx">id</span> <span class="nx">RetrievalDealID</span><span class="p">)</span> <span class="kt">error</span>
    <span class="nf">RetrievalStatus</span><span class="p">(</span><span class="nx">id</span> <span class="nx">RetrievalDealID</span><span class="p">)</span>
    <span class="nf">ListDeals</span><span class="p">()</span> <span class="p">{</span><span class="nx">RetrievalDealID</span><span class="p">:</span> <span class="nx">RetrievalClientDealState</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  

  
    








<div id="systems__filecoin_markets__retrieval_market__retrieval_provider">

<h4 class="section-header">
  Retrieval Provider (Miner)
</h4>

<div class="section-content">




































<h5 id="provider-dependencies">Provider Dependencies</h5>
<p>The Retrieval Provider Depends On The Following Dependencies</p>
<ul>
<li><strong>Host</strong>: A libp2p host (set setup the libp2p protocols)</li>
<li><strong>Filecoin Node</strong>: A node implementation to query the chain for pieces and to setup and manage payment channels</li>
<li><strong>StorageMining Subsystem</strong>: For unsealing sectors</li>
<li><strong>BlockStore</strong>: Same as one used by data transfer module</li>
<li><strong>Data Transfer</strong>: V1 only &ndash; Module used for transferring payload. Reads from the blockstore.</li>
</ul>
<h5 id="api">API</h5>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>

<span class="kd">type</span> <span class="nx">RetrievalProviderDealState</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">RetrievalDealProposal</span>
    <span class="nx">Status</span>                 <span class="nx">DealStatus</span>
    <span class="nx">Receiver</span>               <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
    <span class="nx">TotalSent</span>              <span class="nx">UInt</span>
    <span class="nx">FundsReceived</span>          <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalProviderEvent</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Open</span>
    <span class="nx">Progress</span>
    <span class="nx">Error</span>
    <span class="nx">Complete</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalProviderDealID</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">From</span>  <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>
    <span class="nx">ID</span>    <span class="nx">RetrievalDealID</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalProviderSubscriber</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">OnEvent</span><span class="p">(</span><span class="nx">event</span> <span class="nx">RetrievalProviderEvent</span><span class="p">,</span> <span class="nx">RetrievalProviderDealState</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">RetrievalProvider</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// V0
</span><span class="c1"></span>    <span class="nf">SetPricePerByte</span><span class="p">(</span><span class="nx">price</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
    <span class="nf">SetPaymentInterval</span><span class="p">(</span><span class="nx">paymentInterval</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">paymentIntervalIncrease</span> <span class="nx">UInt</span><span class="p">)</span>
    <span class="nf">SubscribeToEvents</span><span class="p">(</span><span class="nx">subscriber</span> <span class="nx">RetrievalProviderSubscriber</span><span class="p">)</span>

    <span class="c1">// V1
</span><span class="c1"></span>    <span class="nf">SetPricePerUnseal</span><span class="p">(</span><span class="nx">price</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">TokenAmount</span><span class="p">)</span>
    <span class="nf">ListDeals</span><span class="p">()</span> <span class="p">{</span><span class="nx">RetrievalProviderDealID</span><span class="p">:</span> <span class="nx">RetrievalProviderDealState</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  


</div>

  


</div>

  

  
    








<div id="libraries">

<h1 class="section-header">
  Libraries used in Filecoin
</h1>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries">
        

        Libraries

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__filcrypto">
        

        Filcrypto

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__filcrypto__filproofs">
        

        filproofs

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  















<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__fcs">
        

        FCS

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld">
        

        IPLD

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__cid">
        

        CID

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__datamodel">
        

        Data Model

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipld__selectors">
        

        Selectors

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p">
        

        libp2p

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p__gossipsub">
        

        gossipsub

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p__kad_dht">
        

        kad-dht

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  











  




    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__libp2p__fil_libp2p_nodes">
        

        fil-libp2p Nodes

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs">
        

        IPFS

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs__bitswap">
        

        BitSwap

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs__graphsync">
        

        GraphSync

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
                
                  














    


<div class="tocMap-item ">
    <div class="tocMap-item-label">
        <a href="./#libraries__ipfs__unixfs">
        

        UnixFS

        
        </a>
    </div>

    <div class="tocMap-children">
        
    </div>
</div>

                
            
        
    </div>
</div>

                
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__multiformats">
        

        Multiformats

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>



</div>


  
    








<div id="libraries__filcrypto">

<h2 class="section-header">
  Cryptographic libraries used in Filecoin
</h2>

<div class="section-content">





































<div class="tocMap ">


  
  
    











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__filcrypto">
        

        Filcrypto

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
                
                  











  





<div class="tocMap-item expanded">
    <div class="tocMap-item-label">
        <a href="./#libraries__filcrypto__filproofs">
        

        filproofs

        
        </a>
    </div>

    <div class="tocMap-children">
        
            
        
    </div>
</div>

                
            
        
    </div>
</div>

  

</div>



</div>


  
    








<div id="libraries__filcrypto__filproofs">

<h3 class="section-header">
  filproofs - Filecoin Storage Proofs
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>

<span class="kd">type</span> <span class="nx">SectorInfo</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Block</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">SectorID</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="kd">type</span> <span class="nx">FilecoinProofsSubsystem</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sealVerifyInfo</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">ValidateBlock</span><span class="p">(</span><span class="nx">block</span> <span class="nx">Block</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
<span class="kn">import</span> <span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
<span class="kn">import</span> <span class="nx">sectorIndex</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector_index&#34;</span>

<span class="kd">type</span> <span class="nx">WinStackedDRGLayers</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGNodeSize</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGNodes</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGWindowCount</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGPartitions</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGChallenges</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">WinStackedDRGWindowChallenges</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">PoStLeafChallengeCount</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">PoStChallengeRangeSize</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">DRGDepth</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGFraction</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGDegree</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">DRGSeed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGNodeCount</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ExpanderGraphNodeCount</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ChungExpanderPermutationFeistelKeys</span> <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="kd">type</span> <span class="nx">ChungExpanderPermutationFeistelRounds</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ChungExpanderPermutationFeistelHashFunction</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">Blake2S</span>
    <span class="nx">SHA256</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">ChungExpanderAlpha</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">ChungExpanderBeta</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">ExpanderGraphDegree</span> <span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">ExpanderGraphSeed</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">DRGNodeSize</span> <span class="nx">UInt</span>

<span class="kd">type</span> <span class="nx">SealAlgorithmArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">AlgorithmWideSetupArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// trusted setup output parameters go here
</span><span class="c1"></span>        <span class="c1">// updates to public parameters go here
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="nx">SealSetupArtifacts</span>

    <span class="c1">// ProveArtifacts or
</span><span class="c1"></span>    <span class="nx">ChallengeArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// inputs into prove() go here
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="nx">VerifyArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="c1">// inputs into verify() go here
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// per-sector setup artifacts go here
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealSetupArtifacts</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">CommD</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommR</span>              <span class="nx">abi</span><span class="p">.</span><span class="nx">SealedSectorCID</span>
    <span class="nx">CommC</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommQ</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommRLast</span>          <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="nx">CommDTreePath</span>      <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">CommCTreePath</span>      <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">CommQTreePath</span>      <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">CommRLastTreePath</span>  <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span>
    <span class="nx">Seed</span>               <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span>
    <span class="nx">KeyLayers</span>          <span class="p">[</span><span class="nx">Bytes</span><span class="p">]</span>
    <span class="nx">Replica</span>            <span class="nx">Bytes</span>  <span class="c1">// This is what we challenge in PoSt. It will be regenerated just in time. Should probably be removed from here.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">EllipticCurve</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">FieldModulus</span> <span class="o">&amp;</span><span class="nx">util</span><span class="p">.</span><span class="nx">BigInt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">WinStackedDRG</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Layers</span>                  <span class="nx">WinStackedDRGLayers</span>
    <span class="nx">NodeSize</span>                <span class="nx">WinStackedDRGNodeSize</span>
    <span class="nx">Nodes</span>                   <span class="nx">WinStackedDRGNodes</span>
    <span class="nx">WindowCount</span>             <span class="nx">WinStackedDRGWindowCount</span>
    <span class="nx">Partitions</span>              <span class="nx">WinStackedDRGPartitions</span>
    <span class="nx">Challenges</span>              <span class="nx">WinStackedDRGChallenges</span>
    <span class="nx">WindowChallenges</span>        <span class="nx">WinStackedDRGWindowChallenges</span>
    <span class="nx">Algorithm</span>               <span class="kd">struct</span> <span class="p">{}</span>
    <span class="nx">DRGCfg</span>
    <span class="nx">ExpanderGraphCfg</span>
    <span class="nx">WindowDRGCfg</span>            <span class="nx">DRGCfg</span>
    <span class="nx">WindowExpanderGraphCfg</span>  <span class="nx">ExpanderGraphCfg</span>
    <span class="c1">// invariant: DRGCfg.Nodes == ExpanderGraphCfg.Nodes
</span><span class="c1"></span>    <span class="nx">Curve</span>                   <span class="nx">EllipticCurve</span>
    <span class="nx">RegisteredProof</span>         <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span>
    <span class="nx">Cfg</span>                     <span class="nx">SealInstanceCfg</span>

    <span class="nf">Drg</span><span class="p">()</span>                   <span class="nx">DRG</span>
    <span class="nf">Expander</span><span class="p">()</span>              <span class="nx">ExpanderGraph</span>

    <span class="nf">WindowDrg</span><span class="p">()</span>             <span class="nx">DRG</span>
    <span class="nf">WindowExpander</span><span class="p">()</span>        <span class="nx">ExpanderGraph</span>

    <span class="nf">Seal</span><span class="p">(</span>
        <span class="nx">registeredProof</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span>
        <span class="nx">sid</span>              <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span>
        <span class="nx">data</span>             <span class="nx">Bytes</span>
        <span class="nx">randomness</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">SealRandomness</span>
    <span class="p">)</span> <span class="nx">SealSetupArtifacts</span>
    <span class="nf">CreateSealProof</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span>
        <span class="nx">aux</span>            <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span>
    <span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SealProof</span>
    <span class="nf">CreatePrivateSealProof</span><span class="p">(</span>
        <span class="nx">randomness</span>  <span class="nx">abi</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span>
        <span class="nx">aux</span>         <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span>
    <span class="p">)</span> <span class="nx">PrivateOfflineProof</span>

    <span class="nf">CreateOfflineCircuitProof</span><span class="p">(</span>
        <span class="nx">challengeProofs</span>  <span class="p">[</span><span class="nx">OfflineWindowProof</span><span class="p">]</span>
        <span class="nx">aux</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span>
    <span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SealProof</span>
    <span class="nf">VerifyPrivateSealProof</span><span class="p">(</span>
        <span class="nx">privateProof</span>  <span class="p">[</span><span class="nx">OfflineWindowProof</span><span class="p">]</span>
        <span class="nx">sealSeeds</span>     <span class="p">[</span><span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">]</span>
        <span class="nx">randomness</span>    <span class="nx">abi</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span>
        <span class="nx">commD</span>         <span class="nx">Commitment</span>
        <span class="nx">commR</span>         <span class="nx">abi</span><span class="p">.</span><span class="nx">SealedSectorCID</span>
    <span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">GenerateElectionPoStCandidates</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>    <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">eligibleSectors</span>  <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span>
        <span class="nx">candidateCount</span>   <span class="kt">int</span>
        <span class="nx">sectorStore</span>      <span class="nx">sectorIndex</span><span class="p">.</span><span class="nx">SectorStore</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>
    <span class="nf">CreateElectionPoStProof</span><span class="p">(</span><span class="nx">privateProofs</span> <span class="p">[</span><span class="nx">PrivatePoStProof</span><span class="p">])</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span>
    <span class="nf">VerifyElectionPoSt</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">GenerateSurprisePoStCandidates</span><span class="p">(</span>
        <span class="nx">challengeSeed</span>    <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">eligibleSectors</span>  <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorNumber</span><span class="p">]</span>
        <span class="nx">candidateCount</span>   <span class="kt">int</span>
        <span class="nx">sectorStore</span>      <span class="nx">sectorIndex</span><span class="p">.</span><span class="nx">SectorStore</span>
    <span class="p">)</span> <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>
    <span class="nf">CreateSurprisePoStProof</span><span class="p">(</span><span class="nx">privateProofs</span> <span class="p">[</span><span class="nx">PrivatePoStProof</span><span class="p">])</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span>
    <span class="nf">VerifySurprisePoSt</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span>
    <span class="nf">CreatePrivatePoStProof</span><span class="p">(</span>
        <span class="nx">candidateProofs</span>  <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span><span class="p">]</span>
        <span class="nx">challengeSeed</span>    <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
        <span class="nx">aux</span>              <span class="nx">sector</span><span class="p">.</span><span class="nx">PersistentProofAux</span>
    <span class="p">)</span> <span class="nx">PrivatePoStProof</span>
    <span class="nf">VerifyPrivatePoStProof</span><span class="p">(</span>
        <span class="nx">privateProof</span>  <span class="nx">PrivatePoStProof</span>
        <span class="nx">candidates</span>    <span class="p">[</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">]</span>
        <span class="nx">commRLast</span>     <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
    <span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SealVerifier</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SealCfg</span> <span class="nx">SealInstanceCfg</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PoStVerifier</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PoStCfg</span> <span class="nx">PoStInstanceCfg</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DRGCfg</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Algorithm</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Depth</span>     <span class="nx">DRGDepth</span>  <span class="c1">// D
</span><span class="c1"></span>        <span class="nx">Fraction</span>  <span class="nx">DRGFraction</span>  <span class="c1">// E
</span><span class="c1"></span>
        <span class="nx">ParentsAlgorithm</span> <span class="nx">enum</span> <span class="p">{</span>
            <span class="nx">DRSample</span>
        <span class="p">}</span>

        <span class="nx">RNGAlgorithm</span> <span class="nx">enum</span> <span class="p">{</span>
            <span class="nx">ChaCha20</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">Degree</span> <span class="nx">DRGDegree</span>
    <span class="nx">Seed</span> <span class="nx">DRGSeed</span>
    <span class="nx">Nodes</span> <span class="nx">DRGNodeCount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">DRG</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Config</span>         <span class="nx">DRGCfg</span>
    <span class="nf">Parents</span><span class="p">(</span><span class="nx">UInt</span><span class="p">)</span>  <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ExpanderGraphCfg</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Algorithm</span> <span class="nx">union</span> <span class="p">{</span>
        <span class="nx">ChungExpanderAlgorithm</span>
    <span class="p">}</span>

    <span class="nx">Degree</span>  <span class="nx">ExpanderGraphDegree</span>
    <span class="nx">Seed</span>    <span class="nx">ExpanderGraphSeed</span>
    <span class="nx">Nodes</span>   <span class="nx">ExpanderGraphNodeCount</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ExpanderGraph</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Config</span>         <span class="nx">ExpanderGraphCfg</span>
    <span class="nf">Parents</span><span class="p">(</span><span class="nx">UInt</span><span class="p">)</span>  <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ChungExpanderAlgorithm</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Alpha</span>  <span class="nx">ChungExpanderAlpha</span>
    <span class="nx">Beta</span>   <span class="nx">ChungExpanderBeta</span>
    <span class="nx">PermutationAlgorithm</span> <span class="nx">union</span> <span class="p">{</span>
        <span class="nx">Feistel</span>
    <span class="p">}</span>
    <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">ExpanderGraphDegree</span><span class="p">,</span> <span class="nx">nodes</span> <span class="nx">ExpanderGraphNodeCount</span><span class="p">)</span> <span class="p">[</span><span class="nx">UInt</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Feistel</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Keys</span>          <span class="nx">ChungExpanderPermutationFeistelKeys</span>
    <span class="nx">Rounds</span>        <span class="nx">ChungExpanderPermutationFeistelRounds</span>
    <span class="nx">HashFunction</span>  <span class="nx">ChungExpanderPermutationFeistelHashFunction</span>
    <span class="nf">Permute</span><span class="p">(</span><span class="nx">size</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">n</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">UInt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MerkleTree</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">InclusionProof</span>
    <span class="nf">Leaf</span><span class="p">(</span><span class="nx">index</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">Bytes</span>
<span class="p">}</span>

<span class="c1">// TODO: Needs to be generic over hash.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">InclusionProof</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nf">Leaf</span><span class="p">()</span>       <span class="nx">Bytes</span>
    <span class="nf">LeafIndex</span><span class="p">()</span>  <span class="nx">UInt</span>
    <span class="nf">Root</span><span class="p">()</span>       <span class="nx">Commitment</span>
    <span class="nf">Verify</span><span class="p">(</span><span class="nx">root</span> <span class="nx">Bytes</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProofRegistry</span> <span class="p">{</span><span class="nx">UInt</span><span class="p">:</span> <span class="nx">ProofInstance</span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProofInstance</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// FIXME: move some or all of these types into filproofs.
</span><span class="c1"></span>    <span class="nx">ID</span>           <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span>
    <span class="nx">Type</span>         <span class="nx">ProofType</span>
    <span class="nx">Algorithm</span>    <span class="nx">ProofAlgorithm</span>
    <span class="nx">CircuitType</span>  <span class="nx">ConcreteCircuit</span>
    <span class="nx">Partitions</span>   <span class="nx">UInt</span>
    <span class="nx">Cfg</span>          <span class="nx">ProofCfg</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ConcreteCircuit</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Name must be globally unique. It will be a hash derived from semantic content of circuit.
</span><span class="c1"></span>    <span class="nx">Name</span>                      <span class="kt">string</span>
    <span class="nf">GrothParameterFileName</span><span class="p">()</span>  <span class="kt">string</span>
    <span class="nf">VerifyingKeyFileName</span><span class="p">()</span>    <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProofCfg</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">SealCfg</span>  <span class="nx">SealInstanceCfg</span>
    <span class="nx">PoStCfg</span>  <span class="nx">PoStInstanceCfg</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProofType</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">SealProof</span>
    <span class="nx">PoStProof</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProofAlgorithm</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">StackedDRGSeal</span>
    <span class="nx">WinStackedDRGSeal</span>
    <span class="nx">StackedDRGPoSt</span>
    <span class="nx">WinStackedDRGPoSt</span>
<span class="p">}</span>

<span class="c1">// New proof ProofInstances can add new cfg types if needed.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">SealInstanceCfg</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">WinStackedDRGCfgV1</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">WinStackedDRGCfgV1</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">SectorSize</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span>
    <span class="nx">WindowCount</span>  <span class="nx">UInt</span>
<span class="p">}</span>

<span class="c1">// New proof ProofInstances can add new cfg types if needed.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">PoStInstanceCfg</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">PoStCfgV1</span>
    <span class="nx">PoStCfgVBogus</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PoStCfgV1</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Type</span>                <span class="nx">PoStType</span>
    <span class="nx">Nodes</span>               <span class="nx">UInt</span>
    <span class="nx">Partitions</span>          <span class="nx">UInt</span>
    <span class="nx">LeafChallengeCount</span>  <span class="nx">UInt</span>
    <span class="nx">ChallengeRangeSize</span>  <span class="nx">UInt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PoStCfgVBogus</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Type</span>                 <span class="nx">PoStType</span>
    <span class="nx">Nodes</span>                <span class="nx">UInt</span>
    <span class="nx">Partitions</span>           <span class="nx">UInt</span>
    <span class="nx">QuantumMonkeyBrains</span>  <span class="nx">UInt</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PoStType</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">ElectionPoSt</span>
    <span class="nx">SurprisePoSt</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">filproofs</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;errors&#34;</span>
	<span class="s">&#34;fmt&#34;</span>
	<span class="s">&#34;math&#34;</span>
	<span class="s">&#34;math/rand&#34;</span>

	<span class="s">&#34;encoding/binary&#34;</span>
	<span class="nx">big</span> <span class="s">&#34;math/big&#34;</span>

	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">file</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_files/file&#34;</span>
	<span class="nx">sector</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector&#34;</span>
	<span class="nx">sector_index</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_mining/sector_index&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
	<span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Bytes32</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="kd">type</span> <span class="nx">UInt</span> <span class="p">=</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UInt</span>
<span class="kd">type</span> <span class="nx">PieceInfo</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfo</span>
<span class="kd">type</span> <span class="nx">Label</span> <span class="nx">Bytes32</span>
<span class="kd">type</span> <span class="nx">Commitment</span> <span class="p">=</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">Commitment</span>
<span class="kd">type</span> <span class="nx">PrivatePostCandidateProof</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span>
<span class="kd">type</span> <span class="nx">SectorSize</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span>
<span class="kd">type</span> <span class="nx">RegisteredProof</span> <span class="p">=</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span>

<span class="kd">const</span> <span class="nx">WRAPPER_LAYER_WINDOW_INDEX</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="kd">const</span> <span class="nx">NODE_SIZE</span> <span class="p">=</span> <span class="mi">32</span>
<span class="kd">const</span> <span class="nx">ELECTION_POST_PARTITIONS</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">const</span> <span class="nx">SURPRISE_POST_PARTITIONS</span> <span class="p">=</span> <span class="mi">1</span>
<span class="kd">const</span> <span class="nx">POST_LEAF_CHALLENGE_COUNT</span> <span class="p">=</span> <span class="mi">66</span>
<span class="kd">const</span> <span class="nx">POST_CHALLENGE_RANGE_SIZE</span> <span class="p">=</span> <span class="mi">1</span>

<span class="kd">const</span> <span class="nx">GIB_32</span> <span class="p">=</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span>

<span class="kd">var</span> <span class="nx">PROOFS</span> <span class="nx">ProofRegistry</span> <span class="p">=</span> <span class="nf">ProofRegistry</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">util</span><span class="p">.</span><span class="nx">UInt</span><span class="p">]</span><span class="nx">ProofInstance</span><span class="p">{</span><span class="nx">util</span><span class="p">.</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_WinStackedDRG32GiBSeal</span><span class="p">):</span> <span class="o">&amp;</span><span class="nx">ProofInstance_I</span><span class="p">{</span>
	<span class="nx">ID_</span><span class="p">:</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_WinStackedDRG32GiBSeal</span><span class="p">,</span>
	<span class="nx">Type_</span><span class="p">:</span> <span class="nx">ProofType_SealProof</span><span class="p">,</span>
	<span class="nx">CircuitType_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">ConcreteCircuit_I</span><span class="p">{</span>
		<span class="nx">Name_</span><span class="p">:</span> <span class="s">&#34;HASHOFCIRCUITPARAMETERS1&#34;</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">},</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_WinStackedDRG32GiBPoSt</span><span class="p">):</span> <span class="o">&amp;</span><span class="nx">ProofInstance_I</span><span class="p">{</span>
		<span class="nx">ID_</span><span class="p">:</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_WinStackedDRG32GiBPoSt</span><span class="p">,</span>
		<span class="nx">Type_</span><span class="p">:</span> <span class="nx">ProofType_PoStProof</span><span class="p">,</span>
		<span class="nx">CircuitType_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">ConcreteCircuit_I</span><span class="p">{</span>
			<span class="nx">Name_</span><span class="p">:</span> <span class="s">&#34;HASHOFCIRCUITPARAMETERS2&#34;</span><span class="p">,</span>
		<span class="p">},</span>
		<span class="nx">Cfg_</span><span class="p">:</span> <span class="nf">ProofCfg_Make_PoStCfg</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">PoStInstanceCfg_I</span><span class="p">{}),</span>
		<span class="c1">// FIXME: integrate
</span><span class="c1"></span>		<span class="c1">// return sector.PoStInstanceCfg_Make_PoStCfgV1(&amp;sector.PoStCfgV1_I{
</span><span class="c1"></span>		<span class="c1">// 	Type_:               pType,
</span><span class="c1"></span>		<span class="c1">// 	Nodes_:              nodes,
</span><span class="c1"></span>		<span class="c1">// 	Partitions_:         partitions,
</span><span class="c1"></span>		<span class="c1">// 	LeafChallengeCount_: POST_LEAF_CHALLENGE_COUNT,
</span><span class="c1"></span>		<span class="c1">// 	ChallengeRangeSize_: POST_CHALLENGE_RANGE_SIZE,
</span><span class="c1"></span>		<span class="c1">// }).Impl()
</span><span class="c1"></span>
	<span class="p">},</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_StackedDRG32GiBSeal</span><span class="p">):</span> <span class="o">&amp;</span><span class="nx">ProofInstance_I</span><span class="p">{</span>
		<span class="nx">ID_</span><span class="p">:</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_StackedDRG32GiBSeal</span><span class="p">,</span>
		<span class="nx">Type_</span><span class="p">:</span> <span class="nx">ProofType_SealProof</span><span class="p">,</span>
		<span class="nx">CircuitType_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">ConcreteCircuit_I</span><span class="p">{</span>
			<span class="nx">Name_</span><span class="p">:</span> <span class="s">&#34;HASHOFCIRCUITPARAMETERS3&#34;</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_StackedDRG32GiBPoSt</span><span class="p">):</span> <span class="o">&amp;</span><span class="nx">ProofInstance_I</span><span class="p">{</span>
		<span class="nx">ID_</span><span class="p">:</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_StackedDRG32GiBPoSt</span><span class="p">,</span>
		<span class="nx">Type_</span><span class="p">:</span> <span class="nx">ProofType_PoStProof</span><span class="p">,</span>
		<span class="nx">CircuitType_</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">ConcreteCircuit_I</span><span class="p">{</span>
			<span class="nx">Name_</span><span class="p">:</span> <span class="s">&#34;HASHOFCIRCUITPARAMETERS4&#34;</span><span class="p">,</span>
		<span class="p">},</span>
	<span class="p">},</span>
<span class="p">})</span>

<span class="kd">func</span> <span class="nf">RegisteredProofInstance</span><span class="p">(</span><span class="nx">r</span> <span class="nx">RegisteredProof</span><span class="p">)</span> <span class="nx">ProofInstance</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">PROOFS</span><span class="p">[</span><span class="nx">util</span><span class="p">.</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">r</span><span class="p">)]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConcreteCircuit_I</span><span class="p">)</span> <span class="nf">GrothParameterFileName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Name</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;.params&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">ConcreteCircuit_I</span><span class="p">)</span> <span class="nf">VerifyingKeyFileName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Name</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;.vk&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cfg</span> <span class="o">*</span><span class="nx">SealInstanceCfg_I</span><span class="p">)</span> <span class="nf">SectorSize</span><span class="p">()</span> <span class="nx">SectorSize</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">cfg</span><span class="p">.</span><span class="nf">Which</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SealInstanceCfg_Case_WinStackedDRGCfgV1</span><span class="p">:</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="nx">cfg</span><span class="p">.</span><span class="nf">As_WinStackedDRGCfgV1</span><span class="p">().</span><span class="nf">SectorSize</span><span class="p">()</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">PoStCfg</span><span class="p">(</span><span class="nx">pType</span> <span class="nx">PoStType</span><span class="p">,</span> <span class="nx">sectorSize</span> <span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">partitions</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">RegisteredProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_WinStackedDRG32GiBPoSt</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">MakeSealVerifier</span><span class="p">(</span><span class="nx">registeredProof</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span><span class="p">)</span> <span class="o">*</span><span class="nx">SealVerifier_I</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">SealVerifier_I</span><span class="p">{</span>
		<span class="nx">SealCfg_</span><span class="p">:</span> <span class="nf">RegisteredProofInstance</span><span class="p">(</span><span class="nx">registeredProof</span><span class="p">).</span><span class="nf">Cfg</span><span class="p">().</span><span class="nf">As_SealCfg</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SurprisePoStCfg</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">SectorSize</span><span class="p">)</span> <span class="nx">RegisteredProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">PoStCfg</span><span class="p">(</span><span class="nx">PoStType_SurprisePoSt</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">SURPRISE_POST_PARTITIONS</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ElectionPoStCfg</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">SectorSize</span><span class="p">)</span> <span class="nx">RegisteredProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">PoStCfg</span><span class="p">(</span><span class="nx">PoStType_ElectionPoSt</span><span class="p">,</span> <span class="nx">sectorSize</span><span class="p">,</span> <span class="nx">ELECTION_POST_PARTITIONS</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">MakeElectionPoStVerifier</span><span class="p">(</span><span class="nx">registeredProof</span> <span class="nx">RegisteredProof</span><span class="p">)</span> <span class="o">*</span><span class="nx">PoStVerifier_I</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">PoStVerifier_I</span><span class="p">{</span>
		<span class="nx">PoStCfg_</span><span class="p">:</span> <span class="nf">RegisteredProofInstance</span><span class="p">(</span><span class="nx">registeredProof</span><span class="p">).</span><span class="nf">Cfg</span><span class="p">().</span><span class="nf">As_PoStCfg</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">MakeSurprisePoStVerifier</span><span class="p">(</span><span class="nx">registeredProof</span> <span class="nx">RegisteredProof</span><span class="p">)</span> <span class="o">*</span><span class="nx">PoStVerifier_I</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">PoStVerifier_I</span><span class="p">{</span>
		<span class="nx">PoStCfg_</span><span class="p">:</span> <span class="nf">RegisteredProofInstance</span><span class="p">(</span><span class="nx">registeredProof</span><span class="p">).</span><span class="nf">Cfg</span><span class="p">().</span><span class="nf">As_PoStCfg</span><span class="p">(),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">)</span> <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="nx">config</span> <span class="o">:=</span> <span class="nx">drg</span><span class="p">.</span><span class="nf">Config</span><span class="p">()</span>
	<span class="nx">degree</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nf">Degree</span><span class="p">())</span>
	<span class="k">return</span> <span class="nf">DRGAlgorithmComputeParents</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nf">Algorithm</span><span class="p">().</span><span class="nf">ParentsAlgorithm</span><span class="p">(),</span> <span class="nx">degree</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// TODO: Verify this. Both the port from impl and the algorithm.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DRGAlgorithmComputeParents</span><span class="p">(</span><span class="nx">alg</span> <span class="nx">DRGCfg_Algorithm_ParentsAlgorithm</span><span class="p">,</span> <span class="nx">degree</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">node</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">(</span><span class="nx">parents</span> <span class="p">[]</span><span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">alg</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">DRGCfg_Algorithm_ParentsAlgorithm_DRSample</span><span class="p">:</span>
		<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">node</span> <span class="p">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">node</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

		<span class="nx">m</span> <span class="o">:=</span> <span class="nx">degree</span> <span class="o">-</span> <span class="mi">1</span>

		<span class="kd">var</span> <span class="nx">k</span> <span class="nx">UInt</span>
		<span class="k">for</span> <span class="nx">k</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="p">&lt;</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">logi</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Floor</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Log2</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span> <span class="nx">m</span><span class="p">))))</span>
			<span class="c1">// FIXME: Make RNG parameterizable and specify it.
</span><span class="c1"></span>			<span class="nx">j</span> <span class="o">:=</span> <span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">logi</span><span class="p">)</span>
			<span class="nx">jj</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Min</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">node</span><span class="o">*</span><span class="nx">m</span><span class="o">+</span><span class="nx">k</span><span class="p">),</span> <span class="nb">float64</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="nb">uint</span><span class="p">(</span><span class="nx">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
			<span class="nx">backDist</span> <span class="o">:=</span> <span class="nf">randInRange</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Max</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">jj</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
			<span class="nx">out</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">node</span><span class="o">*</span><span class="nx">m</span> <span class="o">+</span> <span class="nx">k</span> <span class="o">-</span> <span class="nx">backDist</span><span class="p">)</span> <span class="o">/</span> <span class="nx">m</span>

			<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">out</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nx">parents</span>

	<span class="k">default</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;DRG algorithm not supported: %v&#34;</span><span class="p">,</span> <span class="nx">alg</span><span class="p">))</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">randInRange</span><span class="p">(</span><span class="nx">lowInclusive</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">highExclusive</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="c1">// NOTE: current implementation uses a more sophisticated method for repeated sampling within a range.
</span><span class="c1"></span>	<span class="c1">// We need to converge on and fully specify the actual method, since this must be deterministic.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="nx">highExclusive</span><span class="o">-</span><span class="nx">lowInclusive</span><span class="p">)</span> <span class="o">+</span> <span class="nx">lowInclusive</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">exp</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">)</span> <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">exp</span><span class="p">.</span><span class="nf">Config</span><span class="p">().</span><span class="nf">Degree</span><span class="p">()</span>

	<span class="c1">// TODO: How do we handle choice of algorithm generically?
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">exp</span><span class="p">.</span><span class="nf">Config</span><span class="p">().</span><span class="nf">Algorithm</span><span class="p">().</span><span class="nf">As_ChungExpanderAlgorithm</span><span class="p">().</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">exp</span><span class="p">.</span><span class="nf">Config</span><span class="p">().</span><span class="nf">Nodes</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chung</span> <span class="o">*</span><span class="nx">ChungExpanderAlgorithm_I</span><span class="p">)</span> <span class="nf">Parents</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">d</span> <span class="nx">ExpanderGraphDegree</span><span class="p">,</span> <span class="nx">nodes</span> <span class="nx">ExpanderGraphNodeCount</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">parents</span> <span class="p">[]</span><span class="nx">UInt</span>
	<span class="kd">var</span> <span class="nx">i</span> <span class="nx">UInt</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">d</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">parent</span> <span class="o">:=</span> <span class="nx">chung</span><span class="p">.</span><span class="nf">_ithParent</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">d</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">)</span>
		<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">parent</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">parents</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chung</span> <span class="o">*</span><span class="nx">ChungExpanderAlgorithm_I</span><span class="p">)</span> <span class="nf">_ithParent</span><span class="p">(</span><span class="nx">node</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">i</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">degree</span> <span class="nx">ExpanderGraphDegree</span><span class="p">,</span> <span class="nx">nodes</span> <span class="nx">ExpanderGraphNodeCount</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="c1">// ithParent generates one of d parents of node.
</span><span class="c1"></span>	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">degree</span><span class="p">)</span>

	<span class="c1">// This is done by operating on permutations of a set with d elements per node.
</span><span class="c1"></span>	<span class="nx">setSize</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">nodes</span><span class="p">)</span> <span class="o">*</span> <span class="nx">d</span>

	<span class="c1">// There are d ways of mapping each node into the set, and we choose the ith.
</span><span class="c1"></span>	<span class="c1">// Note that we can project the element back to the original node: element / d == node.
</span><span class="c1"></span>	<span class="nx">element</span> <span class="o">:=</span> <span class="nx">node</span><span class="o">*</span><span class="nx">d</span> <span class="o">+</span> <span class="nx">i</span>

	<span class="c1">// Permutations of the d elements corresponding to each node yield d new elements,
</span><span class="c1"></span>	<span class="nx">permuted</span> <span class="o">:=</span> <span class="nx">chung</span><span class="p">.</span><span class="nf">PermutationAlgorithm</span><span class="p">().</span><span class="nf">As_Feistel</span><span class="p">().</span><span class="nf">Permute</span><span class="p">(</span><span class="nx">setSize</span><span class="p">,</span> <span class="nx">element</span><span class="p">)</span>

	<span class="c1">// each of which can be projected back to a node.
</span><span class="c1"></span>	<span class="nx">projected</span> <span class="o">:=</span> <span class="nx">permuted</span> <span class="o">/</span> <span class="nx">d</span>

	<span class="c1">// We have selected the ith such parent of node.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">projected</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Feistel_I</span><span class="p">)</span> <span class="nf">Permute</span><span class="p">(</span><span class="nx">size</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">i</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="c1">// Call into feistel.go.
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getProverID</span><span class="p">(</span><span class="nx">minerID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ActorID</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="c1">// return leb128(minerID)
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">computeSealSeed</span><span class="p">(</span><span class="nx">sid</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SealRandomness</span><span class="p">,</span> <span class="nx">commD</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">)</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span> <span class="p">{</span>
	<span class="nx">proverId</span> <span class="o">:=</span> <span class="nf">getProverID</span><span class="p">(</span><span class="nx">sid</span><span class="p">.</span><span class="nx">Miner</span><span class="p">)</span>
	<span class="nx">sectorNumber</span> <span class="o">:=</span> <span class="nx">sid</span><span class="p">.</span><span class="nx">Number</span>

	<span class="kd">var</span> <span class="nx">preimage</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">proverId</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">bigEndianBytesFromUInt</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">sectorNumber</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">randomness</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">Commitment_UnsealedSectorCID</span><span class="p">(</span><span class="nx">commD</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>

	<span class="nx">sealSeed</span> <span class="o">:=</span> <span class="nf">HashBytes_SHA256Hash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">sector</span><span class="p">.</span><span class="nf">SealSeed</span><span class="p">(</span><span class="nx">sealSeed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateSDRKeyLayers</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">window</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodes</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">layers</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">modulus</span> <span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span> <span class="p">[][]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">keyLayers</span> <span class="p">[][]</span><span class="kt">byte</span>
	<span class="kd">var</span> <span class="nx">prevLayer</span> <span class="p">[]</span><span class="kt">byte</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">layers</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">currentLayer</span> <span class="o">:=</span> <span class="nf">labelLayer</span><span class="p">(</span><span class="nx">drg</span><span class="p">,</span> <span class="nx">expander</span><span class="p">,</span> <span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">window</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">nodes</span><span class="p">,</span> <span class="nx">prevLayer</span><span class="p">)</span>
		<span class="nx">keyLayers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">,</span> <span class="nx">currentLayer</span><span class="p">)</span>
		<span class="nx">prevLayer</span> <span class="p">=</span> <span class="nx">currentLayer</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">keyLayers</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">labelLayer</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">window</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodes</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">prevLayer</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">size</span> <span class="o">:=</span> <span class="nx">nodes</span> <span class="o">*</span> <span class="nx">nodeSize</span>
	<span class="nx">labels</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nodes</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">parents</span> <span class="p">[]</span><span class="nx">Label</span>

		<span class="c1">// The first node of every layer has no DRG Parents.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">i</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">parent</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">drg</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">start</span> <span class="o">:=</span> <span class="nx">parent</span> <span class="o">*</span> <span class="nx">nodeSize</span>
				<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">labels</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">start</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// The first layer has no expander parents.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">prevLayer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">for</span> <span class="nx">parent</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">expander</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="nx">start</span> <span class="o">:=</span> <span class="nx">parent</span> <span class="o">*</span> <span class="nx">nodeSize</span>
				<span class="nx">parents</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parents</span><span class="p">,</span> <span class="nx">prevLayer</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">start</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">])</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nx">label</span> <span class="o">:=</span> <span class="nf">generateLabel</span><span class="p">(</span><span class="nx">sealSeed</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">window</span><span class="p">,</span> <span class="nx">parents</span><span class="p">)</span>
		<span class="nx">labels</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">labels</span><span class="p">,</span> <span class="nx">label</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">labels</span>
<span class="p">}</span>

<span class="c1">// Encodes data in-place, mutating it.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">encodeDataInPlace</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">modulus</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;Key and data must be same length.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">i</span> <span class="o">+=</span> <span class="nx">nodeSize</span> <span class="p">{</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nf">encodeNode</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nx">key</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nx">i</span><span class="o">+</span><span class="nx">nodeSize</span><span class="p">],</span> <span class="nx">modulus</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">data</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateLabel</span><span class="p">(</span><span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">node</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">window</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">dependencies</span> <span class="p">[]</span><span class="nx">Label</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">preimage</span> <span class="o">:=</span> <span class="nx">sealSeed</span>

	<span class="k">if</span> <span class="nx">window</span> <span class="o">!=</span> <span class="nx">WRAPPER_LAYER_WINDOW_INDEX</span> <span class="p">{</span>
		<span class="nx">windowBytes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
		<span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">.</span><span class="nf">PutUint64</span><span class="p">(</span><span class="nx">windowBytes</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">window</span><span class="p">))</span>

		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">windowBytes</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">nodeBytes</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
	<span class="nx">binary</span><span class="p">.</span><span class="nx">LittleEndian</span><span class="p">.</span><span class="nf">PutUint64</span><span class="p">(</span><span class="nx">nodeBytes</span><span class="p">,</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">node</span><span class="p">))</span>

	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">nodeBytes</span><span class="o">...</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">dependency</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">dependencies</span> <span class="p">{</span>
		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">dependency</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">deriveLabel</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">deriveLabel</span><span class="p">(</span><span class="nx">elements</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">trimToFr32</span><span class="p">(</span><span class="nf">HashBytes_SHA256Hash</span><span class="p">(</span><span class="nx">elements</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">computeCommC</span><span class="p">(</span><span class="nx">keyLayers</span> <span class="p">[][]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">leaves</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

	<span class="c1">// For each node in the graph,
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">start</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">start</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leaves</span><span class="p">);</span> <span class="nx">start</span> <span class="o">+=</span> <span class="nx">nodeSize</span> <span class="p">{</span>
		<span class="nx">end</span> <span class="o">:=</span> <span class="nx">start</span> <span class="o">+</span> <span class="nx">nodeSize</span>

		<span class="kd">var</span> <span class="nx">column</span> <span class="p">[]</span><span class="nx">Label</span>
		<span class="c1">// Concatenate that node&#39;s label at each layer, in order, into a column.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">keyLayers</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">label</span> <span class="o">:=</span> <span class="nx">keyLayers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">]</span>
			<span class="nx">column</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">column</span><span class="p">,</span> <span class="nx">label</span><span class="p">)</span>
		<span class="p">}</span>

		<span class="c1">// And hash that column to create the leaf of a new tree.
</span><span class="c1"></span>		<span class="nx">hashed</span> <span class="o">:=</span> <span class="nf">hashColumn</span><span class="p">(</span><span class="nx">column</span><span class="p">)</span>
		<span class="nb">copy</span><span class="p">(</span><span class="nx">leaves</span><span class="p">[</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">],</span> <span class="nx">hashed</span><span class="p">[:])</span>
	<span class="p">}</span>

	<span class="c1">// Return the root of and path to the column tree.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">BuildTree_PedersenHash</span><span class="p">(</span><span class="nx">leaves</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">computeCommQ</span><span class="p">(</span><span class="nx">layerBytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">PedersenHash</span><span class="p">,</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">leaves</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">layerBytes</span><span class="p">)</span><span class="o">/</span><span class="nx">nodeSize</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">leaves</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">leaves</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">leaves</span><span class="p">,</span> <span class="nx">layerBytes</span><span class="p">[</span><span class="nx">i</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">:(</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nx">nodeSize</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">BuildTree_PedersenHash</span><span class="p">(</span><span class="nx">leaves</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">hashColumn</span><span class="p">(</span><span class="nx">column</span> <span class="p">[]</span><span class="nx">Label</span><span class="p">)</span> <span class="nx">PedersenHash</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">preimage</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">label</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">column</span> <span class="p">{</span>
		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">label</span><span class="o">...</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nf">HashBytes_PedersenHash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createColumnProofs</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">columnTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">,</span> <span class="nx">windows</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">windowSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">SDRColumnProof</span> <span class="p">{</span>
	<span class="nx">columnElements</span> <span class="o">:=</span> <span class="nf">getColumnElements</span><span class="p">(</span><span class="nx">drg</span><span class="p">,</span> <span class="nx">expander</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">columnProofs</span> <span class="p">[]</span><span class="nx">SDRColumnProof</span>
	<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">columnElements</span> <span class="p">{</span>
		<span class="nx">chall</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>

		<span class="nx">columnProof</span> <span class="o">:=</span> <span class="nf">createColumnProof</span><span class="p">(</span><span class="nx">chall</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">windows</span><span class="p">,</span> <span class="nx">windowSize</span><span class="p">,</span> <span class="nx">columnTree</span><span class="p">,</span> <span class="nx">aux</span><span class="p">)</span>
		<span class="nx">columnProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnProofs</span><span class="p">,</span> <span class="nx">columnProof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">columnProofs</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createWindowProof</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">dataTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">columnTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">qLayerTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">,</span> <span class="nx">windows</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">windowSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">proof</span> <span class="nx">OfflineWindowProof</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">columnElements</span> <span class="o">:=</span> <span class="nf">getColumnElements</span><span class="p">(</span><span class="nx">drg</span><span class="p">,</span> <span class="nx">expander</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>

	<span class="kd">var</span> <span class="nx">columnProofs</span> <span class="p">[]</span><span class="nx">SDRColumnProof</span>
	<span class="k">for</span> <span class="nx">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">columnElements</span> <span class="p">{</span>
		<span class="nx">chall</span> <span class="o">:=</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>

		<span class="nx">columnProof</span> <span class="o">:=</span> <span class="nf">createColumnProof</span><span class="p">(</span><span class="nx">chall</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">,</span> <span class="nx">windows</span><span class="p">,</span> <span class="nx">windowSize</span><span class="p">,</span> <span class="nx">columnTree</span><span class="p">,</span> <span class="nx">aux</span><span class="p">)</span>
		<span class="nx">columnProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnProofs</span><span class="p">,</span> <span class="nx">columnProof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">dataProof</span> <span class="o">:=</span> <span class="nx">dataTree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span>
	<span class="nx">qLayerProof</span> <span class="o">:=</span> <span class="nx">qLayerTree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span>

	<span class="nx">proof</span> <span class="p">=</span> <span class="nx">OfflineWindowProof</span><span class="p">{</span>
		<span class="nx">DataProof</span><span class="p">:</span>   <span class="nx">dataProof</span><span class="p">,</span>
		<span class="nx">QLayerProof</span><span class="p">:</span> <span class="nx">qLayerProof</span><span class="p">,</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">proof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createWrapperProof</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">qTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">replicaTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">,</span> <span class="nx">windows</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">windowSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">proof</span> <span class="nx">OfflineWrapperProof</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">proof</span><span class="p">.</span><span class="nx">ReplicaProof</span> <span class="p">=</span> <span class="nx">replicaTree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span>

	<span class="nx">parents</span> <span class="o">:=</span> <span class="nx">expander</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">parent</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">parents</span> <span class="p">{</span>
		<span class="nx">proof</span><span class="p">.</span><span class="nx">QLayerProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">proof</span><span class="p">.</span><span class="nx">QLayerProofs</span><span class="p">,</span> <span class="nx">qTree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">parent</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">proof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">getColumnElements</span><span class="p">(</span><span class="nx">drg</span> <span class="o">*</span><span class="nx">DRG_I</span><span class="p">,</span> <span class="nx">expander</span> <span class="o">*</span><span class="nx">ExpanderGraph_I</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">(</span><span class="nx">columnElements</span> <span class="p">[]</span><span class="nx">UInt</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">columnElements</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnElements</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>
	<span class="nx">columnElements</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnElements</span><span class="p">,</span> <span class="nx">drg</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">columnElements</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">columnElements</span><span class="p">,</span> <span class="nx">expander</span><span class="p">.</span><span class="nf">Parents</span><span class="p">(</span><span class="nx">challenge</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">columnElements</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createColumnProof</span><span class="p">(</span><span class="nx">c</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">windowSize</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">windows</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">columnTree</span> <span class="nx">MerkleTree</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">ProofAuxTmp</span><span class="p">)</span> <span class="p">(</span><span class="nx">columnProof</span> <span class="nx">SDRColumnProof</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">layers</span> <span class="o">:=</span> <span class="nx">aux</span><span class="p">.</span><span class="nf">KeyLayers</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">column</span> <span class="p">[]</span><span class="nx">Label</span>

	<span class="k">for</span> <span class="nx">w</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">w</span> <span class="p">&lt;</span> <span class="nx">windows</span><span class="p">;</span> <span class="nx">w</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">layers</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="nx">start</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span> <span class="nx">windowSize</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
			<span class="nx">end</span> <span class="o">:=</span> <span class="nx">start</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nodeSize</span><span class="p">)</span>
			<span class="nx">column</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">column</span><span class="p">,</span> <span class="nx">layers</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">start</span><span class="p">:</span><span class="nx">end</span><span class="p">])</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">columnProof</span> <span class="p">=</span> <span class="nx">SDRColumnProof</span><span class="p">{</span>
		<span class="nx">Column</span><span class="p">:</span>         <span class="nx">column</span><span class="p">,</span>
		<span class="nx">InclusionProof</span><span class="p">:</span> <span class="nx">columnTree</span><span class="p">.</span><span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">columnProof</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PrivateOfflineProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ColumnProofs</span>  <span class="p">[]</span><span class="nx">SDRColumnProof</span>
	<span class="nx">WindowProofs</span>  <span class="p">[]</span><span class="nx">OfflineWindowProof</span>
	<span class="nx">WrapperProofs</span> <span class="p">[]</span><span class="nx">OfflineWrapperProof</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">OfflineWindowProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="c1">// TODO: these proofs need to depend on hash function.
</span><span class="c1"></span>	<span class="nx">DataProof</span>   <span class="nx">InclusionProof</span> <span class="c1">// SHA256
</span><span class="c1"></span>	<span class="nx">QLayerProof</span> <span class="nx">InclusionProof</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">OfflineWrapperProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ReplicaProof</span> <span class="nx">InclusionProof</span> <span class="c1">// Pedersen
</span><span class="c1"></span>	<span class="nx">QLayerProofs</span> <span class="p">[]</span><span class="nx">InclusionProof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="nx">InclusionProof_I</span><span class="p">)</span> <span class="nf">Leaf</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="nx">InclusionProof_I</span><span class="p">)</span> <span class="nf">LeafIndex</span><span class="p">()</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="nx">InclusionProof_I</span><span class="p">)</span> <span class="nf">Root</span><span class="p">()</span> <span class="nx">Commitment</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">mt</span> <span class="o">*</span><span class="nx">MerkleTree_I</span><span class="p">)</span> <span class="nf">ProveInclusion</span><span class="p">(</span><span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">InclusionProof</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">mt</span> <span class="o">*</span><span class="nx">MerkleTree_I</span><span class="p">)</span> <span class="nf">Leaf</span><span class="p">(</span><span class="nx">index</span> <span class="nx">UInt</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">LoadMerkleTree</span><span class="p">(</span><span class="nx">path</span> <span class="nx">file</span><span class="p">.</span><span class="nx">Path</span><span class="p">)</span> <span class="nx">MerkleTree</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ip</span> <span class="o">*</span><span class="nx">InclusionProof_I</span><span class="p">)</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">root</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// FIXME: need to verify proof length of private inclusion proofs.
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SDRColumnProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Column</span>         <span class="p">[]</span><span class="nx">Label</span>
	<span class="nx">InclusionProof</span> <span class="nx">InclusionProof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">proof</span> <span class="o">*</span><span class="nx">SDRColumnProof</span><span class="p">)</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">root</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">challenge</span> <span class="nx">UInt</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">bytes</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="nf">hashColumn</span><span class="p">(</span><span class="nx">proof</span><span class="p">.</span><span class="nx">Column</span><span class="p">),</span> <span class="nx">proof</span><span class="p">.</span><span class="nx">InclusionProof</span><span class="p">.</span><span class="nf">Leaf</span><span class="p">())</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">proof</span><span class="p">.</span><span class="nx">InclusionProof</span><span class="p">.</span><span class="nf">LeafIndex</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">challenge</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">proof</span><span class="p">.</span><span class="nx">InclusionProof</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateOfflineChallenges</span><span class="p">(</span><span class="nx">challengeRange</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sealSeed</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">SealSeed</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">InteractiveSealRandomness</span><span class="p">,</span> <span class="nx">challengeCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="nx">UInt</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">challenges</span> <span class="p">[]</span><span class="nx">UInt</span>
	<span class="nx">challengeRangeSize</span> <span class="o">:=</span> <span class="nx">challengeRange</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// Never challenge the first node.
</span><span class="c1"></span>	<span class="nx">challengeModulus</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="nx">challengeModulus</span><span class="p">.</span><span class="nf">SetUint64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">challengeRangeSize</span><span class="p">))</span>

	<span class="c1">// Maybe factor this into a separate function, since the logic is the same...
</span><span class="c1"></span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">challengeCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">preimage</span> <span class="p">[]</span><span class="kt">byte</span>
		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">sealSeed</span><span class="o">...</span><span class="p">)</span>
		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">randomness</span><span class="o">...</span><span class="p">)</span>
		<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">littleEndianBytesFromInt</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>

		<span class="nx">hash</span> <span class="o">:=</span> <span class="nf">HashBytes_SHA256Hash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
		<span class="nx">bigChallenge</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>
		<span class="nx">bigChallenge</span> <span class="p">=</span> <span class="nx">bigChallenge</span><span class="p">.</span><span class="nf">Mod</span><span class="p">(</span><span class="nx">bigChallenge</span><span class="p">,</span> <span class="nx">challengeModulus</span><span class="p">)</span>

		<span class="c1">// Sectors nodes must be 64-bit addressable, always a safe assumption.
</span><span class="c1"></span>		<span class="nx">challenge</span> <span class="o">:=</span> <span class="nx">bigChallenge</span><span class="p">.</span><span class="nf">Uint64</span><span class="p">()</span>
		<span class="nx">challenge</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1">// Never challenge the first node.
</span><span class="c1"></span>		<span class="nx">challenges</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">challenges</span><span class="p">,</span> <span class="nx">challenge</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">challenges</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">encodeNode</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">modulus</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="c1">// TODO: Make this a method of WinStackedDRG.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nf">addEncode</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">modulus</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">addEncode</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">modulus</span> <span class="o">*</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">,</span> <span class="nx">nodeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>

	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="nx">k</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>

	<span class="nx">sum</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nf">Add</span><span class="p">(</span><span class="nx">d</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span>
	<span class="nx">result</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nf">Mod</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="nx">modulus</span><span class="p">)</span>

	<span class="k">return</span> <span class="nf">littleEndianBytesFromBigInt</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">nodeSize</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Seal Verification
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">sv</span> <span class="o">*</span><span class="nx">SealVerifier_I</span><span class="p">)</span> <span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">svi</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SealVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">svi</span><span class="p">.</span><span class="nx">OnChain</span><span class="p">.</span><span class="nx">RegisteredProof</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_WinStackedDRG32GiBSeal</span><span class="p">:</span>
		<span class="p">{</span>
			<span class="nx">sdr</span> <span class="o">:=</span> <span class="nf">WinSDRParams</span><span class="p">(</span><span class="nx">svi</span><span class="p">.</span><span class="nx">OnChain</span><span class="p">.</span><span class="nx">RegisteredProof</span><span class="p">)</span>

			<span class="k">return</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">VerifySeal</span><span class="p">(</span><span class="nx">svi</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_StackedDRG32GiBSeal</span><span class="p">:</span>
		<span class="p">{</span>
			<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">ComputeUnsealedSectorCIDFromPieceInfos</span><span class="p">(</span><span class="nx">sectorSize</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorSize</span><span class="p">,</span> <span class="nx">pieceInfos</span> <span class="p">[]</span><span class="nx">PieceInfo</span><span class="p">)</span> <span class="p">(</span><span class="nx">unsealedCID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">UnsealedSectorCID</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">rootPieceInfo</span> <span class="o">:=</span> <span class="nf">computeRootPieceInfo</span><span class="p">(</span><span class="nx">pieceInfos</span><span class="p">)</span>
	<span class="nx">rootSize</span> <span class="o">:=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">rootPieceInfo</span><span class="p">.</span><span class="nx">Size</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">rootSize</span> <span class="o">!=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">sectorSize</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">unsealedCID</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Wrong sector size.&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nf">UnsealedSectorCID</span><span class="p">(</span><span class="nx">rootPieceInfo</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">()),</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">computeRootPieceInfo</span><span class="p">(</span><span class="nx">pieceInfos</span> <span class="p">[]</span><span class="nx">PieceInfo</span><span class="p">)</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
	<span class="c1">// Construct root PieceInfo by (shift-reduce) parsing the constituent PieceInfo array.
</span><span class="c1"></span>	<span class="c1">// Later pieces must always be joined with equal-sized predecessors to create a new root twice their size.
</span><span class="c1"></span>	<span class="c1">// So if a piece is larger than the current root (top of stack), add padding until it is not.
</span><span class="c1"></span>	<span class="c1">// If a piece is smaller than the root, let it be the new root (top of stack) until reduced to a replacement that can be joined
</span><span class="c1"></span>	<span class="c1">// with the previous.
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">stack</span> <span class="p">[]</span><span class="nx">PieceInfo</span>

	<span class="nx">shift</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="nx">PieceInfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">stack</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">peek</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">peek2</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">pop</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
		<span class="nx">stack</span> <span class="p">=</span> <span class="nx">stack</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">return</span> <span class="nx">stack</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="nx">reduce1</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nf">peek</span><span class="p">().</span><span class="nx">Size</span> <span class="o">==</span> <span class="nf">peek2</span><span class="p">().</span><span class="nx">Size</span> <span class="p">{</span>
			<span class="nx">right</span> <span class="o">:=</span> <span class="nf">pop</span><span class="p">()</span>
			<span class="nx">left</span> <span class="o">:=</span> <span class="nf">pop</span><span class="p">()</span>
			<span class="nx">joined</span> <span class="o">:=</span> <span class="nf">joinPieceInfos</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="nx">right</span><span class="p">)</span>
			<span class="nf">shift</span><span class="p">(</span><span class="nx">joined</span><span class="p">)</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="p">}</span>
	<span class="nx">reduce</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nf">reduce1</span><span class="p">()</span> <span class="p">{</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="nx">shiftReduce</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">p</span> <span class="nx">PieceInfo</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">shift</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
		<span class="nf">reduce</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="c1">// Prime the pump with first pieceInfo.
</span><span class="c1"></span>	<span class="nf">shift</span><span class="p">(</span><span class="nx">pieceInfos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

	<span class="c1">// Consume the remainder.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">pieceInfo</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pieceInfos</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">{</span>
		<span class="c1">// TODO: Assert that pieceInfo.Size is a power of 2.
</span><span class="c1"></span>
		<span class="c1">// Add padding until top of stack is large enough to receive current pieceInfo.
</span><span class="c1"></span>		<span class="k">for</span> <span class="nf">peek</span><span class="p">().</span><span class="nx">Size</span> <span class="p">&lt;</span> <span class="nx">pieceInfo</span><span class="p">.</span><span class="nx">Size</span> <span class="p">{</span>
			<span class="nf">shiftReduce</span><span class="p">(</span><span class="nf">zeroPadding</span><span class="p">(</span><span class="nf">peek</span><span class="p">().</span><span class="nx">Size</span><span class="p">))</span>
		<span class="p">}</span>

		<span class="c1">// Add the current piece.
</span><span class="c1"></span>		<span class="nf">shiftReduce</span><span class="p">(</span><span class="nx">pieceInfo</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="c1">// Add any necessary final padding.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
		<span class="nf">shiftReduce</span><span class="p">(</span><span class="nf">zeroPadding</span><span class="p">(</span><span class="nf">peek</span><span class="p">().</span><span class="nx">Size</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

	<span class="k">return</span> <span class="nf">pop</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">zeroPadding</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int64</span><span class="p">)</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">{</span>
		<span class="nx">Size</span><span class="p">:</span> <span class="nx">size</span><span class="p">,</span>
		<span class="c1">// CommP_: FIXME: Implement.
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">joinPieceInfos</span><span class="p">(</span><span class="nx">left</span> <span class="nx">PieceInfo</span><span class="p">,</span> <span class="nx">right</span> <span class="nx">PieceInfo</span><span class="p">)</span> <span class="nx">PieceInfo</span> <span class="p">{</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nx">Size</span> <span class="o">==</span> <span class="nx">right</span><span class="p">.</span><span class="nx">Size</span><span class="p">)</span>

	<span class="c1">// FIXME: make this whole function generic?
</span><span class="c1"></span>	<span class="c1">// Note: cid.Bytes() isn&#39;t actually the payload data that we want input to the binary hash function, for more
</span><span class="c1"></span>	<span class="c1">// information see discussion: https://filecoinproject.slack.com/archives/CHMNDCK9P/p1578629688082700
</span><span class="c1"></span>	<span class="nx">sectorPieceCID</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">cid</span><span class="p">.</span><span class="nf">Cast</span><span class="p">(</span><span class="nf">BinaryHash_SHA256Hash</span><span class="p">(</span><span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">).</span><span class="nf">Bytes</span><span class="p">(),</span> <span class="nx">cid</span><span class="p">.</span><span class="nf">Cid</span><span class="p">(</span><span class="nx">right</span><span class="p">.</span><span class="nx">PieceCID</span><span class="p">).</span><span class="nf">Bytes</span><span class="p">()))</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="nx">err</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PieceInfo</span><span class="p">{</span>
		<span class="nx">Size</span><span class="p">:</span>     <span class="nx">left</span><span class="p">.</span><span class="nx">Size</span> <span class="o">+</span> <span class="nx">right</span><span class="p">.</span><span class="nx">Size</span><span class="p">,</span>
		<span class="nx">PieceCID</span><span class="p">:</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">PieceCID</span><span class="p">(</span><span class="nx">sectorPieceCID</span><span class="p">),</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// PoSt
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">getChallengedSectors</span><span class="p">(</span><span class="nx">sectorIDs</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">eligibleSectors</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">candidateCount</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">sectors</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">candidateCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sector</span> <span class="o">:=</span> <span class="nf">generateSectorChallenge</span><span class="p">(</span><span class="nx">randomness</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">sectorIDs</span><span class="p">)</span>
		<span class="nx">sectors</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">sectors</span><span class="p">,</span> <span class="nx">sector</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">sectors</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateSectorChallenge</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sectorIDs</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="p">(</span><span class="nx">sector</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">preimage</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">randomness</span><span class="p">,</span> <span class="nf">littleEndianBytesFromInt</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nf">SHA256Hash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
	<span class="nx">sectorChallenge</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>

	<span class="nx">challengeModulus</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="nx">challengeModulus</span><span class="p">.</span><span class="nf">SetUint64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">sectorIDs</span><span class="p">)))</span>

	<span class="nx">sectorIndex</span> <span class="o">:=</span> <span class="nx">sectorChallenge</span><span class="p">.</span><span class="nf">Mod</span><span class="p">(</span><span class="nx">sectorChallenge</span><span class="p">,</span> <span class="nx">challengeModulus</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">sectorIDs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nx">sectorIndex</span><span class="p">.</span><span class="nf">Uint64</span><span class="p">())]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateLeafChallenge</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">sectorChallengeIndex</span> <span class="nx">UInt</span><span class="p">,</span> <span class="nx">leafChallengeIndex</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">nodes</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">challengeRangeSize</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">UInt</span> <span class="p">{</span>
	<span class="nx">preimage</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">randomness</span><span class="p">,</span> <span class="nf">littleEndianBytesFromUInt</span><span class="p">(</span><span class="nx">sectorChallengeIndex</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">littleEndianBytesFromInt</span><span class="p">(</span><span class="nx">leafChallengeIndex</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">hash</span> <span class="o">:=</span> <span class="nf">SHA256Hash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">)</span>
	<span class="nx">bigHash</span> <span class="o">:=</span> <span class="nf">bigIntFromLittleEndianBytes</span><span class="p">(</span><span class="nx">hash</span><span class="p">)</span>

	<span class="nx">challengeSpaceSize</span> <span class="o">:=</span> <span class="nx">nodes</span> <span class="o">/</span> <span class="nx">challengeRangeSize</span>
	<span class="nx">challengeModulus</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">)</span>
	<span class="nx">challengeModulus</span><span class="p">.</span><span class="nf">SetUint64</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">challengeSpaceSize</span><span class="p">))</span>

	<span class="nx">leafChallenge</span> <span class="o">:=</span> <span class="nx">bigHash</span><span class="p">.</span><span class="nf">Mod</span><span class="p">(</span><span class="nx">bigHash</span><span class="p">,</span> <span class="nx">challengeModulus</span><span class="p">)</span>

	<span class="k">return</span> <span class="nx">leafChallenge</span><span class="p">.</span><span class="nf">Uint64</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">generateCandidate</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">aux</span> <span class="nx">sector</span><span class="p">.</span><span class="nx">PersistentProofAux</span><span class="p">,</span> <span class="nx">sectorID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">sectorChallengeIndex</span> <span class="nx">UInt</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">candidate</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span>

	<span class="c1">// switch algorithm {
</span><span class="c1"></span>	<span class="c1">// case ProofAlgorithm_StackedDRGSeal:
</span><span class="c1"></span>	<span class="c1">// 	panic(&#34;TODO&#34;)
</span><span class="c1"></span>	<span class="c1">// case ProofAlgorithm_WinStackedDRGSeal:
</span><span class="c1"></span>	<span class="c1">// 	sdr := WinStackedDRG_I{}
</span><span class="c1"></span>	<span class="c1">// 	candidate = sdr._generateCandidate(cfg, randomness, aux, sectorID, sectorChallengeIndex)
</span><span class="c1"></span>	<span class="c1">// }
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">candidate</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">computePartialTicket</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">sectorID</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PartialTicket</span> <span class="p">{</span>
	<span class="nx">preimage</span> <span class="o">:=</span> <span class="nx">randomness</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">getProverID</span><span class="p">(</span><span class="nx">sectorID</span><span class="p">.</span><span class="nx">Miner</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nf">littleEndianBytesFromUInt</span><span class="p">(</span><span class="nf">UInt</span><span class="p">(</span><span class="nx">sectorID</span><span class="p">.</span><span class="nx">Number</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">preimage</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">preimage</span><span class="p">,</span> <span class="nx">data</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">partialTicket</span> <span class="o">:=</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">PartialTicket</span><span class="p">(</span><span class="nf">HashBytes_PedersenHash</span><span class="p">(</span><span class="nx">preimage</span><span class="p">))</span>

	<span class="k">return</span> <span class="nx">partialTicket</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PoStCandidatesMap</span> <span class="kd">map</span><span class="p">[</span><span class="nx">ProofAlgorithm</span><span class="p">][]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span>

<span class="kd">func</span> <span class="nf">CreatePoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span> <span class="p">[]</span><span class="nx">PrivatePostCandidateProof</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">)</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">proofsMap</span> <span class="kd">map</span><span class="p">[</span><span class="nx">RegisteredProof</span><span class="p">][]</span><span class="nx">PrivatePostCandidateProof</span>

	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">proof</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">privateCandidateProofs</span> <span class="p">{</span>
		<span class="nx">registeredProof</span> <span class="o">:=</span> <span class="nx">proof</span><span class="p">.</span><span class="nx">RegisteredProof</span>
		<span class="nx">proofsMap</span><span class="p">[</span><span class="nx">registeredProof</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">proofsMap</span><span class="p">[</span><span class="nx">registeredProof</span><span class="p">],</span> <span class="nx">proof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">circuitProofs</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span>
	<span class="k">for</span> <span class="nx">registeredProof</span><span class="p">,</span> <span class="nx">proofs</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">proofsMap</span> <span class="p">{</span>
		<span class="nx">privateProof</span> <span class="o">:=</span> <span class="nf">createPrivatePoStProof</span><span class="p">(</span><span class="nx">registeredProof</span><span class="p">,</span> <span class="nx">proofs</span><span class="p">,</span> <span class="nx">challengeSeed</span><span class="p">)</span>
		<span class="nx">circuitProof</span> <span class="o">:=</span> <span class="nf">createPoStCircuitProof</span><span class="p">(</span><span class="nx">registeredProof</span><span class="p">,</span> <span class="nx">privateProof</span><span class="p">)</span>
		<span class="nx">circuitProofs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">circuitProofs</span><span class="p">,</span> <span class="nx">circuitProof</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">circuitProofs</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">PrivatePoStProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">RegisteredProof</span> <span class="nx">RegisteredProof</span>
	<span class="nx">ChallengeSeed</span>   <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span>
	<span class="nx">CandidateProofs</span> <span class="p">[]</span><span class="nx">PrivatePostCandidateProof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createPrivatePoStProof</span><span class="p">(</span><span class="nx">registeredProof</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span><span class="p">,</span> <span class="nx">candidateProofs</span> <span class="p">[]</span><span class="nx">PrivatePostCandidateProof</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">)</span> <span class="nx">PrivatePoStProof</span> <span class="p">{</span>
	<span class="c1">// TODO: Verify that all candidateProofs share algorithm.
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">PrivatePoStProof</span><span class="p">{</span>
		<span class="nx">RegisteredProof</span><span class="p">:</span> <span class="nx">registeredProof</span><span class="p">,</span>
		<span class="nx">ChallengeSeed</span><span class="p">:</span>   <span class="nx">challengeSeed</span><span class="p">,</span>
		<span class="nx">CandidateProofs</span><span class="p">:</span> <span class="nx">candidateProofs</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">InternalPrivateCandidateProof</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">InclusionProofs</span> <span class="p">[]</span><span class="nx">InclusionProof</span>
<span class="p">}</span>

<span class="c1">// This exists because we need to pass private proofs out of filproofs for winner selection.
</span><span class="c1">// Actually implementing it would (will?) be tedious, since it means doing the same for InclusionProofs.
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">InternalPrivateCandidateProof</span><span class="p">)</span> <span class="nf">externalize</span><span class="p">(</span><span class="nx">registeredProof</span> <span class="nx">RegisteredProof</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span><span class="p">{</span>
		<span class="nx">RegisteredProof</span><span class="p">:</span> <span class="nx">registeredProof</span><span class="p">,</span>
		<span class="nx">Externalized</span><span class="p">:</span>    <span class="p">[]</span><span class="kt">byte</span><span class="p">{},</span> <span class="c1">// Unimplemented.
</span><span class="c1"></span>	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This is the inverse of InternalPrivateCandidateProof.externalize and equally tedious.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newInternalPrivateProof</span><span class="p">(</span><span class="nx">externalPrivateProof</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PrivatePoStCandidateProof</span><span class="p">)</span> <span class="nx">InternalPrivateCandidateProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">InternalPrivateCandidateProof</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">createPoStCircuitProof</span><span class="p">(</span><span class="nx">registeredProof</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof</span><span class="p">,</span> <span class="nx">privateProof</span> <span class="nx">PrivatePoStProof</span><span class="p">)</span> <span class="p">(</span><span class="nx">proof</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">registeredProof</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_WinStackedDRG32GiBPoSt</span><span class="p">:</span>
		<span class="nx">sdr</span> <span class="o">:=</span> <span class="nx">WinStackedDRG_I</span><span class="p">{}</span>
		<span class="nx">proof</span> <span class="p">=</span> <span class="nx">sdr</span><span class="p">.</span><span class="nf">_createPoStCircuitProof</span><span class="p">(</span><span class="nx">privateProof</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RegisteredProof_StackedDRG32GiBPoSt</span><span class="p">:</span>
		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">proof</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pv</span> <span class="o">*</span><span class="nx">PoStVerifier_I</span><span class="p">)</span> <span class="nf">_verifyPoStProof</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// commT := sv.CommT()
</span><span class="c1"></span>	<span class="c1">// candidates := sv.Candidates()
</span><span class="c1"></span>	<span class="c1">// randomness := sv.Randomness()
</span><span class="c1"></span>	<span class="c1">// postProofs := sv.OnChain.Proofs()
</span><span class="c1"></span>
	<span class="c1">// Verify circuit proof.
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// General PoSt
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">generatePoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">eligibleSectors</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">candidateCount</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sectorStore</span> <span class="nx">sector_index</span><span class="p">.</span><span class="nx">SectorStore</span><span class="p">)</span> <span class="p">(</span><span class="nx">candidates</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">challengedSectors</span> <span class="o">:=</span> <span class="nf">getChallengedSectors</span><span class="p">(</span><span class="nx">eligibleSectors</span><span class="p">,</span> <span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">eligibleSectors</span><span class="p">,</span> <span class="nx">candidateCount</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">sectorID</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">challengedSectors</span> <span class="p">{</span>
		<span class="nx">proofAux</span> <span class="o">:=</span> <span class="nx">sectorStore</span><span class="p">.</span><span class="nf">GetSectorPersistentProofAux</span><span class="p">(</span><span class="nx">sectorID</span><span class="p">)</span>

		<span class="nx">candidate</span> <span class="o">:=</span> <span class="nf">generateCandidate</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">proofAux</span><span class="p">,</span> <span class="nx">sectorID</span><span class="p">,</span> <span class="nf">UInt</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>

		<span class="nx">candidates</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">candidates</span><span class="p">,</span> <span class="nx">candidate</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">candidates</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Election PoSt
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">GenerateElectionPoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">eligibleSectors</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">candidateCount</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sectorStore</span> <span class="nx">sector_index</span><span class="p">.</span><span class="nx">SectorStore</span><span class="p">)</span> <span class="p">(</span><span class="nx">candidates</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">generatePoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span><span class="p">,</span> <span class="nx">eligibleSectors</span><span class="p">,</span> <span class="nx">candidateCount</span><span class="p">,</span> <span class="nx">sectorStore</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CreateElectionPoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span> <span class="p">[]</span><span class="nx">PrivatePostCandidateProof</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">)</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">CreatePoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span><span class="p">,</span> <span class="nx">challengeSeed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pv</span> <span class="o">*</span><span class="nx">PoStVerifier_I</span><span class="p">)</span> <span class="nf">VerifyElectionPoSt</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">pv</span><span class="p">.</span><span class="nf">_verifyPoStProof</span><span class="p">(</span><span class="nx">sv</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////
</span><span class="c1">// Surprise PoSt
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">GenerateSurprisePoStCandidates</span><span class="p">(</span><span class="nx">challengeSeed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">,</span> <span class="nx">eligibleSectors</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">SectorID</span><span class="p">,</span> <span class="nx">candidateCount</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">sectorStore</span> <span class="nx">sector_index</span><span class="p">.</span><span class="nx">SectorStore</span><span class="p">)</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStCandidate</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">CreateSurprisePoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span> <span class="p">[]</span><span class="nx">PrivatePostCandidateProof</span><span class="p">,</span> <span class="nx">challengeSeed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStRandomness</span><span class="p">)</span> <span class="p">[]</span><span class="nx">abi</span><span class="p">.</span><span class="nx">PoStProof</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">CreatePoStProof</span><span class="p">(</span><span class="nx">privateCandidateProofs</span><span class="p">,</span> <span class="nx">challengeSeed</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pv</span> <span class="o">*</span><span class="nx">PoStVerifier_I</span><span class="p">)</span> <span class="nf">VerifySurprisePoSt</span><span class="p">(</span><span class="nx">sv</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">PoStVerifyInfo</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">pv</span><span class="p">.</span><span class="nf">_verifyPoStProof</span><span class="p">(</span><span class="nx">sv</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="libraries__fcs">

<h2 class="section-header">
  FCS
</h2>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipld">

<h2 class="section-header">
  IPLD - InterPlanetary Linked Data
</h2>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// imported as ipld.Object
</span><span class="c1"></span>
<span class="kn">import</span> <span class="nx">cid</span> <span class="s">&#34;github.com/ipfs/go-cid&#34;</span>

<span class="kd">type</span> <span class="nx">Object</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">CID</span><span class="p">()</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span>

    <span class="c1">// Populate(v interface{}) error
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">GraphStore</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Retrieves a serialized value from the store by CID. Returns the value and whether it was found.
</span><span class="c1"></span>    <span class="nf">Get</span><span class="p">(</span><span class="nx">c</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span><span class="p">)</span> <span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span>

    <span class="c1">// Puts a serialized value in the store, returning the CID.
</span><span class="c1"></span>    <span class="nf">Put</span><span class="p">(</span><span class="nx">value</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="p">(</span><span class="nx">c</span> <span class="nx">cid</span><span class="p">.</span><span class="nx">Cid</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>







</div>


  
    








<div id="libraries__ipld__cid">

<h3 class="section-header">
  CIDs - Content IDentifiers
</h3>

<div class="section-content">




































<p>For most objects referenced by Filecoin, a Content Identifier (CID for short) is used. Any pointer inclusions in the Filecoin spec <code>id</code> files (e.g. <code>&amp;Object</code>) denotes the CID of said object. Some objects explicitly name a CID field. The spec treats these notations interchangeably.
This is effectively a hash value, prefixed with its hash function (multihash) as well as extra labels to inform applications about how to deserialize the given data.</p>
<p>For a more detailed specification, we refer the reader to the
<a href="https://github.com/ipld/cid">IPLD repository</a>.</p>


</div>



</div>

  

  
    








<div id="libraries__ipld__datamodel">

<h3 class="section-header">
  Data Model
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipld__selectors">

<h3 class="section-header">
  Selectors - IPLD Query Language
</h3>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// This is a compression of the IPLD Selector Spec
</span><span class="c1">// Full spec: https://github.com/ipld/specs/blob/master/selectors/selectors.md
</span><span class="c1"></span>
<span class="kd">type</span> <span class="nx">Selector</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">Matcher</span>
    <span class="nx">ExploreAll</span>
    <span class="nx">ExploreFields</span>
    <span class="nx">ExploreIndex</span>
    <span class="nx">ExploreRange</span>
    <span class="nx">ExploreRecursive</span>
    <span class="nx">ExploreUnion</span>
    <span class="nx">ExploreConditional</span>
    <span class="nx">ExploreRecursiveEdge</span>
<span class="p">}</span>

<span class="c1">// ExploreAll is similar to a `*` -- it traverses all elements of an array,
</span><span class="c1">// or all entries in a map, and applies a next selector to the reached nodes.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreAll</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">next</span> <span class="nx">Selector</span>
<span class="p">}</span>

<span class="c1">// ExploreFields traverses named fields in a map (or equivalently, struct, if
</span><span class="c1">// traversing on typed/schema nodes) and applies a next selector to the
</span><span class="c1">// reached nodes.
</span><span class="c1">//
</span><span class="c1">// Note that a concept of exploring a whole path (e.g. &#34;foo/bar/baz&#34;) can be
</span><span class="c1">// represented as a set of three nexted ExploreFields selectors, each
</span><span class="c1">// specifying one field.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreFields</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">fields</span> <span class="p">{</span><span class="kt">string</span><span class="p">:</span> <span class="nx">Selector</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ExploreIndex traverses a specific index in a list, and applies a next
</span><span class="c1">// selector to the reached node.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreIndex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">index</span>  <span class="nx">UInt</span>
    <span class="nx">next</span>   <span class="nx">Selector</span>
<span class="p">}</span>

<span class="c1">// ExploreIndex traverses a list, and for each element in the range specified,
</span><span class="c1">// will apply a next selector to those reached nodes.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreRange</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">start</span>  <span class="nx">UInt</span>
    <span class="nx">end</span>    <span class="nx">UInt</span>
    <span class="nx">next</span>   <span class="nx">Selector</span>
<span class="p">}</span>

<span class="c1">// ExploreRecursive traverses some structure recursively.
</span><span class="c1">// To guide this exploration, it uses a &#34;sequence&#34;, which is another Selector
</span><span class="c1">// tree; some leaf node in this sequence should contain an ExploreRecursiveEdge
</span><span class="c1">// selector, which denotes the place recursion should occur.
</span><span class="c1">//
</span><span class="c1">// In implementation, whenever evaluation reaches an ExploreRecursiveEdge marker
</span><span class="c1">// in the recursion sequence&#39;s Selector tree, the implementation logically
</span><span class="c1">// produces another new Selector which is a copy of the original
</span><span class="c1">// ExploreRecursive selector, but with a decremented maxDepth parameter, and
</span><span class="c1">// continues evaluation thusly.
</span><span class="c1">//
</span><span class="c1">// It is not valid for an ExploreRecursive selector&#39;s sequence to contain
</span><span class="c1">// no instances of ExploreRecursiveEdge; it *is* valid for it to contain
</span><span class="c1">// more than one ExploreRecursiveEdge.
</span><span class="c1">//
</span><span class="c1">// ExploreRecursive can contain a nested ExploreRecursive!
</span><span class="c1">// This is comparable to a nested for-loop.
</span><span class="c1">// In these cases, any ExploreRecursiveEdge instance always refers to the
</span><span class="c1">// nearest parent ExploreRecursive (in other words, ExploreRecursiveEdge can
</span><span class="c1">// be thought of like the &#39;continue&#39; statement, or end of a for-loop body;
</span><span class="c1">// it is *not* a &#39;goto&#39; statement).
</span><span class="c1">//
</span><span class="c1">// Be careful when using ExploreRecursive with a large maxDepth parameter;
</span><span class="c1">// it can easily cause very large traversals (especially if used in combination
</span><span class="c1">// with selectors like ExploreAll inside the sequence).
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreRecursive</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">sequence</span>  <span class="nx">Selector</span>
    <span class="nx">maxDepth</span>  <span class="nx">UInt</span>
    <span class="nx">stopAt</span>    <span class="nx">Condition</span>
<span class="p">}</span>

<span class="c1">// ExploreRecursiveEdge is a special sentinel value which is used to mark
</span><span class="c1">// the end of a sequence started by an ExploreRecursive selector: the recursion
</span><span class="c1">// goes back to the initial state of the earlier ExploreRecursive selector,
</span><span class="c1">// and proceeds again (with a decremented maxDepth value).
</span><span class="c1">//
</span><span class="c1">// An ExploreRecursive selector that doesn&#39;t contain an ExploreRecursiveEdge
</span><span class="c1">// is nonsensical.  Containing more than one ExploreRecursiveEdge is valid.
</span><span class="c1">// An ExploreRecursiveEdge without an enclosing ExploreRecursive is an error.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreRecursiveEdge</span> <span class="kd">struct</span> <span class="p">{}</span>

<span class="c1">// ExploreUnion allows selection to continue with two or more distinct selectors
</span><span class="c1">// while exploring the same tree of data.
</span><span class="c1">//
</span><span class="c1">// ExploreUnion can be used to apply a Matcher on one node (causing it to
</span><span class="c1">// be considered part of a (possibly labelled) result set), while simultaneously
</span><span class="c1">// continuing to explore deeper parts of the tree with another selector,
</span><span class="c1">// for example.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreUnion</span> <span class="p">[</span><span class="nx">Selector</span><span class="p">]</span>

<span class="c1">// Note that ExploreConditional versus a Matcher with a Condition are distinct:
</span><span class="c1">// ExploreConditional progresses deeper into a tree;
</span><span class="c1">// whereas a Matcher with a Condition may look deeper to make its decision,
</span><span class="c1">// but returns a match for the node it&#39;s on rather any of the deeper values.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ExploreConditional</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">condition</span>  <span class="nx">Condition</span>
    <span class="nx">next</span>       <span class="nx">Selector</span>
<span class="p">}</span>

<span class="c1">// Matcher marks a node to be included in the &#34;result&#34; set.
</span><span class="c1">// (All nodes traversed by a selector are in the &#34;covered&#34; set (which is a.k.a.
</span><span class="c1">// &#34;the merkle proof&#34;); the &#34;result&#34; set is a subset of the &#34;covered&#34; set.)
</span><span class="c1">//
</span><span class="c1">// In libraries using selectors, the &#34;result&#34; set is typically provided to
</span><span class="c1">// some user-specified callback.
</span><span class="c1">//
</span><span class="c1">// A selector tree with only &#34;explore*&#34;-type selectors and no Matcher selectors
</span><span class="c1">// is valid; it will just generate a &#34;covered&#34; set of nodes and no &#34;result&#34; set.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Matcher</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">onlyIf</span>  <span class="nx">Condition</span><span class="err">?</span>  <span class="c1">// match is true based on position alone if this is not set.
</span><span class="c1"></span>    <span class="nx">label</span>   <span class="kt">string</span><span class="err">?</span>  <span class="c1">// labels can be used to match multiple different structures in one selection.
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// Condition is expresses a predicate with a boolean result.
</span><span class="c1">//
</span><span class="c1">// Condition clauses are used several places:
</span><span class="c1">//   - in Matcher, to determine if a node is selected.
</span><span class="c1">//   - in ExploreRecursive, to halt exploration.
</span><span class="c1">//   - in ExploreConditional,
</span><span class="c1">//
</span><span class="c1">//
</span><span class="c1">// TODO -- Condition is very skeletal and incomplete.
</span><span class="c1">// The place where Condition appears in other structs is correct;
</span><span class="c1">// the rest of the details inside it are not final nor even completely drafted.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Condition</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="c1">// We can come back to this and expand it later...
</span><span class="c1"></span>    <span class="c1">// TODO: figure out how to make this recurse correctly, so I can say &#34;hasField{hasField{or{hasValue{1}, hasValue{2}}}}&#34;.
</span><span class="c1"></span>    <span class="nx">Condition_HasField</span>
    <span class="nx">Condition_HasValue</span>
    <span class="nx">Condition_HasKind</span>
    <span class="nx">Condition_IsLink</span>
    <span class="nx">Condition_GreaterThan</span>
    <span class="nx">Condition_LessThan</span>
    <span class="nx">Condition_And</span>
    <span class="nx">Condition_Or</span>
    <span class="c1">// REVIEW: since we introduced &#34;and&#34; and &#34;or&#34; here, we&#39;re getting into dangertown again.  we&#39;ll need a &#34;max conditionals limit&#34; (a la &#39;gas&#39; of some kind) near here.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">Condition_HasField</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_HasKind</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_HasValue</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_And</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_GreaterThan</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_IsLink</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_LessThan</span> <span class="kd">struct</span> <span class="p">{}</span>
<span class="kd">type</span> <span class="nx">Condition_Or</span> <span class="kd">struct</span> <span class="p">{}</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="libraries__libp2p">

<h2 class="section-header">
  libp2p
</h2>

<div class="section-content">























































<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">peer</span> <span class="s">&#34;github.com/libp2p/go-libp2p-core/peer&#34;</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// PeerID returns the PeerID associated with this libp2p Node
</span><span class="c1"></span>    <span class="nf">PeerID</span><span class="p">()</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">ID</span>

    <span class="c1">// MountProtocol adds given Protocol under specified protocol id.
</span><span class="c1"></span>    <span class="nf">MountProtocol</span><span class="p">(</span><span class="nx">path</span> <span class="nx">ProtocolPath</span><span class="p">,</span> <span class="nx">protocol</span> <span class="nx">Protocol</span><span class="p">)</span>

    <span class="c1">// ConnectPeerID establishes a connection to peer matching given PeerInfo.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// peer.AddrInfo may be empty. If so:
</span><span class="c1"></span>    <span class="c1">// - Libp2pNode will try to use any Multiaddrs it knows (internal PeerStore)
</span><span class="c1"></span>    <span class="c1">// - Libp2pNode may use any `PeerRouting` protocol mounted onto the libp2p node.
</span><span class="c1"></span>    <span class="c1">//     TODO: how to define this.
</span><span class="c1"></span>    <span class="c1">//     NOTE: probably implies using kad-dht or gossipsub for this.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Idempotent. If a connection already exists, this method returns silently.
</span><span class="c1"></span>    <span class="nf">Connect</span><span class="p">(</span><span class="nx">peerInfo</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">AddrInfo</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ProtocolPath</span> <span class="kt">string</span>

<span class="kd">type</span> <span class="nx">Protocol</span> <span class="nx">union</span> <span class="p">{</span>
    <span class="nx">StreamProtocol</span>
    <span class="nx">DatagramProtocol</span>
<span class="p">}</span>

<span class="c1">// Stream is an interface to deal with networked processes, which communicate
</span><span class="c1">// via streams of bytes.
</span><span class="c1">//
</span><span class="c1">// See golang.org/pkg/io -- as this is modelled after io.Reader and io.Writer
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Stream</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Read reads bytes from the underlying stream and copies them to buf.
</span><span class="c1"></span>    <span class="c1">// Read returns the number of bytes read (n), and potentially an error
</span><span class="c1"></span>    <span class="c1">// encountered while reading. Read reads at most len(buf) byte.
</span><span class="c1"></span>    <span class="c1">// Read may read 0 bytes.
</span><span class="c1"></span>    <span class="nf">Read</span><span class="p">(</span><span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Write writes bytes to the underlying stream, copying them from buf.
</span><span class="c1"></span>    <span class="c1">// Write returns the number of bytes written (n), and potentially an error
</span><span class="c1"></span>    <span class="c1">// encountered while writing. Write writes at most len(buf) byte.
</span><span class="c1"></span>    <span class="c1">// Write may read 0 bytes.
</span><span class="c1"></span>    <span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">union</span> <span class="p">{</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>

    <span class="c1">// Close terminates client&#39;s use of the stream.
</span><span class="c1"></span>    <span class="c1">// Calling Read or Write after Close is an error.
</span><span class="c1"></span>    <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">StreamProtocol</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// AcceptStream accepts an incoming stream connection.
</span><span class="c1"></span>    <span class="nf">AcceptStream</span><span class="p">()</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">stream</span>    <span class="nx">Stream</span>
        <span class="nx">peerInfo</span>  <span class="nx">peer</span><span class="p">.</span><span class="nx">AddrInfo</span>
        <span class="nx">err</span>       <span class="kt">error</span>
    <span class="p">}</span>

    <span class="c1">// OpenStream opens a stream to a particular PeerID.
</span><span class="c1"></span>    <span class="nf">OpenStream</span><span class="p">(</span><span class="nx">peerInfo</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">AddrInfo</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">stream</span>  <span class="nx">Stream</span>
        <span class="nx">err</span>     <span class="kt">error</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Datagram
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Datagram</span> <span class="nx">Bytes</span>

<span class="c1">// Datagrams are &#34;messages&#34; in the network packet sense of the word.
</span><span class="c1">//
</span><span class="c1">// &#34;message-oriented network protocols&#34; should use this interface,
</span><span class="c1">// not the StreamProtocol interface.
</span><span class="c1">//
</span><span class="c1">// We call it &#34;Datagram&#34; here because unfortunately the word &#34;Message&#34;
</span><span class="c1">// is very overloaded in Filecoin.
</span><span class="c1">// Suggestion for libp2p: use datagram too.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DatagramProtocol</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// AcceptDatagram accepts an incoming message.
</span><span class="c1"></span>    <span class="nf">AcceptDatagram</span><span class="p">()</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">datagram</span>  <span class="nx">Datagram</span>
        <span class="nx">peerInfo</span>  <span class="nx">peer</span><span class="p">.</span><span class="nx">AddrInfo</span>
        <span class="nx">err</span>       <span class="kt">error</span>
    <span class="p">}</span>

    <span class="c1">// OpenStream opens a stream to a particular PeerID
</span><span class="c1"></span>    <span class="nf">SendDatagram</span><span class="p">(</span><span class="nx">datagram</span> <span class="nx">Datagram</span><span class="p">,</span> <span class="nx">peerInfo</span> <span class="nx">peer</span><span class="p">.</span><span class="nx">AddrInfo</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// type StorageDealLibp2pProtocol struct {
</span><span class="c1">//   StreamProtocol StreamProtocol
</span><span class="c1">//   // ---
</span><span class="c1">//   AcceptStream() struct {}
</span><span class="c1">//   OpenStream() struct {}
</span><span class="c1">// }
</span></code></pre></div>







</div>


  
    








<div id="libraries__libp2p__gossipsub">

<h3 class="section-header">
  Gossipsub for broadcasts
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__libp2p__kad_dht">

<h3 class="section-header">
  Kademlia DHT for Peer Routing
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__libp2p__fil_libp2p_nodes">

<h3 class="section-header">
  Filecoin libp2p Nodes
</h3>

<div class="section-content">






































</div>



</div>

  


</div>

  

  
    








<div id="libraries__ipfs">

<h2 class="section-header">
  IPFS - InterPlanetary File System
</h2>

<div class="section-content">






































</div>


  
    








<div id="libraries__ipfs__bitswap">

<h3 class="section-header">
  BitSwap
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipfs__graphsync">

<h3 class="section-header">
  GraphSync
</h3>

<div class="section-content">






































</div>



</div>

  

  
    








<div id="libraries__ipfs__unixfs">

<h3 class="section-header">
  UnixFS
</h3>

<div class="section-content">






































</div>



</div>

  


</div>

  

  
    








<div id="libraries__multiformats">

<h2 class="section-header">
  Multiformats - self describing protocol values
</h2>

<div class="section-content">




































<h3 id="multihash---self-describing-hash-values">Multihash - self describing hash values</h3>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Multihash</span> <span class="nx">Bytes</span>
</code></pre></div>





<h3 id="multiaddr---self-describing-network-addresses">Multiaddr - self describing network addresses</h3>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Multiaddr</span> <span class="nx">Bytes</span>
</code></pre></div>







</div>



</div>

  


</div>

  

  
    








<div id="algorithms">

<h1 class="section-header">
  Algorithms
</h1>

<div class="section-content">






































</div>


  
    








<div id="algorithms__expected_consensus">

<h2 class="section-header">
  Expected Consensus
</h2>

<div class="section-content">




































<div id="algorithms__expected_consensus__expected_consensus"></div>
<h4 id="algorithm">Algorithm</h4>
<p>Expected Consensus (EC) is a probabilistic Byzantine fault-tolerant consensus protocol. At a high level, it operates by running a leader election every round in which, on expectation, one participant may be eligible to submit a block. EC guarantees that this winner will be anonymous until they reveal themselves by submitting a proof of their election. The miner can submit a number of such proofs per round and will be rewarded proportionally. Each proof can be derived from a <code>Challenge Ticket</code> produced by the <a href="./#algorithms__post__election_post">Election PoSt</a>. All valid blocks submitted in a given round form a <code>Tipset</code>. Every block in a Tipset adds weight to its chain. The &lsquo;best&rsquo; chain is the one with the highest weight, which is to say that the fork choice rule is to choose the heaviest known chain. For more details on how to select the heaviest chain, see <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a>.</p>
<p>At a very high level, with every new block generated, a miner will craft a new ticket from the prior one in the chain appended with the current epoch number (i.e. parentTipset.epoch + 1 to start). While on expectation at least one block will be generated at every round, in cases where no one finds a block in a given round, a miner will increment the round number and attempt a new leader election (using the new input) thereby ensuring liveness in the protocol.</p>
<p>The <a href="./#systems__filecoin_blockchain__storage_power_consensus___index">Storage Power Consensus</a> subsystem uses access to EC to use the following facilities:</p>
<ul>
<li>Access to verifiable randomness for the protocol, derived from <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Tickets</a>.</li>
<li>Running and verifying <a href="./#algorithms__expected_consensus__leader_election">leader election</a> for block generation.</li>
<li>Access to a weighting function enabling <a href="./#algorithms__expected_consensus__chain_selection">Chain Selection</a> by the chain manager.</li>
<li>Access to the most recently <a href="./#algorithms__expected_consensus__finality">finalized tipset</a> available to all protocol participants.</li>
</ul>
<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
<span class="kn">import</span> <span class="nx">chain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/chain&#34;</span>
<span class="kn">import</span> <span class="nx">spowact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_power&#34;</span>

<span class="kd">type</span> <span class="nx">ExpectedConsensus</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">expectedLeadersPerEpoch</span>  <span class="nx">UVarint</span>
    <span class="nx">expectedRewardPerEpoch</span>   <span class="nx">UVarint</span>

    <span class="nf">ComputeChainWeight</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span>
    <span class="nf">IsValidConsensusFault</span><span class="p">(</span><span class="nx">faults</span> <span class="nx">spowact</span><span class="p">.</span><span class="nx">ConsensusFaultType</span><span class="p">,</span> <span class="nx">blocks</span> <span class="p">[</span><span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">])</span> <span class="kt">bool</span>
    <span class="nf">IsWinningChallengeTicket</span><span class="p">(</span>
        <span class="nx">challengeTicket</span>    <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>
        <span class="nx">sectorPower</span>        <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span>
        <span class="nx">networkPower</span>       <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span>
        <span class="nx">numSectorsSampled</span>  <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
        <span class="nx">numSectorsMiner</span>    <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span>
    <span class="p">)</span> <span class="kt">bool</span>

    <span class="nf">log2b</span><span class="p">(</span><span class="nx">x</span> <span class="nx">UVarint</span><span class="p">)</span> <span class="nx">UVarint</span>
    <span class="nx">wParams</span> <span class="nx">weightFunctionParameters</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">weightFunctionParameters</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">wRatio_num</span>  <span class="nx">UVarint</span>
    <span class="nx">wRatio_den</span>  <span class="nx">UVarint</span>
    <span class="nx">wPrecision</span>  <span class="nx">UVarint</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">storage_power_consensus</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;math/big&#34;</span>

	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">spowact</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin/storage_power&#34;</span>
	<span class="nx">block</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/block&#34;</span>
	<span class="nx">chain</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_blockchain/struct/chain&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">ExpectedConsensus_I</span><span class="p">)</span> <span class="nf">ComputeChainWeight</span><span class="p">(</span><span class="nx">tipset</span> <span class="nx">chain</span><span class="p">.</span><span class="nx">Tipset</span><span class="p">)</span> <span class="nx">block</span><span class="p">.</span><span class="nx">ChainWeight</span> <span class="p">{</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="k">return</span> <span class="nx">block</span><span class="p">.</span><span class="nf">ChainWeight</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="c1">// see expected_consensus.md for detail
</span><span class="c1"></span>
	<span class="c1">// wPowerFactor := self.log2b(spa.GetTotalPower())
</span><span class="c1"></span>	<span class="c1">// wBlocksFactor_num := (wPowerFactor * len(tipset.Blocks) * self.wParams.wRatio_num)
</span><span class="c1"></span>	<span class="c1">// wBlocksFactor_den := self.expectedLeadersPerEpoch * self.wParams.wRatio_den
</span><span class="c1"></span>	<span class="c1">// return tipset.ParentTipset.ChainWeight
</span><span class="c1"></span>	<span class="c1">// 	+wPowerFactor * self.wParams.wPrecision
</span><span class="c1"></span>	<span class="c1">// 	+(wBlocksFactor_num * self.wParams.wPrecision / wBlocksFactor_den)
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">ExpectedConsensus_I</span><span class="p">)</span> <span class="nf">IsValidConsensusFault</span><span class="p">(</span><span class="nx">faults</span> <span class="nx">spowact</span><span class="p">.</span><span class="nx">ConsensusFaultType</span><span class="p">,</span> <span class="nx">blocks</span> <span class="p">[]</span><span class="nx">block</span><span class="p">.</span><span class="nx">Block</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">util</span><span class="p">.</span><span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="k">return</span> <span class="kc">false</span>

	<span class="c1">// validation checks before calling this method
</span><span class="c1"></span>	<span class="c1">// - there should be exactly two block headers in proof
</span><span class="c1"></span>	<span class="c1">// - block1 and block2 are two different blocks
</span><span class="c1"></span>	<span class="c1">// - both blocks are mined by the same miner
</span><span class="c1"></span>	<span class="c1">// - block1 is of the same or lower block height as block2
</span><span class="c1"></span>
	<span class="c1">// 1. double-fork mining fault
</span><span class="c1"></span>	<span class="c1">// return block1.Epoch == block2.Epoch
</span><span class="c1"></span>
	<span class="c1">// 2. time-offset mining fault
</span><span class="c1"></span>	<span class="c1">// return block1.Epoch != block2.Epoch
</span><span class="c1"></span>	<span class="c1">// &amp;&amp; block1.Parents == block2.Parents
</span><span class="c1"></span>
	<span class="c1">// 3. parent grinding fault
</span><span class="c1"></span>	<span class="c1">// return block2.Epoch - block1.Epoch == 1
</span><span class="c1"></span>	<span class="c1">// &amp;&amp; !block2.Parents.include(block1)
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">ExpectedConsensus_I</span><span class="p">)</span> <span class="nf">IsWinningChallengeTicket</span><span class="p">(</span><span class="nx">challengeTicket</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">sectorPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span> <span class="nx">networkPower</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">StoragePower</span><span class="p">,</span> <span class="nx">numSectorsSampled</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">,</span> <span class="nx">numSectorsMiner</span> <span class="nx">util</span><span class="p">.</span><span class="nx">UVarint</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// Conceptually we are mapping the pseudorandom, deterministic hash output of the challenge ticket onto [0,1]
</span><span class="c1"></span>	<span class="c1">// by dividing by 2^HashLen and comparing that to the sector&#39;s target.
</span><span class="c1"></span>	<span class="c1">// if the challenge ticket hash / max hash val &lt; sectorPower / totalPower * ec.ExpectedLeaders * numSectorsMiner / numSectorsSampled
</span><span class="c1"></span>	<span class="c1">// it is a winning challenge ticket.
</span><span class="c1"></span>	<span class="c1">// note that the sectorPower may differ based on the challenged sector
</span><span class="c1"></span>
	<span class="c1">// lhs := challengeTicket * totalPower * numSectorsSampled
</span><span class="c1"></span>	<span class="c1">// rhs := maxTicket * activeSectorPower * numSectorsMiner * self.ExpectedLeaders
</span><span class="c1"></span>	<span class="nx">lhs</span> <span class="o">:=</span> <span class="nx">util</span><span class="p">.</span><span class="nf">BigFromBytes</span><span class="p">(</span><span class="nx">challengeTicket</span><span class="p">[:])</span>
	<span class="nx">lhs</span> <span class="p">=</span> <span class="nx">lhs</span><span class="p">.</span><span class="nf">Mul</span><span class="p">(</span><span class="nx">lhs</span><span class="p">,</span> <span class="nx">util</span><span class="p">.</span><span class="nf">BigFromUint64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">networkPower</span><span class="p">)))</span>
	<span class="nx">lhs</span> <span class="p">=</span> <span class="nx">lhs</span><span class="p">.</span><span class="nf">Mul</span><span class="p">(</span><span class="nx">lhs</span><span class="p">,</span> <span class="nx">util</span><span class="p">.</span><span class="nf">BigFromUint64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">numSectorsSampled</span><span class="p">)))</span>

	<span class="c1">// TODO: remove const here
</span><span class="c1"></span>	<span class="nx">SHA256Len</span> <span class="o">:=</span> <span class="mi">256</span>
	<span class="c1">// sectorPower * 2^len(H)
</span><span class="c1"></span>	<span class="nx">rhs</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">big</span><span class="p">.</span><span class="nx">Int</span><span class="p">).</span><span class="nf">Lsh</span><span class="p">(</span><span class="nx">util</span><span class="p">.</span><span class="nf">BigFromUint64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">sectorPower</span><span class="p">)),</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">SHA256Len</span><span class="p">))</span>
	<span class="nx">rhs</span> <span class="p">=</span> <span class="nx">rhs</span><span class="p">.</span><span class="nf">Mul</span><span class="p">(</span><span class="nx">rhs</span><span class="p">,</span> <span class="nx">util</span><span class="p">.</span><span class="nf">BigFromUint64</span><span class="p">(</span><span class="nb">uint64</span><span class="p">(</span><span class="nx">numSectorsMiner</span><span class="p">)))</span>
	<span class="nx">rhs</span> <span class="p">=</span> <span class="nx">rhs</span><span class="p">.</span><span class="nf">Mul</span><span class="p">(</span><span class="nx">rhs</span><span class="p">,</span> <span class="nx">big</span><span class="p">.</span><span class="nf">NewInt</span><span class="p">(</span><span class="nb">int64</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nf">expectedLeadersPerEpoch</span><span class="p">())))</span>

	<span class="c1">// lhs &lt; rhs?
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">lhs</span><span class="p">.</span><span class="nf">Cmp</span><span class="p">(</span><span class="nx">rhs</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div>




</p>
<h4 id="tickets-in-ec">Tickets in EC</h4>
<p>Within SPC, a miner generates a new ticket in their block for every ticket they use running leader election, thereby ensuring the ticket chain is always as long as the block chain.</p>
<p>Tickets are used to achieve the following:</p>
<ul>
<li>Ensure leader secrecy &ndash; meaning a block producer will not be known until they release their block to the network.</li>
<li>Prove leader election &ndash; meaning a block producer can be verified by any participant in the network.</li>
</ul>
<p>In practice, EC defines two different fields within a block:</p>
<ul>
<li>A <code>Ticket</code> field ‚Äî this stores the new ticket generated during this block generation attempt. It is from this ticket that miners will sample randomness to run leader election in <code>K</code> rounds (see <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Tickets</a>).</li>
<li>A set of winning <code>ChallengeTickets</code> ‚Äî this stores a proof that a given miner has won a leader election using the appropriate ticket generated by the election PoSt process with randomness <code>K</code> rounds back. It proves that the leader was validly elected in this epoch.</li>
</ul>
<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
<span class="kn">import</span> <span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
<span class="kn">import</span> <span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>

<span class="kd">type</span> <span class="nx">Ticket</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">VRFResult</span>  <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFResult</span>

    <span class="nx">Output</span>     <span class="nx">Bytes</span>                <span class="err">@</span><span class="p">(</span><span class="nx">cached</span><span class="p">)</span>
    <span class="nf">DrawRandomness</span><span class="p">(</span><span class="nx">round</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Bytes</span>
    <span class="nf">ValidateSyntax</span><span class="p">()</span> <span class="kt">bool</span>
    <span class="nf">Verify</span><span class="p">(</span>
        <span class="nx">input</span>           <span class="nx">Bytes</span>
        <span class="nx">pk</span>              <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFPublicKey</span>
        <span class="nx">minerActorAddr</span>  <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span>
    <span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">block</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">acrypto</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/crypto&#34;</span>
	<span class="nx">filcrypto</span> <span class="s">&#34;github.com/filecoin-project/specs/algorithms/crypto&#34;</span>
	<span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">tix</span> <span class="o">*</span><span class="nx">Ticket_I</span><span class="p">)</span> <span class="nf">ValidateSyntax</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">tix</span><span class="p">.</span><span class="nx">VRFResult_</span><span class="p">.</span><span class="nf">ValidateSyntax</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">tix</span> <span class="o">*</span><span class="nx">Ticket_I</span><span class="p">)</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">filcrypto</span><span class="p">.</span><span class="nx">VRFPublicKey</span><span class="p">,</span> <span class="nx">minerActorAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">input</span> <span class="o">:=</span> <span class="nx">acrypto</span><span class="p">.</span><span class="nf">DeriveRandWithMinerAddr</span><span class="p">(</span><span class="nx">acrypto</span><span class="p">.</span><span class="nx">DomainSeparationTag_TicketProduction</span><span class="p">,</span> <span class="nx">randomness</span><span class="p">,</span> <span class="nx">minerActorAddr</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">tix</span><span class="p">.</span><span class="nx">VRFResult_</span><span class="p">.</span><span class="nf">Verify</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">pk</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">tix</span> <span class="o">*</span><span class="nx">Ticket_I</span><span class="p">)</span> <span class="nf">DrawRandomness</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">acrypto</span><span class="p">.</span><span class="nf">DeriveRandWithEpoch</span><span class="p">(</span><span class="nx">acrypto</span><span class="p">.</span><span class="nx">DomainSeparationTag_TicketDrawing</span><span class="p">,</span> <span class="nx">tix</span><span class="p">.</span><span class="nf">Output</span><span class="p">(),</span> <span class="nb">int</span><span class="p">(</span><span class="nx">epoch</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>




</p>
<pre><code>But why the randomness lookback?

The randomness lookback helps turn independent ticket generation from a block one round back
into a global ticket generation game instead. Rather than having a distinct chance of winning or losing
for each potential fork in a given round, a miner will either win on all or lose on all
forks descended from the block in which the ticket is sampled.

This is useful as it reduces opportunities for grinding, across forks or sybil identities.

However this introduces a tradeoff:

- The randomness lookback means that a miner can know K rounds in advance that they will win,
decreasing the cost of running a targeted attack (given they have local predictability).

How is K selected?

- On the one end, there is no advantage to picking K larger than finality.
- On the other, making K smaller reduces adversarial power to grind.
</code></pre><div id="algorithms__expected_consensus__leader_election"></div>
<h4 id="secret-leader-election">Secret Leader Election</h4>
<p>Expected Consensus is a consensus protocol that works by electing a miner from a weighted set in proportion to their power. In the case of Filecoin, participants and powers are drawn from the <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table">Power Table</a>, where power is equivalent to storage provided through time.</p>
<p>Leader Election in Expected Consensus must be Secret, Fair and Verifiable. This is achieved through the use of randomness used to run the election. In the case of Filecoin&rsquo;s EC, the blockchain tracks an independent ticket chain. These tickets are used as randomness inputs for Leader Election. Every block generated references winning <code>ChallengeTickets</code> generated using a past ticket. The ticket chain is extended by the miner who generates a new block for each successful leader election.</p>
<h5 id="running-a-leader-election">Running a leader election</h5>
<p>Now, a miner must also check whether they are eligible to mine a block in this round.</p>
<p>Design goals here include:</p>
<ul>
<li>Miners should be rewarded proportional to their power in the system</li>
<li>The system should be able to tune how many blocks are put out per epoch on expectation (hence &ldquo;expected consensus&rdquo;).</li>
</ul>
<p>As discussed in <a href="./#algorithms__post__election_post">Election PoSt</a>, a miner will use the challenge ticket of an ElectionPoSt to uniformly draw a value from 0 to 1 when crafting a block.</p>
<p>The miner gets to draw one such challenge ticket per sector they have committed and must then compare the value derived from the challenge ticket against a target to determine whether they are eligible to mine. This is called finding a winning ticket.</p>
<p>The target is set as follows, for each sector sampled for a ticket from the miner&rsquo;s <code>ProvingSet</code> and the number of sectors in the set:
<code>target = activePowerInSector/networkPower * EC.ExpectedLeadersPerEpoch * numSectorsMiner / numSectorsSampled</code></p>
<p>The target ensures that the miner can express the power across all of their sectors through the tickets they have sampled. Specifically, on expectation, checking <code>numSectorsSampled</code> (with <code>numSectorsSampled = ceil(len(provingSet) * EPoStSampleRate)</code>) challenge tickets in every epoch, a miner will find <code>minerPower/networkPower * EC.ExpectedLeadersPerEpoch</code> winning tickets per epoch on expectation. Note that while the sectorPower may differ based on the challenged sector, i.e. in any given epoch a miner may have an advantage (if picking sectors with more than the average across all their sectors) or a disadvantage (conversely) in their election; but over multiple epochs, on expectation the election will be fair.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">We elaborate on the above claim:

We want the miner&#39;s expected wins over time to be equal to w = minerPower/networkPower * EC.ExpectedLeadersPerEpoch

Take P to be the average miner power over the N sectors in their ProvingSet.
We have P = SUM_{i=0}^N P_i / N

The miner&#39;s likelihood of winning an election in any epoch is, for C tickets randomly drawn
W = C * target = C * P_i/networkPower * EC.ExpectedLeadersPerEpoch * N/C = N * P_i/networkPower * EC.ExpectedLeadersPerEpoch

with N * P_i ~= minerPower on expectation over enough epochs. That is to say: W = minerPower/networkPower * EC.ExpectedLeadersPerEpoch as wanted.
</code></pre></div><p>We show this below, removing division for ease of implementation:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">const maxChallengeTicketSize = 2^len(H)

def TicketIsWinner(challengeTicket):
    // Check that `ChallengeTicket &lt; Target`
    return challengeTicket * networkPower * numSectorsSampled &lt; activePowerInSector * EC.ExpectedLeadersPerEpoch * maxChallengeTicketSize * numSectorsMiner
</code></pre></div><p>If the miner finds any winning ticket in this round, it can use it, along with a new randomness ticket to generate and publish a new block. Otherwise, it waits to hear of another block generated in this round.</p>
<p>We also use the VRF from <a href="./#algorithms__crypto__vrf">Verifiable Random Function</a> to draw randomness as part of crafting the Challenge Tickets in order to ensure leader election is secret (a miner cannot be known to win until they publish their ticket on the chain).</p>
<p>It is important to note that every block contains three artifacts: one, a ticket derived from last block&rsquo;s ticket to extend the ticket-chain, two, a challenge ticket array PoSt process run in this epoch, and three a PoStProof to prove each ChallengeTicket was derived correctly.</p>
<h5 id="election-validation">Election Validation</h5>
<p>In order to determine that the mined block was generated by an eligible miner, one must check its <code>ChallengeTickets</code>&rsquo; validity and that they were generated appropriately by the PoSt generator. Thereafter, for each ticket the miner must check that it is a winning challenge ticket, per the above definition.</p>
<div id="algorithms__expected_consensus__chain_selection"></div>
<h4 id="chain-selection">Chain Selection</h4>
<p>Just as there can be 0 miners win in a round, multiple miners can be elected in a given round. This in turn means multiple blocks can be created in a round, as seen above. In order to avoid wasting valid work done by miners, EC makes use of all valid blocks generated in a round.</p>
<h5 id="chain-weighting">Chain Weighting</h5>
<p>It is possible for forks to emerge naturally in Expected Consensus. EC relies on weighted chains in order to quickly converge on &lsquo;one true chain&rsquo;, with every block adding to the chain&rsquo;s weight. This means the heaviest chain should reflect the most amount of work performed, or in Filecoin&rsquo;s case, the most storage provided.</p>
<p>In short, the weight at each block is equal to its <code>ParentWeight</code> plus that block&rsquo;s delta weight. Details of Filecoin&rsquo;s chain weighting function <a href="https://observablehq.com/d/3812cd65c054082d">are included here</a>.</p>
<p>Delta weight is a term composed of a few elements:</p>
<ul>
<li>wForkFactor: which seeks to cut the weight derived from rounds in which produced Tipsets do not correspond to what an honest chain is likely to have yielded (pointing to selfish mining or other non-collaborative miner behavior).</li>
<li>wPowerFactor: which adds weight to the chain proportional to the total power backing the chain, i.e. accounted for in the chain&rsquo;s power table.</li>
<li>wBlocksFactor: which adds weight to the chain proportional to the number of blocks mined in a given round. Like wForkFactor, it rewards miner cooperation (which will yield more blocks per round on expectation).</li>
</ul>
<p>The weight should be calculated using big integer arithmetic with order of operations defined above. We use brackets instead of parentheses below for legibility. We have:</p>
<p><code>w[r+1] = w[r] + (wPowerFactor[r+1] + wBlocksFactor[r+1]) * 2^8</code></p>
<p>For a given tipset <code>ts</code> in round <code>r+1</code>, we define:</p>
<ul>
<li><code>wPowerFactor[r+1]  = wFunction(totalPowerAtTipset(ts))</code></li>
<li>wBlocksFactor[r+1] =  <code>wPowerFactor[r+1] * wRatio * b / e</code>
<ul>
<li>with <code>b = |blocksInTipset(ts)|</code></li>
<li><code>e = expected number of blocks per round in the protocol</code></li>
<li>and <code>wRatio in ]0, 1[</code>
Thus, for stability of weight across implementations, we take:</li>
</ul>
</li>
<li>wBlocksFactor[r+1] =  <code>(wPowerFactor[r+1] * b * wRatio_num) / (e * wRatio_den)</code></li>
</ul>
<p>We get:</p>
<ul>
<li><code>w[r+1] = w[r] + wFunction(totalPowerAtTipset(ts)) * 2^8 + (wFunction(totalPowerAtTipset(ts)) * len(ts.blocks) * wRatio_num * 2^8) / (e * wRatio_den)</code>
Using the 2^8 here to prevent precision loss ahead of the division in the wBlocksFactor.</li>
</ul>
<p>The exact value for these parameters remain to be determined, but for testing purposes, you may use:</p>
<ul>
<li><code>e = 5</code></li>
<li><code>wRatio = .5, or wRatio_num = 1, wRatio_den = 2</code></li>
<li><code>wFunction = log2b</code> with
<ul>
<li><code>log2b(X) = floor(log2(x)) = (binary length of X) - 1</code> and <code>log2b(0) = 0</code>. Note that that special case should never be used (given it would mean an empty power table.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh">Note that <span class="k">if</span> your implementation does not allow <span class="k">for</span> rounding to the fourth decimal, miners should apply the <span class="o">[</span>tie-breaker below<span class="o">](</span><span class="c1">#selecting-between-tipsets-with-equal-weight). Weight changes will be on the order of single digit numbers on expectation, so this should not have an outsized impact on chain consensus across implementations.</span>
</code></pre></div><p><code>ParentWeight</code> is the aggregate chain weight of a given block&rsquo;s parent set. It is calculated as
the <code>ParentWeight</code> of any of its parent blocks (all blocks in a given Tipset should have
the same <code>ParentWeight</code> value) plus the delta weight of each parent. To make the
computation a bit easier, a block&rsquo;s <code>ParentWeight</code> is stored in the block itself (otherwise
potentially long chain scans would be required to compute a given block&rsquo;s weight).</p>
<h5 id="selecting-between-tipsets-with-equal-weight">Selecting between Tipsets with equal weight</h5>
<p>When selecting between Tipsets of equal weight, a miner chooses the one with the smallest final ticket.</p>
<p>In the case where two Tipsets of equal weight have the same min ticket, the miner will compare the next smallest ticket (and select the Tipset with the next smaller ticket). This continues until one Tipset is selected.</p>
<p>The above case may happen in situations under certain block propagation conditions. Assume three blocks B, C, and D have been mined (by miners 1, 2, and 3 respectively) off of block A, with minTicket(B) &lt; minTicket(C) &lt; minTicket(D).</p>
<p>Miner 1 outputs their block B and shuts down. Miners 2 and 3 both receive B but not each others&rsquo; blocks. We have miner 2 mining a Tipset made of B and C and miner 3 mining a Tipset made of B and D. If both succesfully mine blocks now, other miners in the network will receive new blocks built off of Tipsets with equal weight and the same smallest ticket (that of block B). They should select the block mined atop [B, C] since minTicket(C) &lt; minTicket(D).</p>
<p>The probability that two Tipsets with different blocks would have all the same tickets can be considered negligible: this would amount to finding a collision between two 256-bit (or more) collision-resistant hashes.</p>
<div id="algorithms__expected_consensus__finality"></div>
<h4 id="finality-in-ec">Finality in EC</h4>
<p>EC enforces a version of soft finality whereby all miners at round N will reject all blocks that fork off prior to round N-F. For illustrative purposes, we can take F to be 500. While strictly speaking EC is a probabilistically final protocol, choosing such an F simplifies miner implementations and enforces a macroeconomically-enforced finality at no cost to liveness in the chain.</p>
<div id="algorithms__expected_consensus__consensus_faults"></div>
<h4 id="consensus-faults">Consensus Faults</h4>
<p>Due to the existence of potential forks in EC, a miner can try to unduly influence protocol fairness. This means they may choose to disregard the protocol in order to gain an advantage over the power they should normally get from their storage on the network. A miner should be slashed if they are provably deviating from the honest protocol.</p>
<p>This is detectable when a given miner submits two blocks that satisfy any of the following &ldquo;consensus faults&rdquo;:</p>
<ul>
<li>
<p>(1) <code>double-fork mining fault</code>: two blocks mined at the same epoch.












<div class="diagram">

<span class="diagram-title">Double-Fork Mining Fault</span>




(<a href="docs/algorithms/expected_consensus/diagrams/double_fork.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/algorithms/expected_consensus/diagrams/double_fork.dot.svg" />




</div>
</p>
</li>
<li>
<p>(2) <code>time-offset mining fault</code>: two blocks mined off of the same Tipset at different epochs (i.e. with different <code>ChallengeTickets</code> generated from the same input ticket).












<div class="diagram">

<span class="diagram-title">Time-Offset Mining Fault</span>




(<a href="docs/algorithms/expected_consensus/diagrams/time_offset.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/algorithms/expected_consensus/diagrams/time_offset.dot.svg" />




</div>
</p>
</li>
<li>
<p>(3) <code>parent-grinding fault</code>: one block&rsquo;s parent is a Tipset that provably should have included a given block but does not. While it cannot be proven that a missing block was willfully omitted in general (i.e. network latency could simply mean the miner did not receive a particular block), it can when a miner has successfully mined a block two epochs in a row and omitted one. That is, this condition should be evoked when a miner omits their own prior block. When a miner&rsquo;s block at epoch e + 1 references a Tipset that does not include the block they mined at e both blocks can be submitted to prove this fault.












<div class="diagram">

<span class="diagram-title">Parent-Grinding fault</span>




(<a href="docs/algorithms/expected_consensus/diagrams/parent_grinding.dot.svg" target="_blank">open in new tab</a>)
<br />
<img src="docs/algorithms/expected_consensus/diagrams/parent_grinding.dot.svg" />




</div>
</p>
</li>
</ul>
<p>Any node that detects any of the above events should submit both block headers to the <code>StoragePowerActor</code>'s <code>ReportConsensusFault</code> method. The &ldquo;slasher&rdquo; will receive a portion of the offending miner&rsquo;s <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__pledge_collateral">Pledge Collateral</a> as a reward for notifying the network of the fault. Consensus faults (except for <code>uncommitted power fault</code> below which falls under storage faults with impact on consensus) will tentatively result in all pledge collateral being slashed and the miner removed from the power table. Some portion of the pledge collateral is given to the slasher as a function of some initial share (<code>SLASHER_INITIAL_SHARE</code>) and growth rate (<code>SLASHER_SHARE_GROWTH_RATE</code>). Slasher&rsquo;s share of the slashed collateral increases as block elapses since the block when the fault is committed. Default growth rate results in slasher&rsquo;s share reaches 1 after 250 blocks. However, only the first slasher gets its share of the pledge collateral and the remaining pledge collateral will be burned. The longer a slasher waits, the higher the likelihood that the slashed collateral will be claimed by another slasher.</p>
<p>It is important to note that there exists a third type of consensus fault directly reported by the <code>CronActor</code> on <code>StorageDeal</code> failures via the <code>ReportUncommittedPowerFault</code> method:</p>
<ul>
<li>(4) <code>uncommitted power fault</code> which occurs when a miner fails to submit their <code>PostProof</code> and is thus participating in leader election with undue power (see <a href="./#systems__filecoin_markets__storage_market__faults">Storage Faults</a>).</li>
</ul>


</div>



</div>

  

  
    








<div id="algorithms__porep">

<h2 class="section-header">
  Proof-of-Replication
</h2>

<div class="section-content">




































<p>See <a href="https://filecoin.io/filecoin.pdf">Filecoin Paper</a></p>


</div>


  
    








<div id="algorithms__porep__stacked_drg">

<h3 class="section-header">
  Stacked DRG PoRep
</h3>

<div class="section-content">




































<p>This section describes <em>Stacked DRG PoRep</em> (SDR), the specific Proof-of-Replication (PoRep) used in Filecoin. In this construction, the prover encodes the original data into a replica and commits to it. An offline PoRep proves that the commitment to the replica is a valid commitment of the encoded original data.</p>
<p>SDR has been presented by <a href="https://eprint.iacr.org/2018/702.pdf">Ben Fisch at EUROCRYPT19</a>.</p>
<h4 id="introduction">Introduction</h4>
<h5 id="background-on-proof-of-replication">Background on Proof-of-Replication</h5>
<p><em>Proof-of-Replication</em> enables a prover <em>P</em> to convince a verifier <em>V</em> that <em>P</em> is storing a replica <em>R</em>, a physically independent copy of some data <em>D</em>, unique to <em>P</em>. The scheme is defined by a tuple of polynomial time algorithms (<em>Setup</em>, Replication, <em>Prove</em>, <em>Verify</em>). The assumption is that generation of a replica after <em>Replicate</em>  must be difficult (if not impossible) to generate.</p>
<ul>
<li><em>Setup</em>: On setup, the public parameters of the proving systems are set.</li>
<li><em>Replicate</em>: On replication, either a party or both (depending on the scheme, in our case the prover only!) generate a unique permutation of the original data <em>D</em>, which we call replica <em>R</em>.</li>
<li><em>Prove</em>: On receiving a challenge, the prover must generate a proof that it is in possession of the replica and that it was derived from data <em>D</em>. The prover must only be able to respond to the challenge successfully if it is in possession of the replica, since would be difficult (if not impossible) to generate a replica that can be used to generate the proof at this stage</li>
<li><em>Verify</em>: On receiving the proof, the verifier checks the validity of the proof and accepts or rejects the proof.</li>
</ul>
<!-- raw HTML omitted -->
<h5 id="time-bounded-proof-of-replication">Time-bounded Proof-of-Replication</h5>
<p><strong>Timing assumption</strong>. <em>Time-bounded Proof-of-Replication</em> are constructions of PoRep with timing assumptions. The assumption is that generation of the replica (hence the <em>Replication</em>) takes some time <em>t</em> that is substantially larger than the time it takes to produce a proof (hence <em>time(Prove)</em>) and the round-trip time (<em>RTT</em>) for sending a challenge and receiving a proof.</p>
<p><strong>Distinguishing Malicious provers</strong>. A malicious prover that does not have <em>R</em>, must obtain it (or generate it), before the <em>Prove</em> step. A verifier can distinguish an honest prover from a malicious prover, since the malicious one will take too long to answer the challenge. A verifier will reject if receiving the proof from the prover takes longer than a timeout (bounded between proving time and replication time).</p>
<h5 id="background-on-stacked-drg-porep">Background on Stacked DRG PoRep</h5>
<p><em>Stacked DRG PoRep</em> (SDR) is a specific Proof-of-Replication construction that we use in Filecoin. SDR has been designed by <a href="https://eprint.iacr.org/2018/702.pdf">Ben Fisch at EUROCRYPT19</a>.  At a high level, SDR ensures that the <em>Replicate</em> step is a slow non-parallelizable sequential process by using a special type of graph called Depth Robust Graphs (DRG).</p>
<p><strong>Encoding using DRGs</strong>. A key is generated by sequentially labeling nodes in the graph such that each label depends on the labels of its parents. The depth robustness property of these graphs ensure that the sequential labeling steps are not parallelizable. The final labels are used as a key to encode the original data.</p>
<p>TODO: This probably needs a more thorough rewrite.</p>
<p>** Stacked DRGs**. SDR builds on the above by stacking DRG graphs into <code>LAYERS</code> layers. Each layer is connected to the previous by a Bipartite Expander Graph. The combination of DRGs and expander graphs guarantee the security property of PoRep. As before, the key produced by the final layer is used to encode the original data, yielding the replica.</p>
<p><strong>Generating SDR proofs</strong>. Given the following public parameters:</p>
<ul>
<li><code>ReplicaId</code> is a unique replica identifier (see the Filecoin Proofs spec for details).</li>
<li><code>CommD</code> is the Merkle tree root hash of the input data to the first layer.</li>
<li><code>CommC</code> is the Merkle tree root hash of the SDR column commitments.</li>
<li><code>CommRLast</code> is the Merkle tree root hash of the replica.</li>
<li><code>CommR</code> is the on-chain commitment to the replica, dervied as the hash of the concatenation of <code>CommC</code> and <code>CommRLast</code>.</li>
</ul>
<p>An SDR proof proves that some data whose committment is <code>CommD</code> has been used to run a <code>Replicate</code> algorithm and generated some data. <code>CommR</code> is the on-chain commitment to both the replicated data and to intermediate stages required to prove <code>Replicate</code> was performed correctly.</p>
<p>An SDR proof consists of a set of challenged DRG nodes for each layer, a set of parent nodes for each challenged node and a Merkle tree inclusion proof for each node provided. The verifier can then verify the correct labeling of each node and that the nodes given were consistent with the prover&rsquo;s commitments.</p>
<p><strong>Making proofs succinct with SNARKs</strong>: The proof size in SDR is too large for blockchain usage (~100MB TODO: check this), mostly due to the large amount of Merkle tree inclusion proofs required to achieve security. We use SNARKs to generate a proof of knowledge of a correct SDR proof. In other words, we implement the SDR proof verification algorithm in an arithmetic circuit and use SNARKs to prove that it was evaluated correctly.</p>
<p>The SNARK circuit proves that given Merkle roots <code>CommD</code>, and <code>CommR</code>, the prover correctly derived the labels at each layer and correctly performed the final encoding.</p>
<h5 id="porep-in-filecoin">PoRep in Filecoin</h5>
<p>Proof-of-Replication proves that a Storage Miner is dedicating unique storage for each <em><strong>sector</strong></em>. Filecoin Storage Miners collect new clients&rsquo; data in a sector, run a slow encoding process (called <code>Seal</code>) and generate a proof (<code>SealProof</code>) that the encoding was generated correctly.</p>
<p>In Filecoin, PoRep provides two guarantees: (1) <em>space-hardness</em>: Storage Miners cannot lie about the amount of space they are dedicating to Filecoin in order to gain more power in the consensus; (2) <em>replication</em>: Storage Miners are dedicating unique storage for each copy of their clients data.</p>
<p>Glossary:</p>
<ul>
<li><strong><em>sector:</em></strong> a fixed-size block of data of <code>SECTOR_SIZE</code> bytes which generally contains clients&rsquo; data.</li>
<li><strong><em>unsealed sector:</em></strong> a concrete representation (on disk or in memory) of a sector&rsquo;s that follows the &ldquo;Storage Format&rdquo; described in <a href="client-data.md#storage-format">Client Data Processing</a> (currently <code>paddedfr32v1</code> is the required default).</li>
<li><strong><em>sealed sector:</em></strong>  a concrete representation (on disk or in memory) of the unique replica generated by <code>Seal</code> from an <strong><em>unsealed sector</em></strong>. A sector contains one or more <em><strong>pieces</strong></em>.</li>
<li><strong><em>piece:</em></strong> a block of data of at most <code>SECTOR_SIZE</code> bytes which is generally a client&rsquo;s file or part of.</li>
</ul>
<h4 id="stacked-drg-construction">Stacked DRG Construction</h4>
<h5 id="public-parameters">Public Parameters</h5>
<p>The following public parameters are used in the Stacked DRG Replication and Proof Generation algorithms:</p>
<p>TODO: the Appendix should explain why we picked those values
TODO: Just interpolate a table of the Orient parameters and reconcile naming.</p>
<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
<th align="right">value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SECTOR_SIZE</code></td>
<td><code>uint</code></td>
<td>Number of nodes in the DRG in bytes</td>
<td align="right"><code>68,719,476,736</code></td>
</tr>
<tr>
<td><code>LAYERS</code></td>
<td><code>uint</code></td>
<td>Number of Depth Robust Graph stacked layers.</td>
<td align="right"><code>10</code></td>
</tr>
<tr>
<td><code>BASE_DEGREE</code></td>
<td><code>uint</code></td>
<td>In-Degree of each Depth Robust Graph.</td>
<td align="right"><code>6</code></td>
</tr>
<tr>
<td><code>EXPANSION_DEGREE</code></td>
<td><code>uint</code></td>
<td>Degree of each Bipartite Expander Graph to extend dependencies between layers.</td>
<td align="right"><code>8</code></td>
</tr>
<tr>
<td><code>GRAPH_SEED</code></td>
<td><code>uint</code></td>
<td>Seed used for random number generation in <code>baseParents</code>.</td>
<td align="right"><code>TODO</code></td>
</tr>
<tr>
<td><code>NODE_SIZE</code></td>
<td><code>uint</code></td>
<td>Size of each node in bytes.</td>
<td align="right"><code>32B</code></td>
</tr>
</tbody>
</table>
<p>The following constants are computed from the public parameters:</p>
<table>
<thead>
<tr>
<th>name</th>
<th>type</th>
<th>description</th>
<th align="right">computation</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>PARENTS_COUNT</code></td>
<td><code>uint</code></td>
<td>Total number of parent nodes</td>
<td align="right"><code>EXPANSION_DEGREE + BASE_DEGREE</code></td>
<td><code>13</code></td>
</tr>
<tr>
<td><code>GRAPH_SIZE</code></td>
<td><code>uint</code></td>
<td>Number of nodes in the graph</td>
<td align="right"><code>SECTOR_SIZE / NODE_SIZE</code></td>
<td><code>2,147,483,648</code></td>
</tr>
<tr>
<td><code>TREE_DEPTH</code></td>
<td><code>uint</code></td>
<td>Height of the Merkle Tree of a sector</td>
<td align="right"><code>LOG_2(GRAPH_SIZE)</code></td>
<td><code>31</code></td>
</tr>
</tbody>
</table>
<p>The following additional public parameters are required:</p>
<ul>
<li><code>TAPER</code> : <code>Float</code>: Fraction of each layer&rsquo;s challenges by which to reduce next-lowest layer&rsquo;s challenge count.</li>
<li><code>TAPER_LAYERS</code>: <code>uint</code>: Number of layers which should be tapered. FIXME: update for current tapering.
<code>Data</code> is a byte array initialized to the content of <strong><em>unsealed sector</em></strong> and will be mutated in-place by the replication process.</li>
</ul>
<h5 id="hash-functions">Hash Functions</h5>
<p>We have describe three hash functions:</p>
<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>size of input</th>
<th>size of output</th>
<th>construction</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>KDFHash</code></td>
<td>Hash function used as a KDF to derive the key used to label a single node.</td>
<td>TODO</td>
<td><code>32B</code></td>
<td><code>SHA256</code></td>
</tr>
<tr>
<td><code>ColumnHash</code></td>
<td>Hash function used to hash the labeled leaves of each layer (see SDR Column Commitments).</td>
<td>TODO</td>
<td><code>32B</code></td>
<td><code>JubjubPedersen</code></td>
</tr>
<tr>
<td><code>RepCompress</code></td>
<td>Collision Resistant Hash function used for the Merkle tree.</td>
<td>2 x <code>32B</code> + integer height</td>
<td><code>32B</code></td>
<td><code>JubjubPedersen</code></td>
</tr>
<tr>
<td><code>RepHash</code></td>
<td>Balanced binary Merkle tree based used to generate commitments to sealed sectors, unsealed sectors, piece commitments, and intermediate parts of the Proof-of-Replication.</td>
<td>TODO</td>
<td><code>32B</code></td>
<td>Uses <code>RepCompress</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h6 id="rephash">RepHash</h6>
<p><code>RepHash</code> is a vector commitment used to generate commitments to sealed sectors, unsealed sectors, piece commitments and intermediate stepds of the Proof-of-Replication. Filecoin uses a balanced binary Merkle tree for <code>RepHash</code>. The leaves of the Merkle tree are pairs of adjacent nodes.</p>
<p><code>RepHash</code> inputs MUST respect a valid Storage Format. [TODO: What does this mean?]</p>
<h5 id="stacked-drg-graph">Stacked DRG Graph</h5>
<p>The slow sequential encoding required is enforced by the depth robusness property of the SDR graph.</p>
<p><strong>Encoding with SDR</strong>: The data from a sector (of size <code>SECTOR_SIZE</code>) is divided in <code>NODE_SIZE</code> nodes (for a total of <code>GRAPH_SIZE</code> nodes) and arranged in a directed acyclic graph. The structure of the graph is used to label the nodes sequentially to generate a key with which to encode the original data: in order to label a node, its parents must be labeled (see the &ldquo;Layer Labeling&rdquo; section below). We repeat this process for <code>LAYERS</code> layers, where the input to a next layer is the output of the previous one.</p>
<p><strong>Generating the SDR graph</strong>: The SDR graph is divided in <code>LAYERS</code> layers. Each layer is a directed acyclic graph and it combines a Depth Robust Graph (DRG) and a Bipartite Expander graph. [TODO: this isn&rsquo;t quite right.]</p>
<p>We provide an algorithm (<code>SDR</code>) which computes the parents of a node. In high level, the parents of a node are computed by combining two algorithms: some parents (<code>BASE_DEGREE</code> of them) are computed via the <code>BucketSample</code> algorithm extended with a direct ordering of nodes, others (<code>EXPANSION_DEGREE</code> of them) are computed via the <code>Chung</code> algorithm.</p>
<h6 id="sdrgraph-sdr-graph-algorithm"><code>SDRGraph</code>: SDR Graph algorithm</h6>
<p>Overview: Compute the DRG and Bipartite Expander parents using respectively <code>BucketSample</code> and <code>ChungExpander</code>.</p>
<h6 id="inputs">Inputs</h6>
<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>node</code></td>
<td>The node for which the parents are being computed</td>
<td><code>uint</code></td>
</tr>
<tr>
<td><code>layer</code></td>
<td>The layer of the SDR graph</td>
<td><code>uint</code></td>
</tr>
</tbody>
</table>
<h6 id="outputs">Outputs</h6>
<table>
<thead>
<tr>
<th>name</th>
<th>description</th>
<th>Type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>parents</code></td>
<td>The ordered parents of node <code>node</code> on layer <code>layer</code></td>
<td><code>[PARENTS_COUNT]uint</code></td>
</tr>
</tbody>
</table>
<h6 id="algorithm">Algorithm</h6>
<ul>
<li>
<p>If <code>layer = 1</code>:</p>
<ul>
<li>Compute <code>drgParents = BucketSample(node)</code></li>
<li>Set <code>parents</code> to be <code>drgParents</code>.</li>
</ul>
</li>
<li>
<p>If <code>layer &gt; 1</code>:</p>
<ul>
<li>Compute <code>drgParents = BucketSample(node)</code></li>
<li>Compute <code>expanderParents = ChungExpander(node)</code></li>
<li>Set <code>parents</code> to be the concatenation of <code>drgParents</code> and <code>expanderParents</code></li>
</ul>
</li>
</ul>
<p>We provide below a more succinct representation of the algorithm:</p>
<p>TODO: Reference to code in filproofs/algorithms.go  ‚Äî or restructure all this.</p>
<h6 id="time-space-tradeoff">Time-space tradeoff</h6>
<p>Computing the parents using both <code>BucketSample</code> and <code>ChungExpander</code> for every layer can be an expensive operation, however, this can be avoided by caching the parents.</p>
<h6 id="bucketsample-depth-robust-graphs-algorithm"><code>BucketSample</code>: Depth Robust Graphs algorithm</h6>
<p>This section describes how to compute the &ldquo;base parents&rdquo; of the SDR graph, which is the equivalent of computing the parents of a Depth Robust Graph.</p>
<p>The properties of DRG graphs guarantee that a sector has been encoded with a slow, non-parallelizable process. We use the <code>BucketSample</code> algorithm that is based on DRSample (<a href="https://acmccs.github.io/papers/p1001-alwenA.pdf">ABH17</a>) and described in <a href="https://web.stanford.edu/~bfisch/porep_short.pdf">FBGB18</a> and generates a directed acyclic graph of in-degree <code>BASE_DEGREE</code>.</p>
<p><code>BucketSample</code> DRG graphs are random graphs that can be deterministically generated from a seed; different seed lead with high probability to different graphs. In SDR, we use the same seed <code>GRAPH_SEED</code> for each layer of the SDR graph such that they are all based on the same underlying DRG graph.</p>
<p>The parents of any node can be locally computed without computing the entire graph. We call the parents of a node calculated in this way <em>base parents</em>.</p>
<p><code>BucketSample</code> extends <code>BucketSampleInner</code> to include the node&rsquo;s &lsquo;immediate predecessor&rsquo;. Each node except the first in a
DRG generated by <code>BucketSample</code> has the node whose index is one less than its own as a parent. This ensures that
visiting nodes whose indexes are sequential will result in a graph traversal in topological order.</p>
<h6 id="chungexpander-bipartite-expander-graphs"><code>ChungExpander</code>: Bipartite Expander Graphs</h6>
<p>TODO: explain why we link nodes in the current layer</p>
<p>Each node in layers other than the first has <code>EXPANSION_DEGREE</code> parents generated via the <code>ChungExpander</code>
algorithm. Note that the indexes returned refer to labels from the <em>previous</em> layer. TODO: Make this all clearer with explicit notation.</p>
<p>// TODO: link to relevant filproofs/algorithms.go</p>
<h6 id="time-space-tradeoff-1">Time-Space tradeoff</h6>
<p>Computing these parents can be expensive (especially due to the hashing required by the Feistel algorithm). A miner can trade this computation by storing the expansion parents.</p>
<h6 id="feistel-construction">Feistel construction</h6>
<p>We use three rounds of <code>Feistel</code> to generate a permutation to compute the parents of the Bipartite Expander graph.</p>
<p>TODO: link to filproofs/feistel</p>
<h4 id="replication">Replication</h4>
<blockquote>
<p>The Replication phase turns an <em>unsealed sector</em> into a <em>sealed sector</em> by first <em>generating a key</em>, then using the key to <em>encode the orignal data</em>.</p>
</blockquote>
<p>Before running the <code>Replicate</code> algorithm, the prover must ensure that the sector is correctly formatted with a valid &ldquo;Storage Format&rdquo; described in <a href="client-data.md#storage-format">Filecoin Client Data Processing</a> (currently <code>paddedfr32v1</code> is the required default).</p>
<p>TODO: inputs are missing</p>
<p>The Replication Algorithm  proceeds as follows:</p>
<ul>
<li>Calculate <code>ReplicaID</code> using <code>Hash</code> (SHA256):</li>
</ul>
<p><code>ReplicaID</code> is a 32-byte array constructed by hashing the concatenation of the following values:</p>
<ul>
<li><code>ProverId</code> is a 32-byte array uniquely identifying a prover.</li>
<li><code>SectorNumber</code> is an unsigned 64-bit integer in little-endian encoding represented as an 8-byte array.</li>
<li><code>RandomSeed</code> is a 32-byte array of randomness extracted from the chain.</li>
<li><code>CommD</code> is the Merkle root obtained by performing <code>RepHash</code> on the original data represented in <code>paddedfr32v1</code>.</li>
</ul>
<pre><code>ReplicaID := Hash(ProverID || SectorNumber || RandomSeed || CommD)
</code></pre><ul>
<li>Perform <code>RepHash</code> on <code>Data</code> to yield <code>CommD</code> and <code>TreeD</code>:</li>
</ul>
<pre><code>CommD, TreeD = RepHash(data)
</code></pre><h5 id="layer-labeling">Layer Labeling</h5>
<p>TODO: Define <code>Graph</code>. We need to decide if this is an object we&rsquo;ll explicitly define or if its properties (e.g., <code>GRAPH_SIZE</code>) are just part of the replication parameters and all the functions just refer to the <em>same</em> graphs being manipulated across the entire replication process. (At the moment I&rsquo;ve avoided defining a <code>Graph</code> structure as in other specs I didn&rsquo;t see any object methods, just standalone functions.)</p>
<p>// TODO: link to filproofs/algorithms</p>
<h4 id="proof-generation">Proof Generation</h4>
<p>Overview:</p>
<ul>
<li>Challenge Derivation</li>
<li>Proof Generation</li>
<li>Circuit Proof Generation</li>
</ul>
<p>TODO: write a single algorithm which includes the spec below</p>
<h5 id="challenge-generation">Challenge Generation</h5>
<p>TODO: Link to filproofs/algorithms</p>
<p>Calculate <code>LAYER_CHALLENGES : [LAYERS]uint</code>: Number of challenges per layer. (This will be passed to the SDR circuit proof.)</p>
<p>Derive challenges for each layer (call <code>DeriveChallenges()</code>).</p>
<h5 id="witness-generation">Witness Generation</h5>
<p>TODO: link to filproofs/algorithms</p>
<h5 id="layer-challenge-counts">Layer Challenge Counts</h5>
<p>TODO: we should just list current parameters and show this as a calculation for correctness, this should not mandatory to implement.</p>


</div>



</div>

  

  
    








<div id="algorithms__porep__porep_commitments">

<h3 class="section-header">
  PoRep Commitments
</h3>

<div class="section-content">






































</div>


  
    








<div id="algorithms__porep__porep_commitments__sdr_commitments">

<h4 class="section-header">
  Stacked DRG Commitments
</h4>

<div class="section-content">






































</div>


  
    








<div id="algorithms__porep__porep_commitments__sdr_commitments__sdr_commitments">

<h5 class="section-header">
  Stacked DRG Commitments
</h5>

<div class="section-content">





































<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp">  <span class="p">(</span><span class="nv">ql:quickload</span> <span class="ss">:orient</span><span class="p">)</span></code></pre></div>
</div>
<table>
<tbody>
<tr>
<td>:ORIENT</td>
</tr>
</tbody>
</table>
<p>
This section summarizes the Stacked DRG (SDR) Column Commitments algorithm described in <a href="https://www.overleaf.com/read/kcdhnxwptxbc">Tight PoS - ZigZag</a>.
</p>
<h6 id="headline-1">
Graph
</h6>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp">  <span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*layers*</span> <span class="mi">4</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*nodes*</span> <span class="mi">8</span><span class="p">)</span>

  <span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*regenerate-sdr-graph*</span> <span class="no">nil</span><span class="p">)</span>

  <span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*dumped-sdr-graph*</span> <span class="o">&#39;</span><span class="p">(</span><span class="ss">:NODES</span> <span class="mi">8</span> <span class="ss">:CHALLENGED-NODE</span> <span class="mi">7</span> <span class="ss">:LAYERS</span> <span class="mi">4</span> <span class="ss">:RENUMBERED-PERMUTATION</span>
                                     <span class="p">(</span><span class="ss">:PERM-LIST</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">6</span> <span class="mi">1</span> <span class="mi">8</span> <span class="mi">2</span> <span class="mi">5</span><span class="p">)</span> <span class="ss">:TYPE</span> <span class="nv">PERM</span><span class="p">)</span> <span class="ss">:REVERSED-PERMUTATION</span>
                                     <span class="p">(</span><span class="ss">:PERM-LIST</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">1</span> <span class="mi">4</span> <span class="mi">2</span><span class="p">)</span> <span class="ss">:TYPE</span> <span class="nv">PERM</span><span class="p">)</span> <span class="ss">:TYPE</span> <span class="nv">SDR-GRAPH</span><span class="p">))</span>

  <span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*sdr-graph*</span>  <span class="p">(</span><span class="k">if</span> <span class="vg">*regenerate-sdr-graph*</span>
                                 <span class="p">(</span><span class="nv">make-sdr-graph</span> <span class="vg">*nodes*</span> <span class="vg">*layers*</span><span class="p">)</span>
                                 <span class="p">(</span><span class="nv">load-from-plist</span> <span class="vg">*dumped-sdr-graph*</span><span class="p">)))</span>

  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">lg</span> <span class="p">(</span><span class="nf">first</span> <span class="p">(</span><span class="nv">sdr-graph-layer-graphs</span> <span class="vg">*sdr-graph*</span><span class="p">))))</span>
    <span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*comm-d-graph*</span> <span class="p">(</span><span class="nv">make-comm-d-layer-graph</span> <span class="p">(</span><span class="nv">layer-graph-nodes</span> <span class="nv">lg</span><span class="p">)</span> <span class="p">(</span><span class="nv">layer-graph-challenged-node</span> <span class="nv">lg</span><span class="p">)</span> <span class="ss">:parent</span> <span class="vg">*sdr-graph*</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*replica-graph*</span> <span class="p">(</span><span class="nv">make-replica-layer-graph</span> <span class="p">(</span><span class="nv">layer-graph-nodes</span> <span class="nv">lg</span><span class="p">)</span> <span class="p">(</span><span class="nv">layer-graph-challenged-node</span> <span class="nv">lg</span><span class="p">)</span> <span class="ss">:parent</span> <span class="vg">*sdr-graph*</span> <span class="ss">:layers</span> <span class="vg">*layers*</span><span class="p">)))</span>

  <span class="p">(</span><span class="nv">dump</span> <span class="vg">*sdr-graph*</span><span class="p">)</span></code></pre></div>
</div>
<pre class="example">
(:NODES 8 :CHALLENGED-NODE 7 :LAYERS 4 :RENUMBERED-PERMUTATION
 (:PERM-LIST (7 4 3 6 1 8 2 5) :TYPE PERM) :REVERSED-PERMUTATION
 (:PERM-LIST (3 7 8 6 5 1 4 2) :TYPE PERM) :TYPE SDR-GRAPH)
</pre>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">emit-legend</span> <span class="no">nil</span><span class="p">)</span></code></pre></div>
</div>
<p>
In the following graphs, DRG and expander parents are both generated by a pseudorandom permutation and are provided only
to illustrate the nature of the SDR commitment scheme. They accurately represent how parent-child relationships
function between layers, and are accurate for expander parents. However, this is not representative of the DRG parent
selection algorithm.
</p>
<p>
The following graphs illustrate the positions of challenges, DRG parents, and expander parents between layers. Only a
single DRG parent and a single expander parent are shown. The immediate predecessor parent is shown for graph topology,
but it is not tracked in the tables below.
</p>
<p>
In order to have a compact and concrete example, we use a graph containing only src_lisp[:package fct]{<strong>nodes</strong>} {{{results(<code class="verbatim">8</code>)}}} nodes replicated in src_lisp[:package fct]{<strong>layers</strong>} {{{results(<code class="verbatim">4</code>)}}} layers.
</p>
<h6 id="headline-2">
Legend
</h6>
<div class="src src-dot">
<pre><code class="language-dot" data-lang="dot">$input</code></pre>
</div>
<p>
<img src="legend.png" alt="legend.png" title="legend.png" />
</p>
<h6 id="headline-3">
Data Layer: $Comm_D$ Tree
</h6>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">emit-comm-d-layer-graph</span> <span class="vg">*comm-d-graph*</span><span class="p">)</span></code></pre></div>
</div>
<div class="src src-dot">
<pre><code class="language-dot" data-lang="dot">$input</code></pre>
</div>
<p>
<img src="data-layer.png" alt="data-layer.png" title="data-layer.png" />
</p>
<h6 id="headline-4">
Replica Column Layers: $Comm_C$ Tree
</h6>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">emit-layer-graph</span> <span class="p">(</span><span class="nf">nth</span> <span class="mi">0</span> <span class="p">(</span><span class="nv">sdr-graph-layer-graphs</span> <span class="vg">*sdr-graph*</span><span class="p">)))</span></code></pre></div>
</div>
<div class="src src-dot">
<pre><code class="language-dot" data-lang="dot">$input</code></pre>
</div>
<p>
<img src="layer-1.png" alt="layer-1.png" title="layer-1.png" />
</p>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">emit-layer-graph</span> <span class="p">(</span><span class="nf">nth</span> <span class="mi">1</span> <span class="p">(</span><span class="nv">sdr-graph-layer-graphs</span> <span class="vg">*sdr-graph*</span><span class="p">)))</span></code></pre></div>
</div>
<div class="src src-dot">
<pre><code class="language-dot" data-lang="dot">$input</code></pre>
</div>
<p>
<img src="layer-2.png" alt="layer-2.png" title="layer-2.png" />
</p>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">emit-layer-graph</span> <span class="p">(</span><span class="nf">nth</span> <span class="mi">2</span> <span class="p">(</span><span class="nv">sdr-graph-layer-graphs</span> <span class="vg">*sdr-graph*</span><span class="p">)))</span></code></pre></div>
</div>
<div class="src src-dot">
<pre><code class="language-dot" data-lang="dot">$input</code></pre>
</div>
<p>
<img src="layer-3.png" alt="layer-3.png" title="layer-3.png" />
</p>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">emit-layer-graph</span> <span class="p">(</span><span class="nf">nth</span> <span class="mi">3</span> <span class="p">(</span><span class="nv">sdr-graph-layer-graphs</span> <span class="vg">*sdr-graph*</span><span class="p">)))</span></code></pre></div>
</div>
<div class="src src-dot">
<pre><code class="language-dot" data-lang="dot">$input</code></pre>
</div>
<p>
<img src="layer-4.png" alt="layer-4.png" title="layer-4.png" />
</p>
<h6 id="headline-5">
Final Layer: $Comm_{R_{LAST}}$ Tree
</h6>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">emit-replica-layer-graph</span> <span class="vg">*replica-graph*</span><span class="p">)</span></code></pre></div>
</div>
<div class="src src-dot">
<pre><code class="language-dot" data-lang="dot">$input</code></pre>
</div>
<p>
<img src="replica-layer.png" alt="replica-layer.png" title="replica-layer.png" />
</p>
<h6 id="headline-6">
Commitment Algorithm
</h6>
<h6 id="headline-7">
Goal
</h6>
<p>
We will generate two commitments $Comm_R, Comm_D$ to be placed on chain.
</p>
<p>
$Comm_D$ is the merkle root of the original data.
</p>
<p>
$Comm_R = H(Comm_C || Comm_{R_{LAST}})$.
</p>
<p>
Their construction is described below.
</p>
<h6 id="headline-8">
Definitions and Notation
</h6>
<p>
We will perform $L$ layers of SDR key generation over $N$ labeled nodes.
</p>
<p>
In the running example, $L$ is src_lisp[:package fct]{<strong>layers</strong>} {{{results(<code class="verbatim">4</code>)}}} and $N$ is src_lisp[:package fct]{<strong>nodes</strong>} {{{results(<code class="verbatim">8</code>)}}}.
</p>
<p>
Merkle roots (commitments) are generated with the vector-commitment function $VC(‚Ä¶)$.
</p>
<p>
Hashes are produced with a hash function $H(‚Ä¶)$, which is not necessarily that used by $VC(‚Ä¶)$.
</p>
<p>
$Comm = VC(l_1||‚Ä¶||l_N)$, where the $l_i$ are the data (labels or hashes) to be committed.
</p>
<p>
Generated trees are retained until the proving phase, when merkle proofs of a given label&#39;s inclusion in $Comm$ will be
created. We will designate such proofs $l_i \rightarrow Comm$.
</p>
<p>
We use the notation $e{_i}^{(l)}$, correlated in the table below with the $(l, i)$ notation used in the graphs above,
where $l$ indexes layers, and $i$ indexes labels or columns.
</p>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">notation-row</span> <span class="vg">*sdr-graph*</span> <span class="mi">1</span><span class="p">)</span></code></pre></div>
</div>
<table>
<tbody>
<tr>
<td>Graph</td>
<td>$(1, 1)$</td>
<td>$(1, 2)$</td>
<td>$(1, 3)$</td>
<td>$(1, 4)$</td>
<td>$(1, 5)$</td>
<td>$(1, 6)$</td>
<td>$(1, 7)$</td>
<td>$(1, 8)$</td>
</tr>
<tr>
<td>Notation</td>
<td>$e_1^{(1)}$</td>
<td>$e_2^{(1)}$</td>
<td>$e_3^{(1)}$</td>
<td>$e_4^{(1)}$</td>
<td>$e_5^{(1)}$</td>
<td>$e_6^{(1)}$</td>
<td>$e_7^{(1)}$</td>
<td>$e_8^{(1)}$</td>
</tr>
</tbody>
</table>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">notation-row</span> <span class="vg">*sdr-graph*</span> <span class="mi">2</span><span class="p">)</span></code></pre></div>
</div>
<table>
<tbody>
<tr>
<td>Graph</td>
<td>$(2, 1)$</td>
<td>$(2, 2)$</td>
<td>$(2, 3)$</td>
<td>$(2, 4)$</td>
<td>$(2, 5)$</td>
<td>$(2, 6)$</td>
<td>$(2, 7)$</td>
<td>$(2, 8)$</td>
</tr>
<tr>
<td>Notation</td>
<td>$e_1^{(2)}$</td>
<td>$e_2^{(2)}$</td>
<td>$e_3^{(2)}$</td>
<td>$e_4^{(2)}$</td>
<td>$e_5^{(2)}$</td>
<td>$e_6^{(2)}$</td>
<td>$e_7^{(2)}$</td>
<td>$e_8^{(2)}$</td>
</tr>
</tbody>
</table>
<p>
‚Ä¶
</p>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">notation-row</span> <span class="vg">*sdr-graph*</span> <span class="mi">4</span><span class="p">)</span></code></pre></div>
</div>
<table>
<tbody>
<tr>
<td>Graph</td>
<td>$(4, 1)$</td>
<td>$(4, 2)$</td>
<td>$(4, 3)$</td>
<td>$(4, 4)$</td>
<td>$(4, 5)$</td>
<td>$(4, 6)$</td>
<td>$(4, 7)$</td>
<td>$(4, 8)$</td>
</tr>
<tr>
<td>Notation</td>
<td>$e_1^{(4)}$</td>
<td>$e_2^{(4)}$</td>
<td>$e_3^{(4)}$</td>
<td>$e_4^{(4)}$</td>
<td>$e_5^{(4)}$</td>
<td>$e_6^{(4)}$</td>
<td>$e_7^{(4)}$</td>
<td>$e_8^{(4)}$</td>
</tr>
</tbody>
</table>
<h6 id="headline-9">
Initial Data Layer
</h6>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">initial-layer</span> <span class="vg">*comm-d-graph*</span><span class="p">)</span></code></pre></div>
</div>
<table>
<tbody>
<tr>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
<td>Challenge</td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
</tr>
<tr>
<td>$(0, 1)$</td>
<td>$(0, 2)$</td>
<td>$(0, 3)$</td>
<td>$(0, 4)$</td>
<td>$(0, 5)$</td>
<td>$(0, 6)$</td>
<td>$(0, 7)$</td>
<td>$(0, 8)$</td>
</tr>
</tbody>
</table>
<h6 id="headline-10">
Vector Commitment
</h6>
<p>
Generate Merkle root for data leaves.
</p>
<p>
$Comm_D = VC(D_1 || D_2 || ‚Ä¶ || D_N)$, where $D_i = e_i^{(0)}$.
</p>
<p>
This example: $Comm_D = VC(e_1^{(0)}, e_2^{(0)}, e_3^{(0)}, e_4^{(0)}, e_5^{(0)}, e_6^{(0)}, e_7^{(0)}, e_8^{(0)})$.
</p>
<h6 id="headline-11">
Opening
</h6>
<p>
To open $D_i$, provide a merkle proof $D_i \rightarrow Comm_D$.
</p>
<h6 id="headline-12">
SDR Replica Columns
</h6>
<h6 id="headline-13">
Columns
</h6>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">columns</span> <span class="vg">*sdr-graph*</span><span class="p">)</span></code></pre></div>
</div>
<table>
<tbody>
<tr>
<td>DRG Parents</td>
<td>Expander Parents</td>
<td><code>~~~~</code></td>
<td>Challenges</td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
</tr>
<tr>
<td>$(1, 1)$</td>
<td>$(1, 2)^{*}$</td>
<td>$(1, 3)$</td>
<td>$(1, 4)$</td>
<td>$(1, 5)$</td>
<td>$(1, 6)$</td>
<td>$(1, 7)$</td>
<td>$(1, 8)$</td>
</tr>
<tr>
<td>$(2, 1)$</td>
<td>$(2, 2)$</td>
<td>$(2, 3)$</td>
<td>$(2, 4)$</td>
<td>$(2, 5)$</td>
<td>$(2, 6)$</td>
<td>$(2, 7)$</td>
<td>$(2, 8)$</td>
</tr>
<tr>
<td>$(3, 1)$</td>
<td>$(3, 2)$</td>
<td>$(3, 3)$</td>
<td>$(3, 4)$</td>
<td>$(3, 5)$</td>
<td>$(3, 6)$</td>
<td>$(3, 7)$</td>
<td>$(3, 8)$</td>
</tr>
<tr>
<td>$(4, 1)$</td>
<td>$(4, 2)$</td>
<td>$(4, 3)$</td>
<td>$(4, 4)$</td>
<td>$(4, 5)$</td>
<td>$(4, 6)$</td>
<td>$(4, 7)$</td>
<td>$(4, 8)$</td>
</tr>
</tbody>
</table>
<p>
$^{*}$ Indicates labels which must be hashed for column commitments but need not be opened for label checks.
</p>
<p>
Concatenate and hash rows of column $i$ to construct $O_i$.
</p>
<p>
Column hash $C_i = H(e_i^{(1)} || e_i^{(2)} || ‚Ä¶ || e_i^{(L)})$.
</p>
<h6 id="headline-14">
Vector Commitment
</h6>
<p>
Generate Merkle tree for column leaves, $C_i$:
</p>
<p>
$Comm_C = VC(C_1 || C_2 || ‚Ä¶ || C_N)$.
</p>
<h6 id="headline-15">
Opening
</h6>
<h6 id="headline-16">
To open labels for column $i$:
</h6>
<ul>
<li>
<p>
Reveal all labels and prove they hash to $C_i$ as above. ($L$ hash proofs).
</p>
</li>
<li>
<p>
Provide a merkle proof $C_i \rightarrow Comm_C$.
</p>
</li>
</ul>
<h6 id="headline-17">
Then once, reusable for all columns,
</h6>
<ul>
<li>
<p>
Reveal $Comm_{R_{LAST}}$ and prove that $H(Comm_C || Comm_{R_{LAST}}) = Comm_R$.
</p>
</li>
</ul>
<h6 id="headline-18">
Final Replica Layer
</h6>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">final-layer</span> <span class="vg">*sdr-graph*</span><span class="p">)</span></code></pre></div>
</div>
<table>
<tbody>
<tr>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
<td>Challenge</td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
<td><code>~~~~</code></td>
</tr>
<tr>
<td>$(5, 1)$</td>
<td>$(5, 2)$</td>
<td>$(5, 3)$</td>
<td>$(5, 4)$</td>
<td>$(5, 5)$</td>
<td>$(5, 6)$</td>
<td>$(5, 7)$</td>
<td>$(5, 8)$</td>
</tr>
</tbody>
</table>
<h6 id="headline-19">
Vector Commitment
</h6>
<p>
Generate Merkle tree for replica leaves.
</p>
<p>
$R_{LAST_i} = e_i^{(L+1)}$.
</p>
<p>
$Comm_{R_{LAST}} = VC(R_{LAST_1} || R_{LAST_2} || ‚Ä¶ || R_{LAST_N})$.
</p>
<h6 id="headline-20">
Opening
</h6>
<h6 id="headline-21">
To open $R_{LAST_i}$,
</h6>
<ul>
<li>
<p>
Provide a merkle proof $R_{LAST_i} \rightarrow Comm_{R_{LAST}}$.
</p>
</li>
</ul>
<h6 id="headline-22">
Then once (shared with Replica Columns ‚Äî see above):
</h6>
<ul>
<li>
<p>
Reveal $Comm_C$ and prove that $H(Comm_C || Comm_{R_{LAST}}) = Comm_pR$.
</p>
</li>
</ul>
<h6 id="headline-23">
Replica Commitment
</h6>
<h6 id="headline-24">
Commitment
</h6>
<ul>
<li>
<p>
Produce $Comm_R$ from its constituents.
</p>
</li>
<li>
<p>
$Comm_R = H(Comm_C || Comm_{R_{LAST}})$.
</p>
</li>
</ul>
<h6 id="headline-25">
Opening (performed once per PoRep)
</h6>
<ul>
<li>
<p>
Reveal $Comm_C$ and $Comm_{R_{LAST}}$ and prove that $H(Comm_C || Comm_{R_{LAST}}) = Comm_R$.
</p>
</li>
</ul>
<h6 id="headline-26">
Challenge Selection
</h6>
<p>
For each challenge $\chi$, we challenge each node $e_{\chi}^{(l)}$ for $l = 1, 2, .. L$.
</p>
<h6 id="headline-27">
Opening Commitments for Offline Proof
</h6>
<p>
For use in all challenge proofs, reveal $Comm_C$ and $Comm_{R_{LAST}}$ and prove that $H(Comm_C || Comm_{R_{LAST}}) =
Comm_R$.
</p>
<p>
To prove encoding for a challenged label $\chi$:
</p>
<ul>
<li>
<p>
Initial data layer openings
</p>
<ul>
<li>
<p>
Open label for challenged data node $e_\chi^{(0)} ‚Äî using Comm_D$.
</p>
</li>
</ul>
</li>
<li>
<p>
SDR replica column openings
</p>
<ul>
<li>
<p>
Open all labels in $C_\chi$ containing challenged label&#39;s &#39;replica node&#39;, ($C_\chi$) ‚Äî using $Comm_C$.
</p>
</li>
<li>
<p>
Open all labels in the columns containing challenged label&#39;s DRG parents ‚Äî using $Comm_C$.
</p>
</li>
<li>
<p>
Open all labels in the columns containing challenged label&#39;s expander parents ‚Äî using $Comm_C$.
</p>
</li>
</ul>
</li>
<li>
<p>
Final replica layer openings
</p>
<ul>
<li>
<p>
Open all challenged labels ($e_{\chi}^{(L+1)}$) using $Comm_{R_{LAST}}$.
</p>
</li>
</ul>
</li>
<li>
<p>
Prove labeling for all challenged labels $e{_\chi}^{(l))} for $l = 1, 2, .. L$.
</p>
</li>
<li>
<p>
Prove encoding for all challenged nodes $e{_\chi}^{(L+1))}$.
</p>
</li>
</ul>
<h6 id="headline-28">
Opening Commitments for Online Proof
</h6>
<p>
To prove encoding for a challenged label $C$ in the replica:
</p>
<ul>
<li>
<p>
Reveal $Comm_C$ (which must have been stored along with the replica).
</p>
</li>
<li>
<p>
Open $Comm_{R_{LAST}}$ from provided $Comm_R$ by proving that $H(Comm_C || Comm_{R_{LAST}}) = Comm_R$.
</p>
</li>
<li>
<p>
Provide a merkle proof $e_C^{(L)} \rightarrow Comm_{R_{LAST}}$.
</p>
</li>
</ul>


</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="algorithms__porep__stacked_drg_circuit">

<h3 class="section-header">
  Stacked DRG - Offline PoRep Circuit Spec
</h3>

<div class="section-content">




































<h6 id="stacked-drg-overview">Stacked DRG Overview</h6>
<p>Stacked DRG PoRep is based on layering DRG graphs <code>LAYERS</code> times. The data represented in each DRG layer is a labeling based on previously labeled nodes. The final labeled layer is the SDR key, and the &lsquo;final layer&rsquo; of replication the replica, an encoding of the original data using the generated key.</p>
<ul>
<li><code>ReplicaId</code> is a unique replica identifier (see the Filecoin Proofs spec for details).</li>
<li><code>CommD</code> is the Merkle tree root hash of the input data to the first layer.</li>
<li><code>CommC</code> is the Merkle tree root hash of the SDR column commitments.</li>
<li><code>CommRLast</code> is the Merkle tree root hash of the replica.</li>
<li><code>CommR</code> is the on-chain commitment to the replica, dervied as the hash of the concatenation of <code>CommC</code> and <code>CommRLast</code>.</li>
</ul>
<p>The (offline) proof size in SDR is too large for blockchain usage (~3MB). We use SNARKs to generate a proof of knowledge of a correct SDR proof. In other words, we implement the SDR proof verification algorithm in an arithmetic circuit and use SNARKs to prove that it was evaluated correctly.</p>
<p>This circuit proves that given a Merkle root <code>CommD</code>, <code>CommRLast</code>, and <code>commRStar</code>, that the prover knew the correct replicated data at each layer.</p>
<h6 id="spec-notation">Spec notation</h6>
<ul>
<li><strong>Fr</strong>: Field element of BLS12-381</li>
<li><strong>UInt</strong>: Unsigned integer</li>
<li><strong>{0..x}</strong>: From <code>0</code> (included) to <code>x</code> (not included) (e.g. <code>[0,x)</code> )</li>
<li><strong>Check</strong>:
<ul>
<li>If there is an equality, create a constraint</li>
<li>otherwise, execute the function</li>
</ul>
</li>
<li><strong>Inclusion path</strong>: Binary representation of the Merkle tree path that must be proven packed into a single <code>Fr</code> element.</li>
</ul>
<h4 id="offline-porep-circuit">Offline PoRep circuit</h4>
<h5 id="public-parameters">Public Parameters</h5>
<p><em>Parameters that are embeded in the circuits or used to generate the circuit</em></p>
<ul>
<li><code>LAYERS : UInt</code>: Number of DRG layers.</li>
<li><code>LAYER_CHALLENGES : [LAYERS]UInt</code>: Number of challenges per layer.</li>
<li><code>EXPANSION_DEGREE: UInt</code>: Degree of each bipartite expander graph to extend dependencies between layers.</li>
<li><code>BASE_DEGREE: UInt</code>: Degree of each Depth Robust Graph.</li>
<li><code>TREE_DEPTH: UInt</code>: Depth of the Merkle tree. Note, this is (log_2(Size of original data in bytes/32 bytes per leaf)).</li>
<li><code>PARENT_COUNT : UInt</code>: Defined as <code>EXPANSION_DEGREE+BASE_DEGREE</code>.</li>
</ul>
<h5 id="public-inputs">Public Inputs</h5>
<p><em>Inputs that the prover uses to generate a SNARK proof and that the verifier uses to verify it</em></p>
<ul>
<li><code>ReplicaId : Fr</code>: A unique identifier for the replica.</li>
<li><code>CommD : Fr</code>: the Merkle tree root hash of the original data (input to the first layer).</li>
<li><code>CommR : Fr</code>: The Merkle tree root hash of the final replica (output of the last layer).</li>
<li><code>InclusionPath : [LAYERS][]Fr</code>: Inclusion path for the challenged data and replica leaf.</li>
<li><code>ParentInclusionPath : [LAYERS][][PARENT_COUNT]Fr</code>:  Inclusion path for the parents of the corresponding <code>InclusionPath[l][c]</code>.</li>
</ul>
<p>Design notes:</p>
<ul>
<li><code>CommRLast</code> is a private input used during during Proof-of-Spacetime.
To enable this, the prover must store <code>CommC</code> and use it to prove that <code>CommRLast</code> is included in <code>CommR</code> [TODO: define &lsquo;included&rsquo; language.]</li>
<li><code>InclusionPath</code> and <code>ParentInclusionPath</code>: Each layer <code>l</code> has <code>LAYER_CHALLENGES[l]</code> inclusion paths.</li>
</ul>
<h5 id="private-inputs">Private Inputs</h5>
<p><em>Inputs that the prover uses to generate a SNARK proof, these are not needed by the verifier to verify the proof</em></p>
<ul>
<li>
<p><code>CommR : [LAYERS-1]Fr</code>: Commitment of the the encoded data at each layer.</p>
<p>Note: Size is <code>LAYERS-1</code> since the commitment to the last layer is <code>CommRLast</code></p>
</li>
<li>
<p><code>DataProof : [LAYERS][][TREE_DEPTH]Fr</code>: Merkle tree inclusion proof for the current layer unencoded challenged leaf.</p>
</li>
<li>
<p><code>ReplicaProof : [LAYERS][][TREE_DEPTH]Fr</code>: Merkle tree inclusion proof for the current layer encoded challenged leaves.</p>
</li>
<li>
<p><code>ParentProof : [LAYERS][][PARENT_COUNT][TREE_DEPTH]Fr</code>: Pedersen hashes of the Merkle inclusion proofs of the parent leaves for each challenged leaf at layer <code>l</code>.</p>
</li>
<li>
<p><code>DataValue : [LAYERS][]Fr</code>: Value of the unencoded challenged leaves at layer <code>l</code>.</p>
</li>
<li>
<p><code>ReplicaValue : [LAYERS][]Fr</code>: Value of the encoded leaves for each challenged leaf at layer <code>l</code>.</p>
</li>
<li>
<p><code>ParentValue : [LAYERS][][PARENT_COUNT]Fr</code>: Value of the parent leaves for each challenged leaf at layer <code>l</code>.</p>
</li>
</ul>
<h5 id="circuit">Circuit</h5>
<p>In high level, we do 4 checks:</p>
<ol>
<li><strong>ReplicaId Check</strong>: Check the binary representation of the ReplicaId</li>
<li><strong>Inclusion Proofs Checks</strong>: Check the inclusion proofs</li>
<li><strong>Encoding Checks</strong>: Check that the data has been correctly encoding into a replica</li>
<li><strong>CommRStar Check</strong>: Check that CommRStar has been generated correctly</li>
</ol>
<p>Detailed</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 1: ReplicaId Check - Check ReplicaId is equal to its bit representation
</span><span class="c1"></span><span class="nx">let</span> <span class="nx">ReplicaIdBits</span> <span class="p">:</span> <span class="p">[</span><span class="mi">255</span><span class="p">]</span><span class="nx">Fr</span> <span class="p">=</span> <span class="nf">Fr_to_bits</span><span class="p">(</span><span class="nx">ReplicaId</span><span class="p">)</span>
<span class="nf">assert</span><span class="p">(</span><span class="nf">Packed</span><span class="p">(</span><span class="nx">replica_id_bits</span><span class="p">)</span> <span class="o">==</span> <span class="nx">ReplicaId</span><span class="p">)</span>

<span class="nx">let</span> <span class="nx">DataRoot</span><span class="p">,</span> <span class="nx">ReplicaRoot</span> <span class="nx">Fr</span>

<span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS</span> <span class="p">{</span>

  <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">DataRoot</span> <span class="p">=</span> <span class="nx">CommD</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">DataRoot</span> <span class="p">=</span> <span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="nx">LAYERS</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">ReplicaRoot</span> <span class="p">=</span> <span class="nx">CommRLast</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">ReplicaRoot</span> <span class="p">=</span> <span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="nx">c</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS_CHALLENGES</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// 2: Inclusion Proofs Checks
</span><span class="c1"></span>    <span class="c1">// 2.1: Check inclusion proofs for data leaves are correct
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">DataRoot</span><span class="p">,</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">DataValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]))</span>
    <span class="c1">// 2.2: Check inclusion proofs for replica leaves are correct
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">ReplicaRoot</span><span class="p">,</span> <span class="nx">InclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">ReplicaProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">],</span> <span class="nx">ReplicaValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]))</span>
    <span class="c1">// 2.3: Check inclusion proofs for parent leaves are correct
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">PARENT_COUNT</span> <span class="p">{</span>
      <span class="nf">assert</span><span class="p">(</span><span class="nf">MerkleTreeVerify</span><span class="p">(</span><span class="nx">ReplicaRoot</span><span class="p">,</span> <span class="nx">ParentInclusionPath</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">],</span> <span class="nx">ParentProof</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">]))</span>
    <span class="p">}</span>

    <span class="c1">// 3: Encoding checks - Check that replica leaves have been correctly encoded
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">ParentBits</span> <span class="p">[</span><span class="nx">PARENT_COUNT</span><span class="p">][</span><span class="mi">255</span><span class="p">]</span><span class="nx">Fr</span>
    <span class="k">for</span> <span class="nx">p</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">PARENT_COUNT</span> <span class="p">{</span>
      <span class="c1">// 3.1: Check that each ParentValue is equal to its bit representation
</span><span class="c1"></span>      <span class="nx">let</span> <span class="nx">parent</span> <span class="p">=</span> <span class="nx">ParentValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">][</span><span class="nx">p</span><span class="p">]</span>
      <span class="nx">ParentBits</span><span class="p">[</span><span class="nx">p</span><span class="p">]</span> <span class="p">=</span> <span class="nf">Fr_to_bits</span><span class="p">(</span><span class="nx">parent</span><span class="p">)</span>
      <span class="nf">assert</span><span class="p">(</span><span class="nf">Packed</span><span class="p">(</span><span class="nx">ParentBits</span><span class="p">[</span><span class="nx">p</span><span class="p">])</span> <span class="o">==</span> <span class="nx">parent</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// 3.2: KDF check - Check that each key has generated correctly
</span><span class="c1"></span>    <span class="c1">// PreImage = ReplicaIdBits || ParentBits[1] .. ParentBits[PARENT_NODES]
</span><span class="c1"></span>    <span class="nx">let</span> <span class="nx">PreImage</span> <span class="p">=</span> <span class="nx">ReplicaIdBits</span>
    <span class="k">for</span> <span class="nx">parentbits</span> <span class="nx">in</span> <span class="nx">ParentBits</span> <span class="p">{</span>
      <span class="nx">PreImage</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">parentbits</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">let</span> <span class="nx">key</span> <span class="nx">Fr</span> <span class="p">=</span> <span class="nf">SHA256</span><span class="p">(</span><span class="nx">PreImage</span><span class="p">)</span>
    <span class="nf">assert</span><span class="p">(</span><span class="nf">SHA256</span><span class="p">(</span><span class="nx">PreImage</span><span class="p">)</span> <span class="o">==</span> <span class="nx">key</span><span class="p">)</span>

    <span class="c1">// 3.3: Check that the data has been encoded to a replica with the right key
</span><span class="c1"></span>    <span class="nf">assert</span><span class="p">(</span><span class="nx">ReplicaValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="o">==</span> <span class="nx">DataValue</span><span class="p">[</span><span class="nx">l</span><span class="p">][</span><span class="nx">c</span><span class="p">]</span> <span class="o">+</span> <span class="nx">key</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// 4: CommRStar check - Check that the CommRStar constructed correctly
</span><span class="c1"></span>  <span class="nx">let</span> <span class="nx">hash</span> <span class="p">=</span> <span class="nx">ReplicaId</span>
  <span class="k">for</span> <span class="nx">l</span> <span class="nx">in</span> <span class="k">range</span> <span class="nx">LAYERS</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">hash</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">CommR</span><span class="p">[</span><span class="nx">l</span><span class="p">])</span>
  <span class="p">}</span>
  <span class="nx">hash</span><span class="p">.</span><span class="nf">Append</span><span class="p">(</span><span class="nx">CommRLast</span><span class="p">)</span>

  <span class="nf">assert</span><span class="p">(</span><span class="nx">CommRStar</span> <span class="o">==</span> <span class="nf">PedersenHash</span><span class="p">(</span><span class="nx">hash</span><span class="p">))</span>
  <span class="c1">// TODO check if we need to do packing/unpacking
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><h5 id="verification-of-offline-porep-proof">Verification of offline porep proof</h5>
<ul>
<li>SNARK proof check: <strong>Check</strong> that given the SNARK proof and the public inputs, the SNARK verification outputs true</li>
<li>Parent checks: For each <code>leaf = InclusionPath[l][c]</code>:
<ul>
<li><strong>Check</strong> that all <code>ParentsInclusionPaths_[l][c][0..PARENT_COUNT}</code> are the correct parent leaves of <code>leaf</code> in the DRG graph, if a leaf has less than <code>PARENT_COUNT</code>, repeat the leaf with the highest label in the graph.</li>
<li><strong>Check</strong> that the parent leaves are in ascending numerical order.</li>
</ul>
</li>
</ul>


</div>



</div>

  


</div>

  

  
    








<div id="algorithms__post">

<h2 class="section-header">
  Proof-of-Spacetime
</h2>

<div class="section-content">




































<p>See <a href="https://filecoin.io/filecoin.pdf">Filecoin Paper</a></p>


</div>


  
    








<div id="algorithms__post__election_post">

<h3 class="section-header">
  Election PoSt
</h3>

<div class="section-content">




































<p>This document describes Election-PoSt, the Proof-of-Spacetime used in Filecoin.</p>
<p>At a high-level it marries <code>ElectionPoSt</code> with a <code>SurprisePoSt</code> fallback:</p>
<ul>
<li>By coupling leader election and PoSt, <code>ElectionPoSt</code> ensures that miners must do the work to prove their sectors at every round in order to earn block rewards.</li>
<li>Small miners may not win on a regular basis however, <code>SurprisePoSt</code> thus comes in as a lower-bound to how often miners must PoSt and helps ensure the Power Table does not grow stale for its long-tail of smaller miners.</li>
</ul>
<div id="algorithms__post__election_post__pledge_collateral"></div>
<h4 id="overview">Overview</h4>
<p>Election PoSt couples the PoSt process with block production, meaning that in order to produce a block, the miner must produce a valid PoSt proof (snark output). Specifically, a subset of non-faulted sectors the miner is storing (i.e. eligible sectors) allows them to attempt a leader election using a PartialTicket any of which could yield a valid ChallengeTicket for leader election. The probability of scratching a winning ChallengeTicket is dependent on sector size and total storage. Miners are rewarded in proportion to the quantity of winning ChallengeTickets they generate in a given epoch, thereby incentivizing a miner to check as much of their storage as allowed in order to express their full power in a leader election. The number of election proofs a miner can generate in a given epoch will determine the block reward it earns.</p>
<p>An election proof is generated from a given PartialTicket by Hashing it, and using that hash to generate a value in [0,1]. Specifically <code>ChallengeTicket = H(PartialTicket)/2^len(H)</code>.</p>
<p>This does mean that, in a given round, a lucky miner may succeed in generating a block by proving only a single sector, but again on expectation, a miner will have to prove their sectors at every single round in order for their full power to contribute to block generation. In the event one of the miner‚Äôs sectors cannot be proven (i.e. the miner does not have access to the nodes from that sector), no tickets will be returned. In order to prevent this, a miner can declare faults on their faulty sectors to avoid having to include them in the eligible sector set. Their power will be reduced accordingly.</p>
<p>The Election-PoSt construction includes a Surprise PoSt cleanup which will randomly challenge leaders who have not been elected in some time so they can prove their storage. Accordingly, miners will be challenged once per proving period on expectation. Any miner who fails to respond to the Challenge with a SurprisePoSt will see their power curbed across all their sectors (this is called a <code>Detected Fault</code>). If they are unable to prove their power within another two SurprisePoSts, their power will be terminated entirely.</p>
<h5 id="electionpost">ElectionPoSt</h5>
<p>To enable short PoSt response time, miners are required submit a PoSt when they are elected to mine a block, hence PoSt on election or ElectionPoSt. When miners win a block, they need to immediately generate a PoStProof and submit that in the block header along with the winning PartialTickets. Both the PartialTickets and PoStProof are checked at Block Validation by <code>StoragePowerConsenusSubsystem</code>. When a block is included, a special message is added that calls <code>SubmitElectionPoSt</code> which will process sector updates in the same way as successful <code>SubmitSurprisePoSt</code> do.</p>
<h5 id="surprisepost-cleanup">SurprisePoSt Cleanup</h5>
<p>In the absence of a posted <code>ElectionPoSt</code>, the chain randomly challenges a miner to submit a <code>SurprisePoSt</code> once per <code>ProvingPeriod</code> on expectation to ensure their storage is still accounted for. The process is largely the same as for <code>ElectionPoSt</code> but a successful <code>SurprisePoSt</code> does not entitle a miner to generate a blocks and gains them no reward. It allows them to maintain power in the power table.</p>
<p>For every miner challenged, a <code>NotifyOfPoStSurpriseChallenge</code> is issued and sent as an on-chain message to the chosen <code>StorageMinerActor</code>.
<code>PoStSurprise</code> will frequently be used by small miners who do not win blocks, and by miners as they are onboarding power to the network (since they will not be able to win ElectionPoSts to start).</p>
<h4 id="in-detail">In Detail</h4>
<h5 id="electionpost-generation">ElectionPoSt Generation</h5>
<p>Filecoin&rsquo;s ElectionPoSt process makes use of two calls to the system library:</p>
<ul>
<li><code>GenerateCandidates</code> which takes in the miner&rsquo;s sectors and a wanted number of Challenge Tickets and generates a number of inclusion proofs for a number of challenged sectors chosen randomly in proportion to the requested number of challenged tickets.</li>
<li><code>GeneratePoSt</code> takes a set of ChallengeTickets and generates a <strong><em>Proof of Spacetime</em></strong> for them, proving the miner storage as a whole.</li>
</ul>
<p>As stated above, a miner is incentivized to repeat this process at every block time in order to check whether they were elected leaders (see &laquo;sref expected_consensus&raquo;). The rationality assumption made by ElectionPoSt is thus that storing files continuously and earning block rewards accordingly will be more profitable to miners than regenerating data at various epochs to sporadically participate in leader election.</p>
<p>At every epoch, each miner will challenge a portion of sectors <code>numSectorsSampled</code> from their <code>Proving Set</code> at random, according to some <code>ElectionPoStSampleRate</code> with each sector being issued K PoSt challenges (coverage may not be perfect).</p>
<p>By proving access to the challenged range of nodes (i.e. merkle tree leaf from the committed sector) in the sector, the miner can generate a set of valid ChallengeTickets in order to check them as part of leader election in EC (in order to find the winning tickets). The winning tickets will be stored on the block and used to generate a PoSt (using a SNARK). A block header will thus contain a number of ‚Äúwinning‚Äù PoStCandidates (each containing a partialTicket, SectorID and other elements, used to verify the leader election) and a PostProof generated from the ChallengeTickets.</p>
<p>This is all included in a field called <code>ElectionPoStOutput</code></p>
<p>In order to simplify implementation and bound block header size, we can set a maximum number of possible election proofs for any block. For instance, for EC.E=5, we can cap challengeTicket submissions at 16 per block, which would cover more than 99.99% of cases (using Chernoff bounds) encountered by a 50% miner (i.e. much more in practice).</p>
<p>The epoch time is divided into three non-overlapping portions: (1) checking sectors for small challenge tickets, (2) computing the SNARK to produce a PoSt certifying the winning challenge tickets, and (3) block production/propagation. The target duration for each is still to be tuned. Proof parameter adjustments might allow a longer block propagation window while maintaining PoSt security (but trades off against sealing time and other things).</p>
<p>If no one has found a winning ticket in this epoch, increment epoch value as part of the post_randomness sampling and try again.</p>
<p>At every round:</p>
<ol>
<li>
<p><strong>(sample randomness)</strong>
The miner draws a randomness ticket from the randomness chain from a given epoch SPC_LOOKBACK_POST back and concats it with the minerID, and epoch for use as post_randomness (this is as it used to happen previously, except the SPC_LOOKBACK_POST is now also the EC randomness_lookback, which is small here):</p>
<ul>
<li><code>post_randomness = VRF_miner(ChainRandomness(currentBlockHeight - SPC_LOOKBACK_POST))</code></li>
</ul>
</li>
<li>
<p><strong>(select eligible sectors)</strong>
The miner calls <code>GenerateCandidates</code> from proofs with their non-faulted (declared or detected) sectors, meaning those in their <code>proving set</code> (from the <code>StorageMinerActor</code>) along with <code>numSectorsSampled</code> <code>PartialTickets</code>. Note that the PoSt sectors are sampled over the <code>ProvingSet</code> and not just active sectors since if the PoSt is successful all PoSt in the <code>ProvingSet</code> will become active. That is, by including these sectors in their <code>ProvingSet</code>, miners are claiming that these are active sectors, which will be proven in the PoSt itself. Therefore we can use these sectors to generate the PoSt.</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">    numSectorsMiner = len(miner.provingSet)
    numSectorsSampled = ceil(EPoStSampleRate * numSectorsMiner)
</code></pre></div><p>Note also that even with <code>numSectorsSampled == len(ProvingSet)</code>, this process may not sample all of a miner‚Äôs sectors in any given epoch, given how the data to be proven in challenged sectors is selected (there could be collisions, e.g. the same sectors selected multiple times).</p>
<ol start="3">
<li>
<p><strong>(generate Partial Ticket(s))</strong> for each selected sector</p>
<ul>
<li>first, generate K <code>PoStChallenges</code> (C_i), sampled at random from the chosen sector.
There will be a chosen challenge-range size (a power of 2), called <code>ChallengeRangeSize</code>. Challenge ranges must be subtree-aligned and thus divide the sector into fixed-size data blocks. So challenge ranges can be indexed because allowable challenge ranges do not overlap. C_i is selected from the valid indexes into the challenge ranges.
<code>C_i = HashToBlockNumber(post_randomness || S_j || i)</code>
C_i corresponds to a given index of a known-sized data block (the sector)</li>
<li>for each C_i, miner reads the specified range of data from disk, which is of size <code>ChallengeRangeSize : C_i_output</code></li>
<li>Miner generates a PartialTicket using all the PoSt witnesses</li>
<li><code>PartialTicket = H(post_randomness || minerID ||S_ j || C_1_Output || ‚Ä¶ || C_K_Output)</code></li>
</ul>
</li>
<li>
<p><strong>(check Challenge Ticket(s) for winners)</strong>
Given returned PartialTickets, miner checks them for winning tickets using the target set by expected consensus in <a href="./#algorithms__expected_consensus___index">Expected Consensus</a> (per the <code>TicketIsWinner()</code> method below).</p>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">winningTickets = []
def checkTicketForWinners(partialTickets):
    for partialTicket in partialTickets:
        challengeTicket = finalizeTicket(PartialTicket) 
        if TicketIsWinner(challengeTicket):
            winningTickets += partialTicket

def finalizeTicket(partialTicket):
    return H(ChallengeTicket) / 2^len(H)

</code></pre></div><p>A single winning ticket and can be used to submit a block but a miner would want to check as many as possible to increase their potential rewards. The target ensures that on expectation, a miner&rsquo;s total power is expressed if they check all of their tickets, taking the <code>ElectionPoStSampleRate</code> into account.</p>
<ol start="5">
<li>
<p><strong>(generate a <code>PoStProof</code>)</strong> for inclusion in the block header</p>
<ul>
<li>Using the winning tickets from step 4 (there may be multiple tickets from the same <code>SectorNumber</code>), call <code>GeneratePoSt</code> from proofs to generate a single PoSt for the block</li>
</ul>
</li>
</ol>
<p>If no one has found a winning ticket in this epoch, increment epoch value as part of the post_randomness sampling and try again.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>Randomness_ticket</code> &ndash;  a ticket drawn from the randomness ticket chain at a prior tipset</li>
<li><code>Randomness_lookback</code> &ndash; how far back to draw randomness from the randomness ticket chain - it will be as large as allowed by PoSt security, likely 1 or 2 epochs</li>
<li><code>K (e.g. 20-100s)</code> - number of  challenges per sector &ndash; must be large enough such that the PoSpace is secure.</li>
<li><code>ChallengeRangeSize</code> - challenge read size (between 32B and 256KB)  &ndash; based on security analysis.</li>
<li><code>EPoStsampleRate</code> - sector sampling fraction (e.g. 1, .10, .04) &ndash; 1 to start&ndash; It should be large enough to make it irrational to fully regenerate sectors. We may choose some subset if cost of verifying all is deleterious to disk</li>
<li><code>sectorsSampled</code> - Number of sectors sampled given the <code>EPoStsampleRate</code>.</li>
<li><code>networkPower</code> - filecoin network‚Äôs power - read from the power table, expressed in number of bytes</li>
</ul>
<h5 id="electionpost-verification">ElectionPoSt verification</h5>
<p>At a high-level, to validate a winning PoSt Proof:</p>
<ol>
<li>
<p><strong>(Verify post_randomness):</strong></p>
<ul>
<li><code>post_randomness</code> is appropriate given <code>chain</code>, <code>SPC_LOOKBACK_POST</code> and <code>epoch</code></li>
<li>VRF is generated by miner who submitted the PoSt:
<code>{0,1} ?= VRF_miner.Verify(post_randomness)</code></li>
<li>VRF output is valid given expected inputs:
<code>{0,1} ?= VRF_miner.Validate(H(randomness_ticket || chainEpoch))</code></li>
</ul>
</li>
<li>
<p>Rederive eligible sectors in order to verify that winning sectors were appropriately selected (meaning it‚Äôs in <code>S_j</code>) from
<code>{0, 1} ?= sectorID in (HashToSectorID(post_randomness || minerID || j))</code></p>
</li>
<li>
<p><strong>Verify <code>PartialTicket</code> returned</strong></p>
<ul>
<li>Prove that the PartialTicket were appropriately derived from the eligible sectors, by submitting all miner sectors along with the wanted number of tickets and verifying that the outputted PartialTicket match.</li>
<li>Verify that no duplicate PartialTickets were submitted, that is there are no two tickets with the same <code>challengeIndex</code> (challengeIndices are unique across challenged sectors). Tickets challenging the same sector at different indices are valid).</li>
</ul>
</li>
<li>
<p><strong>Derive and validate the <code>ChallengeTicket</code> from the PartialTickets</strong></p>
<ul>
<li>Prove the derived ChallengeTicket is below the target
<code>{0, 1} ?= (ChallengeTicket &lt; target)</code></li>
</ul>
</li>
<li>
<p><strong>Verify the <code>postProof</code> using the <code>PartialTickets</code></strong></p>
<ul>
<li>Verify that the postProof was appropriately derived from the PartialTickets.</li>
<li>The PoSt proof will verify the correctness of any PartialTickets passed to it as public inputs. In order to do this, it also needs the sector number along with various on-chain data (randomness, CommR, miner ID, etc.).</li>
</ul>
</li>
</ol>
<p>As it stands, the proofs caller passes a list of all of the replicas (with filesystem paths and auxiliary metadata) which could be challenged and a wanted number of tickets. This code structure forces the miner architecture to look like a single machine with a large number of disks presented as a single filesystem, as shown in spec. That won‚Äôt change for now. VFS systems like NFS may be used to distribute disks among multiple machines virtualizing the FileStore.</p>
<p>There is no requirement to persist the witnesses (list of merkle proofs) for failure recovery. If something fails, we don‚Äôt expect recovery to be fast enough to allow the miner to participate in that round anyway.</p>
<h5 id="surprise-post-cleanup">Surprise PoSt cleanup</h5>
<p>But while this means a miner will never win blocks from faked power, they won‚Äôt be penalized either when storage is lost. How do we ensure that the Power Table is accurate? Likewise, how do we onboard new power since it will not win a block unless it has at least X TB or Y % of the network.</p>
<p>This is why we need PoSt surprise. The process is largely the same as ElectionPoSt save for a few differences:</p>
<ul>
<li>A miner will only be surprised if they have not submitted a PoSt in some time (more than <code>SURPRISE_NO_CHALLENGE_PERIOD</code> epochs)</li>
<li>A miner will have <code>CHALLENGE_DURATION</code> epochs to reply</li>
<li>The PoSt will be submitted as a message on chain rather than part of the block header</li>
<li>After being challenged, a miner will no longer be eligible to submit an ElectionPoSt</li>
</ul>
<p>If a miner fails to respond to the challenge past the <code>CHALLENGE_DURATION</code>, they will lose all their power and a portion of their pledge collateral. This is considered a <code>DetectedFault</code> and all sectors in the <code>ProvingSet</code> will be marked as <code>Failing</code>. No deal collateral will be slashed if miners can recover within the next three proving periods. Note that the exact amount of slashed pledge collateral and pledge collateral function itself are subject to change.</p>
<p>Thereafter, the miner will have three more ProvingPeriods (specifically three challenges, so three ProvingPeriods on expectation) to recover their power by submitting a SurprisePoSt. If the miner does not do so, their sectors are permanently terminated and their storage deal collateral slashed (see the StorageMinerActor in the spec).</p>
<h5 id="postsurprise-challenge">PoStSurprise Challenge</h5>
<p>Miners are selected at random to be challenged at every clockTick by the storage power actor (with <code>_selectMinersToSurprise</code>), with <code>len(PowerTable)/ProvingPeriod</code> miners selected per round (for one challenge per miner per proving period on expectation).</p>
<p>If the chosen <code>StorageMinerActor</code> is already challenged (<code>IsChallenged</code> is True) or they&rsquo;ve submitted a post (election or surprise) in the last <code>SURPRISE_NO_CHALLENGE_PERIOD</code> epochs, they will not be challenged again. That is if <code>ShouldChallenge</code> is False, then the SurprisePoSt notification will be ignored and return success.</p>
<p>Sampling which miners to surprise works as follows:</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">// A number of challenged miners is chosen at every round
challNumber = NumMiners / ProvingPeriod

// Using the ticket to seed randomness, a miner is picked from the power table for each challenge
sampledMiners = []
while len(sampledMiners) &lt; challNumber:
    ranHash = H(ticket, i)
    ranIndex = HashToInt(ranHash) mod len(PowerTable)
    chosenMiner = PowerTable[ranIndex].address
    // a miner should only be challenged if
    // - they have not submitted a post in SURPRISE_NO_CHALLENGE_PERIOD epochs 
    // - they are not currently challenged 
    // - they are not already chosen in this epoch
    if !sampledMiners.contains(chosenMiner) &amp;&amp;chosenMiner.shouldChallenge():
        sampledMiners.append(chosenMiner)
</code></pre></div><p>The surprise process described above is triggered by the cron actor in the <code>Storage Power Actor</code>. A miner should only be chosen if:</p>
<ul>
<li>they are not currently being challenged,</li>
<li>they are not already selected for a challenge this round,</li>
<li>their last PoSt (election or surprise) is older than <code>SURPRISE_NO_CHALLENGE_PERIOD</code> epochs.</li>
</ul>
<p>Once issued a surprise, a miner will have to challenge the sectors in their <code>ProvingSet</code>, generating a number of partial tickets determined by a sampling rate (<code>SPOST_SAMPLE_RATE</code>). In the system here, we use the same system calls as above:</p>
<ul>
<li><code>GenerateCandidates</code> which takes in the miner&rsquo;s sectors and a wanted number of Challenge Tickets and generates a number of inclusion proofs for a number of challenged sectors chosen randomly in proportion to the requested number of challenged tickets.</li>
<li><code>GeneratePoSt</code> takes a set of ChallengeTickets and generates a <strong><em>Proof of Spacetime</em></strong> for them, proving the miner storage as a whole.</li>
</ul>
<h5 id="postsurprise-response">PoStSurprise Response</h5>
<p>The miner&rsquo;s response must be a PoSt proof over the PartialTickets generated by the challenge which clear a given target <code>SURPRISE_TARGET</code> to be defined.</p>
<pre><code>submitSurpriseTickets(partialTickets):
    eligibleTickets = []
    for tix in partialTickets:
        challTix = H(tix) // finalization
        if challTix / 2^len(H) &lt; surprise_target:
            eligibleTickets += tix
    return eligibleTickets
</code></pre><p>If the miner responds to the challenge with a SurprisePoSt within <code>CHALLENGE_DURATION</code> epochs, they will keep/recover their power.</p>
<h5 id="faults">Faults</h5>
<h5 id="fault-detection">Fault Detection</h5>
<p>Fault detection happens over the course of the life time of a sector. When the sector is unavailable for some reason, the miner must submit the known <code>faults</code> in order for that sector not to be tested before the PoSt challenge begins.
Only faults which have been reported at challenge time, will be accounted for. If any other faults have occured the miner will likely fail to submit a valid PoSt for this proving period. Moreover:</p>
<ul>
<li>Faults cannot be declared during a ChallengePeriod</li>
<li>Faults cannot be recovered during a ChallengePeriod</li>
</ul>
<p>Accordingly, if the miner does not respond to the challenge, they will lose all their Power and a portion of their pledge collateral. This is considered a <code>DetectedFault</code> and all sectors in the <code>ProvingSet</code> will be marked as <code>Failing</code>. The miner will get challenged again in the next proving period. If the miner does not provide a valid response to <code>MAX_CONSECUTIVE_FAULTS</code> challenges in a row, their pledge collateral is slashed and their sectors are permanently terminated. Their storage deal collateral is slashed accordingly (see <a href="./#systems__filecoin_markets__storage_market__storage_deal__storage_deal_states">Storage Deal States</a> for more).</p>
<p>Any faulted sectors will not count toward miner power in <a href="./#algorithms__expected_consensus___index">Expected Consensus</a>. Through these <code>Detected</code> and <code>Declared</code> faults, the power table should closely track power in the network.</p>
<h5 id="fault-recovery">Fault Recovery</h5>
<p>In order to recover from faults (and make the faulted sectors active once more), a miner must mark the faults as <code>recovering</code> and then submit a PoSt proving the recovering sectors.
When such a PoSt proof is successfully submitted all faults are reset and assumed to be recovered. A miner must either resolve a failing sector and accept challenges against it in the next proof submission or fail to recover the failing sector within a proving period and the FaultCount on the sector will be incremented. Sectors that have been in the Failing state after <code>MAX_CONSECUTIVE_FAULTS</code> challenges will be terminated and result in a <code>TerminatedFault</code>.</p>
<!-- raw HTML omitted -->
<h5 id="fault-penalization">Fault Penalization</h5>
<p>Each reported fault carries a penality with it.</p>
<!-- raw HTML omitted -->
<h4 id="miner-onboarding">Miner Onboarding</h4>
<p>Storage Power Consensus participants are subject to a <a href="./#systems__filecoin_blockchain__storage_power_consensus__min_miner_size">Minimum Miner Size</a>, meaning miners smaller than <code>MIN_MINER_SIZE_STOR</code> of active (or in-deal) storage cannot produce valid electionPoSts.</p>
<p>These miners&rsquo; power does not count as part of the total network power, nor are they able to sumit electionPoSts but they can still run and transmit SurprisePosts as messages to be added on-chain. These miners can also be faulted as usual for lacking to prove their power after a challenge.</p>
<p>New miners are expected to be onboarded through SurprisePoSts. Once they reach the requisite size, their power will be included in total power and they will be able to submit new blocks with ElectionPoSts as well.</p>


</div>



</div>

  

  
    








<div id="algorithms__post__proof_of_spacetime_parameters">

<h3 class="section-header">
  PoSt Parameters
</h3>

<div class="section-content">




































<p>
This section describes parameters for Rational-PoSt, the Proof-of-Spacetime used in Filecoin.
</p>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nv">asdf:load-system</span> <span class="ss">:orient</span><span class="p">)</span>
<span class="p">(</span><span class="nb">in-package</span> <span class="nv">orient.lang</span><span class="p">)</span></code></pre></div>
</div>
<pre class="example">
#&lt;PACKAGE &#34;ORIENT.LANG&#34;&gt;
</pre>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp"><span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*filecoin*</span> <span class="p">(</span><span class="nv">get-system</span> <span class="s">&#34;../../orient/filecoin.orient&#34;</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*input*</span> <span class="p">(</span><span class="nv">interface:get-json-relation-list</span> <span class="s">&#34;../../orient/params.json&#34;</span><span class="p">))</span>
<span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*multi-input*</span> <span class="p">(</span><span class="nv">interface:get-json-relation-list</span> <span class="s">&#34;../../orient/multi-params.json&#34;</span><span class="p">))</span></code></pre></div>
</div>
<pre class="example">
*MULTI-INPUT*
</pre>
<div class="src src-lisp">
<div class="highlight"><pre class="chroma"><code class="language-lisp" data-lang="lisp">  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">result-tuple</span> <span class="p">(</span><span class="nv">extract</span> <span class="p">(</span><span class="nv">ask</span> <span class="vg">*filecoin*</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">post-challenge-blocks</span> <span class="nv">post-challenge-hours</span> <span class="nv">post-proving-period</span><span class="p">)</span> <span class="vg">*input*</span><span class="p">))))</span>
    <span class="p">(</span><span class="nv">org-present-tuple</span> <span class="nv">result-tuple</span> <span class="vg">*filecoin*</span><span class="p">))</span></code></pre></div>
</div>
<table>
<tbody>
<tr>
<td>Parameter</td>
<td>Type</td>
<td class="align-right">Value</td>
<td>Description</td>
</tr>
<tr>
<td>POST-CHALLENGE-BLOCKS</td>
<td>BLOCKS</td>
<td class="align-right">480</td>
<td>The time offset before which the actual work of generating the PoSt cannot be started. This is some delta before the end of the Proving Period, and as such less than a single Proving Period.</td>
</tr>
<tr>
<td>POST-CHALLENGE-HOURS</td>
<td>HOURS</td>
<td class="align-right">2</td>
<td>PoSt challenge time (see POST_CHALLENGE_BLOCKS).</td>
</tr>
<tr>
<td>POST-PROVING-PERIOD</td>
<td>BLOCKS</td>
<td class="align-right">5760</td>
<td>The time interval in which a PoSt has to be submitted</td>
</tr>
</tbody>
</table>
<div class="notices todo" ><strong>TODO</strong>: The above values are tentative and need both backing from research as well as detailed reasoning why we picked them.</div>


</div>



</div>

  


</div>

  

  
    








<div id="algorithms__payment_channels">

<h2 class="section-header">
  Payment Channels
</h2>

<div class="section-content">




































<h3 id="payment-channels">Payment Channels</h3>
<p>In order for the Filecoin Markets to work in a timely manner, we need to be able to have off-chain payments. This is a solved problem (at least, for our purposes in v0). Payment channels have been implemented and used in bitcoin, ethereum and many other networks.</p>
<p>The basic premise is this: User A wants to be able to send many small payments to user B. So user A locks up money in a contract that says &ldquo;this money will only go to user B, and the unclaimed amount will be returned to user A after a set time period&rdquo;. Once that money is locked up, user A can send user B signed transactions that user B can cash out at any time.</p>
<p>For example:</p>
<ul>
<li>User A locks up 10 FIL to B</li>
<li>User B does something for A</li>
<li>User A sends <code>SignedVoucher{Channel, 1 FIL}</code> to B</li>
<li>User B does something for user A</li>
<li>User A sends <code>SignedVoucher{Channel, 2 FIL}</code> to B</li>
</ul>
<p>At this point, B has two signed messages from A, but the contract is set up such that it can only be cashed out once. So if B decided to cash out, they would obviously select the message with the higher value. Also, once B cashes out, they must not accept any more payments from A on that same channel.</p>
<h4 id="multi-lane-payment-channel">Multi-Lane Payment Channel</h4>
<p>The filecoin storage market may require a way to do incremental payments between two parties, over time, for multiple different transactions. The primary motivating usecase for this is to provide payment for file storage over time, for each file stored. An additional requirement is the ability to have less than one message on chain per transaction &lsquo;lane&rsquo;, meaning that payments for multiple files should be aggregateable (Note: its okay if this aggregation is an interactive process).</p>
<p>Let&rsquo;s say that <code>A</code> wants to make such an arrangement with <code>B</code>. <code>A</code> should create the payment channel with enough funds to cover all potential transactions. Then <code>A</code> decides to start the first transaction, so they send a signed voucher for the payment channel on &lsquo;lane 1&rsquo;, for 2 FIL. They can then send more updates on lane 1 as needed. Then, at some point <code>A</code> decides to start another independent transaction to <code>B</code>, so they send a voucher on &lsquo;lane 2&rsquo;. The voucher for lane 2 can be cashed out independently of lane 1. However, <code>B</code> can ask <code>A</code> to &lsquo;reconcile&rsquo; the two payment channels for them into a single update. This update could contain a value, and a list of lanes to close. Cashing out that reconciled update would invalidate the other lanes, meaning <code>B</code> couldnt also cash in those. The single update would be much smaller, and therefore cheaper to close out.</p>
<p>Lane state can be easily tracked on-chain with a compact bitfield.</p>
<h4 id="payment-channel-reconciliation">Payment Channel Reconciliation</h4>
<p>In a situation where peers A and B  have several different payment channels between them, the scenario may frequently come up where A has multiple payment channel updates from B to apply. Submitting each of these individually would cost a noticeable amount in fees, and put excess unnecessary load on the chain. To remedy this, A can contact B and ask them for a single payment channel update for the combined value of all the updates they have (minus some fee to incent B to actually want to do this). This aggregated update would contain a list of the IDs of the other payment channels that it is superceding so that A cannot also cash out on the originals.</p>
<h3 id="payment-reconciliation">Payment Reconciliation</h3>
<p>The filecoin storage market will (likely) have many independent payments between the same parties. These payments will be secured through payment channels, set up initially on chain, but utilized almost entirely off-chain. The point at which they need to touch the chain is when miners wish to cash out their earnings. A naive solution to this problem would have miners perform one on-chain action per file stored for a particular client. This would not scale well. Instead, we need a system where the miner and client can have some additional off-chain communication and end up with the miner submitting only a single message to the chain.</p>
<p>To accomplish this, we introduce the Payment Reconciliation Protocol.</p>
<p>This is a libp2p service run by all participants wanting to participate in payment reconciliation. When Alice has a set of payments from Bob that she is ready to cash out, Alice can send a <code>ReconcileRequest</code> to Bob, containing the following information:</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ReconcileRequest struct <span class="o">{</span>
	vouchers <span class="o">[</span>Vouchers<span class="o">]</span>
	reqVal TokenAmount
<span class="o">}</span>
</code></pre></div><p>The Vouchers should all be valid vouchers from Bob to Alice, on the same payment channel, and they should all be ready to be cashed in. <code>ReqVal</code> is a token amount less than or equal to the sum of all the values in the given vouchers. Generally, this value will be between the total sum of the vouchers, and that total sum minus the fees it would cost to submit them all to the chain.</p>
<p>Bob receives this request, and checks that all the fields are correct, and then ensures that the difference between ReqVal and the vouchers sum is sufficient (this is a parameter that the client can set).  Then, he sends back a response which either contains the requested voucher, or an error status and message.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> ReconcileResponse struct <span class="o">{</span>
	combined Voucher
	status  Status
	message optional String
<span class="o">}</span>

<span class="c1">## TODO: what are the possible status cases?</span>
<span class="nb">type</span> Status enum <span class="o">{</span>
    <span class="p">|</span> Success
    <span class="p">|</span> Failure
<span class="o">}</span>
</code></pre></div><p>Open Questions:</p>
<ul>
<li>In a number of usecases, this protocol will require the miner look up and connect to a client to propose reconciliation. How does a miner look up and connect to a client over libp2p given only their filecoin address?</li>
<li>Without repair miners, this protocol will likely not be used that much. Should that be made clear? Should there be other considerations added to compensate?</li>
</ul>


</div>



</div>

  

  
    








<div id="algorithms__block_sync">

<h2 class="section-header">
  BlockSync
</h2>

<div class="section-content">




































<div id="algorithms__block_sync__block_sync"></div>
<ul>
<li><strong>Name</strong>: Block Sync</li>
<li><strong>Protocol ID</strong>: <code>/fil/sync/blk/0.0.1</code></li>
</ul>
<p>The blocksync protocol is a small protocol that allows Filecoin nodes to request ranges of blocks from each other. It is a simple request/response protocol.</p>
<p>The request requests a chain of a given length by the hash of its highest block. The <code>Options</code> allow the requester to specify whether or not blocks and messages to be included.</p>
<p>The response contains the requested chain in reverse iteration order. Each item in the <code>Chain</code> array contains the blocks for that tipset if the <code>Blocks</code> option bit in the request was set, and if the <code>Messages</code> bit was set, the messages across all blocks in that tipset. The <code>MsgIncludes</code> array contains one array of integers for each block in the <code>Blocks</code> array. Each of the arrays in <code>MsgIncludes</code> contains a list of indexes of messages from the <code>Messages</code> array that are in each <code>Block</code> in the blocks array.</p>
<div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> BlockSyncRequest struct <span class="o">{</span>
    <span class="c1">## The TipSet being synced from</span>
	start <span class="o">[</span><span class="p">&amp;</span>Block<span class="o">]</span>
    <span class="c1">## How many tipsets to sync</span>
	requestLength UInt
    <span class="c1">## Query options</span>
    options Options
<span class="o">}</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-sh" data-lang="sh"><span class="nb">type</span> Options enum <span class="o">{</span>
    <span class="c1"># Include only blocks</span>
    <span class="p">|</span> Blocks <span class="m">0</span>
    <span class="c1"># Include only messages</span>
    <span class="p">|</span> Messages <span class="m">1</span>
    <span class="c1"># Include messages and blocks</span>
    <span class="p">|</span> BlocksAndMessages <span class="m">2</span>
<span class="o">}</span>

<span class="nb">type</span> BlockSyncResponse struct <span class="o">{</span>
	chain <span class="o">[</span>TipSetBundle<span class="o">]</span>
	status Status
<span class="o">}</span>

<span class="nb">type</span> TipSetBundle struct <span class="o">{</span>
  blocks <span class="o">[</span>Blocks<span class="o">]</span>
  secpMsgs <span class="o">[</span>SignedMessage<span class="o">]</span>
  secpMsgIncludes <span class="o">[[</span>UInt<span class="o">]]</span>

  blsMsgs <span class="o">[</span>Message<span class="o">]</span>
  blsMsgIncludes <span class="o">[[</span>Uint<span class="o">]]</span>
<span class="o">}</span>

<span class="nb">type</span> Status enum <span class="o">{</span>
    <span class="c1">## All is well.</span>
    <span class="p">|</span> Success <span class="m">0</span>
    <span class="c1">## Sent back fewer blocks than requested.</span>
    <span class="p">|</span> PartialResponse <span class="m">101</span>
    <span class="c1">## Request.Start not found.</span>
    <span class="p">|</span> BlockNotFound <span class="m">201</span>
    <span class="c1">## Requester is making too many requests.</span>
    <span class="p">|</span> GoAway <span class="m">202</span>
    <span class="c1">## Internal error occured.</span>
    <span class="p">|</span> InternalError <span class="m">203</span>
    <span class="c1">## Request was bad</span>
    <span class="p">|</span> BadRequest <span class="m">204</span>
<span class="o">}</span>
</code></pre></div><h4 id="example">Example</h4>
<p>The TipSetBundle</p>
<pre><code>Blocks: [b0, b1]
secpMsgs: [mA, mB, mC, mD]
secpMsgIncludes: [[0, 1, 3], [1, 2, 0]]
</code></pre><p>corresponds to:</p>
<pre><code>Block 'b0': [mA, mB, mD]
Block 'b1': [mB, mC, mA]
</code></pre>

</div>



</div>

  

  
    








<div id="algorithms__gossip_sub">

<h2 class="section-header">
  GossipSub
</h2>

<div class="section-content">




































<div id="algorithms__gossip_sub__gossip_sub"></div>
<p>Messages and block headers along side the message references are propagated using the <a href="https://github.com/libp2p/specs/tree/master/pubsub/gossipsub">gossipsub libp2p pubsub router</a>. Every full node must implement and run that protocol. All pubsub messages are authenticated and must be <a href="./validation.md#syntactical-validation">syntactically validated</a> before being propagated further.</p>
<p>Further more, every full node must implement and offer the bitswap protocol and provide all Cid Referenced objects, it knows of, through it. This allows any node to fetch missing pieces (e.g. <code>Message</code>) from any node it is connected to. However, the node should fan out these requests to multiple nodes and not bombard any single node with too many requests at a time. A node may implement throttling and DDoS protection to prevent such a bombardment.</p>
<h3 id="bitswap">Bitswap</h3>
<p>Run bitswap to fetch and serve data (such as blockdata and messages) to and from other filecoin nodes. This is used to fill in missing bits during block propagation, and also to fetch data during sync.</p>
<p>There is not yet an official spec for bitswap, but <a href="https://github.com/ipfs/go-bitswap/blob/master/message/pb/message.proto">the protobufs</a> should help in the interim.</p>


</div>



</div>

  

  
    








<div id="algorithms__crypto">

<h2 class="section-header">
  Cryptographic Primitives
</h2>

<div class="section-content">




































<ul>
<li>
<p>Merkle tree/DAG</p>
</li>
<li>
<p>Vector commitment scheme</p>
</li>
<li>
<p>zkSNARK</p>
</li>
<li>
<p>Reliable broadcast channel (libp2p)</p>
</li>
<li>
<!-- raw HTML omitted -->
</li>
</ul>
<p><!-- raw HTML omitted -->TODO<!-- raw HTML omitted -->:  Add more detail and include references to relevant papers.</p>
<!-- raw HTML omitted -->


</div>


  
    








<div id="algorithms__crypto__signatures">

<h3 class="section-header">
  Signatures
</h3>

<div class="section-content">




































<p>Signatures are cryptographic functions that attest to the origin of a particular
message. In the context of Filecoin, signatures are used to send and receive
messages with the assurance that each message was generated by a specific
entity. In other words, it is infeasible for an entity i to
generate a signed message that appears to have been generated by j, with j != i.</p>
<p>Filecoin uses signatures to associate an action to a given party. For
example, Filecoin uses signatures in order to validate deal messages which represent an
action like a storage deal.
Filecoin uses signatures to verify the authenticity of the following objects (non
exhaustive list):</p>
<ul>
<li>Messages: Users authenticate their transactions to the blockchain.</li>
<li>Tickets: Miner authenticates its ticket (see <a href="./#systems__filecoin_mining__storage_mining">Storage Miner</a>).</li>
<li>Blocks: Block leader signs over all data in the block.</li>
</ul>
<h5 id="messages">Messages</h5>
<p>To generate a signature for the <a href="./#systems__filecoin_vm__message___index">Message</a> type, compute the signature over the message&rsquo;s CID (taken as a byte array).</p>
<p><strong>Note</strong>: for each specific use of a signature scheme, it is recommended to use a domain separation tag to treat the hash function as an independent random oracle. These tags are indicated in the relevant places throughout the specs.
Read more about this in <a href="./#algorithms__crypto__randomness">Randomness</a>.</p>
<h5 id="signature-types">Signature Types</h5>
<p>Filecoin currently uses two types of signatures:</p>
<ul>
<li>ECDSA signatures over the Secp256k1 elliptic curve to authenticate user
transactions, mainly for compatibility with external blockchain systems.</li>
<li>BLS signatures over the BLS12-381 group of curves</li>
</ul>
<p>Both signature types fulfill the <code>Signature</code> interface
and each type have additional functionality as explained below.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Message</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">SecretKey</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">PublicKey</span> <span class="nx">Bytes</span>
<span class="kd">type</span> <span class="nx">SignatureBytes</span> <span class="nx">Bytes</span>

<span class="kd">type</span> <span class="nx">SigKeyPair</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PublicKey</span>
    <span class="nx">SecretKey</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Signature</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Type</span>  <span class="nx">SigType</span>         <span class="err">@</span><span class="p">(</span><span class="nx">internal</span><span class="p">)</span>
    <span class="nx">Sig</span>   <span class="nx">SignatureBytes</span>  <span class="err">@</span><span class="p">(</span><span class="nx">internal</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">SigType</span> <span class="nx">enum</span> <span class="p">{</span>
    <span class="nx">BLSSigType</span>
    <span class="nx">ECDSASigType</span>
<span class="p">}</span>
</code></pre></div>





<h6 id="ecdsa-signatures">ECDSA Signatures</h6>
<p>Filecoin uses the ECDSA signature algorithm over the secp256k1 curve to
authenticate the blockchain transactions. The main reason is to be able to
validate transactions from other blockchain systems that uses secp256k1 (such as
Bitcoin or exchanges in general). ECDSA signatures offer an additional
useful functionality as well: to recover the public key from a given signature.
That feature can allow to save space on the blockchain by extracting the public
key locally from the signature rather than specify an ID of the public key.</p>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// ECDSA implements the Signature interface using the ECDSA algorithm with
</span><span class="c1">// the Secp256k1 elliptic curve.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">ECDSA</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The Signature object is the one returned from SigKeyPair.Sign(). It can
</span><span class="c1"></span>    <span class="c1">// be casted to ECDSA to get the additional functionality described below.
</span><span class="c1"></span>    <span class="nx">Signature</span>

    <span class="c1">// Recover recovers a public key associated with a particular signature.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// Out:
</span><span class="c1"></span>    <span class="c1">//    pk - the public key associated with `M` who signed `m`
</span><span class="c1"></span>    <span class="c1">//    err - a standard error message indicating any process issues
</span><span class="c1"></span>    <span class="c1">//    **
</span><span class="c1"></span>    <span class="c1">// In:
</span><span class="c1"></span>    <span class="c1">//    m - a series of bytes representing the signed message
</span><span class="c1"></span>    <span class="c1">//    sig - a series of bytes representing a signature usually `r`|`s`
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="nf">Recover</span><span class="p">(</span><span class="nx">m</span> <span class="nx">Message</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">SignatureBytes</span><span class="p">)</span> <span class="kd">struct</span> <span class="p">{</span><span class="nx">pk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>





<p><strong>Wire Format</strong>: Filecoin uses the standard secp256k1 signature serialization,
as described below. For more details on how the Filecoin <code>Signature</code> type is
serialized, see <a href="./#algorithms__crypto__signatures">Signatures</a>.</p>
<pre><code>SignatureBytes = [0x30][len][0x02][r][indicator][s][indicator][recovery]
</code></pre><p><code>s</code> = Scalar of size 32 bytes</p>
<p><code>r</code> = Compressed elliptic curve point (x-coordinate) of size 32 bytes</p>
<p><code>recovery</code> = Information needed to recover a public key from <code>sig</code>.</p>
<ul>
<li>LSB(0) = parity of y-coordinate of r</li>
<li>LSB(1) = overflow indicator</li>
</ul>
<p><code>indicator</code> = a 2 byte formatting indicator</p>
<p><strong>External References</strong>: <a href="http://www.secg.org/sec1-v2.pdf">Elliptic Curve Cryptography Paper</a></p>
<h6 id="bls-signatures">BLS Signatures</h6>
<p>Filecoin uses the <a href="https://datatracker.ietf.org/doc/draft-boneh-bls-signature/">BLS signature scheme</a> over the [BLS12-381](BLS12-381](<a href="https://electriccoin.co/blog/new-snark-curve/">https://electriccoin.co/blog/new-snark-curve/</a>) group of elliptic curves. You can find the default Rust implementation in <a href="https://github.com/filecoin-project/bls-signatures/">Filecoin&rsquo;s repo</a>.</p>
<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// BLS implements the Signature interface using the BLS signature scheme
</span><span class="c1">// with the BLS12-381 group of elliptic curves.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">BLS</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// This signature is the one returned from SigKeyPair.Sign(). It can be
</span><span class="c1"></span>    <span class="c1">// casted to a BLS signature struct to get the additional functionalities.
</span><span class="c1"></span>    <span class="nx">Signature</span>

    <span class="c1">// This represents the largest potential value for a BLS signature in Bytes
</span><span class="c1"></span>    <span class="nf">MaxSigValue</span><span class="p">()</span> <span class="nx">Bytes</span>

    <span class="c1">// Aggregates this BLS signature and `sig` into one BLS signature that can
</span><span class="c1"></span>    <span class="c1">// be verified against the aggregation of the two public key that signed
</span><span class="c1"></span>    <span class="c1">// the aggregated signatures.
</span><span class="c1"></span>    <span class="nf">Aggregate</span><span class="p">(</span><span class="nx">sig2</span> <span class="nx">SignatureBytes</span><span class="p">)</span> <span class="nx">SignatureBytes</span>

    <span class="c1">// VerifyAggregate verifies the aggregate signature with the aggregate
</span><span class="c1"></span>    <span class="c1">// public key over all the distinct messages given. Note that if all
</span><span class="c1"></span>    <span class="c1">// messages are the same, it is sufficient and correct to only call
</span><span class="c1"></span>    <span class="c1">// `Verify` since it is a subset of `VerifyAggregate`.
</span><span class="c1"></span>    <span class="nf">VerifyAggregate</span><span class="p">(</span><span class="nx">messages</span> <span class="p">[</span><span class="nx">Message</span><span class="p">],</span> <span class="nx">aggPk</span> <span class="nx">BLSPublicKey</span><span class="p">,</span> <span class="nx">aggSig</span> <span class="nx">SignatureBytes</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="c1">// BLSPublicKey is a PublicKey with an addition method to aggregate public keys
</span><span class="c1">// together.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">BLSPublicKey</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">PublicKey</span>

    <span class="c1">// Aggregate this public key with p2 into one public key. This aggregated
</span><span class="c1"></span>    <span class="c1">// public key can 
</span><span class="c1"></span>    <span class="c1">// - verify aggregated signatures signed by the two BLSPublicKey
</span><span class="c1"></span>    <span class="c1">// - be aggregated further down with other (aggregated or not) BLSPublicKey.
</span><span class="c1"></span>    <span class="nf">Aggregate</span><span class="p">(</span><span class="nx">p2</span> <span class="nx">BLSPublicKey</span><span class="p">)</span> <span class="nx">BLSPublicKey</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">crypto</span>

<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BLS_I</span><span class="p">)</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">input</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">sig</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// blsPk := pk.(*BLSPublicKey)
</span><span class="c1"></span>	<span class="c1">// 1. Verify public key according to string_to_curve section 2.6.2.1. in
</span><span class="c1"></span>	<span class="c1">// 	https://tools.ietf.org/html/draft-boneh-bls-signature-00#page-12
</span><span class="c1"></span>	<span class="c1">// 2. Verify signature according to section 2.3
</span><span class="c1"></span>	<span class="c1">// 	https://tools.ietf.org/html/draft-boneh-bls-signature-00#page-8
</span><span class="c1"></span>	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;bls.Verify TODO&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BLS_I</span><span class="p">)</span> <span class="nf">MaxSigValue</span><span class="p">()</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BLS_I</span><span class="p">)</span> <span class="nf">Sign</span><span class="p">(</span><span class="nx">input</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">sk</span> <span class="o">*</span><span class="nx">SecretKey</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;see 2.3 in https://tools.ietf.org/html/draft-boneh-bls-signature-00#page-8&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BLS_I</span><span class="p">)</span> <span class="nf">Aggregate</span><span class="p">(</span><span class="nx">sig2</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;see 2.5 in https://tools.ietf.org/html/draft-boneh-bls-signature-00#page-8&#34;</span><span class="p">)</span>
	<span class="kd">var</span> <span class="nx">ret</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">BLS_I</span><span class="p">)</span> <span class="nf">VerifyAggregate</span><span class="p">(</span><span class="nx">messages</span> <span class="p">[]</span><span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">aggPk</span> <span class="nx">PublicKey</span><span class="p">,</span> <span class="nx">aggSig</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;see 2.5.2 in https://tools.ietf.org/html/draft-boneh-bls-signature-00#page-9&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>
</code></pre></div>




</p>
<p><strong>Choice of group</strong>: The BLS signature requires the use of a pairing-equipped
curve which generally yield three groups: G_1, G_2 and G_T. In the BLS signature
scheme, there is a choice on which group to define the public key and the
signature:</p>
<ul>
<li>Public key is on G_1 and signature on G_2</li>
<li>Public key is on G_2 and signature on G_1</li>
</ul>
<p>The group G_1 is &ldquo;smaller&rdquo; and hence offer faster arithmetic operations and
smaller byte representation of its elements. Filecoin currently uses the group
<strong>G_1 for representing public keys</strong> and the group <strong>G_2 for representing
signatures</strong>.</p>
<p><strong>Wire Format</strong>: Filecoin uses the standard way to serialize BLS signatures as
explained in the <a href="https://tools.ietf.org/html/draft-boneh-bls-signature-00#section-2.6.1">RFC Section
2.6.1</a>.</p>
<p><strong>Rationale</strong>:
BLS signatures have two main characteristics that are making them ideal
candidates in recent blockchain systems:</p>
<ul>
<li>BLS signatures are deterministic: for a given message and a given secret key,
the signature is always the same.  That feature removes an important security
weakness of most randomized signature schemes: signer must never re-use the
same randomness twice otherwise this reveals its private key. As well,
deterministic signature are ideal candidate to reduce the attack surface in
terms of grinding, which is a real concern in recent proof of stake systems.</li>
<li>BLS signatures are aggregatable: one can aggregate signatures from different
signers into one single signature. That feature allows to drastically save
space on the blockchain, especially when aggregating user transactions.</li>
</ul>
<p><strong>Aggregation Functionality</strong>: The aggregation functionality is commutative and
associative, enabling to perform <em>partial</em> aggregation. For example, given
<code>(PK1, sig1), (PK2, sig2), (PK3, sig3)</code>, one can first aggregate <code>(PK12 = PK1 + PK2, sig12 = sig1 + sig2)</code> then aggregate with the third tuple to produce
<code>(PK123 = PK12 + PK3, sig123 = sig12 + sig3)</code>.</p>
<p><strong>Aggregation Security</strong>: The naive BLS signature aggregation scheme is
vulnerable to rogue-key attacks where the attacker can freely choose its public
key. To prevent against this class of attacks there exists three different kind
of measures, as explained <a href="https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html">here</a>:</p>
<ul>
<li>Enforce distinct messages</li>
<li>Prove knowledge of the secret key</li>
<li>Use a modified scheme (such as <a href="https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html">BLS Multi Sig</a>)</li>
</ul>
<p>Fortunately, Filecoin can enforce the second condition to safely use the
aggregation property:
Filecoin uses aggregation only for aggregating the transaction&rsquo;s signature of a
block. since Filecoin uses the account model to represent the state of the
chain, each message for a given signer is used in combination of a nonce to
avoid replay attacks. As a direct consequence, every transaction&rsquo;s message is
unique thereby the aggregation is done on distinct messages.  Obviously, the
<strong>assumption</strong> here is that the block producer <strong>enforces that distinction</strong> and
the other miners will <strong>check every transactions</strong> to make sure they are valid.
The validity of a transaction in Filecoin&rsquo;s context implies that the signature
is correctly formed over the message with the correct nonce.</p>


</div>



</div>

  

  
    








<div id="algorithms__crypto__vrf">

<h3 class="section-header">
  Verifiable Random Function
</h3>

<div class="section-content">




































<div id="algorithms__crypto__vrf__vrf"></div>
<p>Filecoin uses the notion of a <a href="https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Pseudo%20Randomness/Verifiable_Random_Functions.pdf">Verifiable Random
Function</a>
(VRF). A VRF uses a private key to produce a digest of
an arbitrary message such that the output is unique per signer and per message.
Any third party in possession of the corresponding public key, the message and
the VRF output can verify if the digest has been computed correctly and from the
correct signer. Using a VRF in the ticket generation process allows anyone to
verify if a block comes from an eligible block producer (see <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Ticket Generation</a> for more details).</p>
<p>BLS signature can be used as the basis to construct a VRF. Filecoin transforms
the BLS signature scheme it uses (see <a href="./#algorithms__crypto__signatures">Signatures</a> into a
VRF, Filecoin uses the random oracle model and deterministically hash the
signature to produce the final digest. Filecoin uses
SHA256 as the hash function. The algorithm is the following:</p>
<pre><code>VRFOutput = SHA256(DST || index || Serialization(BLSSignature(message)))
</code></pre><p>where <code>DST</code> is a domain separation tag in order to treat the hash
function as an independent random oracle in the VRF output (see <a href="./#algorithms__crypto__randomness">Randomness</a>).</p>
<p>


















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">VRFPublicKey</span> <span class="nx">PublicKey</span>
<span class="kd">type</span> <span class="nx">VRFSecretKey</span> <span class="nx">SecretKey</span>

<span class="c1">// VRFKeyPair holds the private key and respectively the public key to create 
</span><span class="c1">// and respectively verify a VRF output.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">VRFKeyPair</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">VRFPublicKey</span>
    <span class="nx">VRFSecretKey</span>

    <span class="c1">// Generate a VRF from the given input with the SecretKey that can be
</span><span class="c1"></span>    <span class="c1">// verified with the PublicKey
</span><span class="c1"></span>    <span class="nf">Generate</span><span class="p">(</span><span class="nx">input</span> <span class="nx">Bytes</span><span class="p">)</span> <span class="nx">VRFResult</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">VRFResult</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Output</span>            <span class="nx">Bytes</span>  <span class="c1">// @(internal)
</span><span class="c1"></span>    <span class="nf">MaxValue</span><span class="p">()</span>        <span class="nx">Bytes</span>
    <span class="nf">ValidateSyntax</span><span class="p">()</span>  <span class="kt">bool</span>

    <span class="nf">Verify</span><span class="p">(</span><span class="nx">input</span> <span class="nx">Bytes</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">VRFPublicKey</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div>
























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">crypto</span>

<span class="kn">import</span> <span class="nx">util</span> <span class="s">&#34;github.com/filecoin-project/specs/util&#34;</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">VRFResult_I</span><span class="p">)</span> <span class="nf">ValidateSyntax</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;TODO&#34;</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">VRFResult_I</span><span class="p">)</span> <span class="nf">Verify</span><span class="p">(</span><span class="nx">input</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">,</span> <span class="nx">pk</span> <span class="nx">VRFPublicKey</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// return new(BLS).Verify(self.Output, pk.(*BLSPublicKey), input)
</span><span class="c1"></span>	<span class="k">return</span> <span class="kc">false</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">VRFResult_I</span><span class="p">)</span> <span class="nf">MaxValue</span><span class="p">()</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
	<span class="c1">// return new(BLS).MaxSigValue()
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">VRFKeyPair_I</span><span class="p">)</span> <span class="nf">Generate</span><span class="p">(</span><span class="nx">input</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">VRFResult</span> <span class="p">{</span>
	<span class="c1">// sig := new(BLS).Sign(input, self.SecretKey)
</span><span class="c1"></span>	<span class="kd">var</span> <span class="nx">blsSig</span> <span class="nx">util</span><span class="p">.</span><span class="nx">Bytes</span>
	<span class="nx">ret</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">VRFResult_I</span><span class="p">{</span>
		<span class="nx">Output_</span><span class="p">:</span> <span class="nx">blsSig</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">ret</span>
<span class="p">}</span>
</code></pre></div>




</p>


</div>



</div>

  

  
    








<div id="algorithms__crypto__randomness">

<h3 class="section-header">
  Randomness
</h3>

<div class="section-content">




































<div id="algorithms__crypto__randomness__randomness"></div>
<p>Randomness is used throughout the protocol in order to generate values and extend the blockchain.
Random values are drawn from the <a href="./#systems__filecoin_blockchain__storage_power_consensus__ticket_chain">Ticket Chain</a> and appropriately formatted for usage.
We describe this formatting below.</p>
<h5 id="encoding-on-chain-data-for-randomness">Encoding On-chain data for randomness</h5>
<p>Any randomness derived from on-chain values uses the following encodings to represent these values as bytes:</p>
<ul>
<li><strong>Bytes</strong>: Bytes</li>
<li><strong>Ints</strong>: Big-endian uint64 representation</li>
<li><strong>Strings</strong>: ASCII</li>
<li><strong>Objects</strong>: Their specified Serialization, currently CBOR-based serialization defined on algebraic datatypes</li>
</ul>
<h5 id="domain-separation-tags">Domain Separation Tags</h5>
<p>For <a href="./#algorithms__crypto__signatures">Signatures</a> as well as <a href="./#algorithms__crypto__vrf">Verifiable Random Function</a> usage in the protocol, we define Domain Separation Tags with which we prepend random inputs.</p>
<p>The source of truth is defined below, but the currently defined DSTs are:</p>
<ul>
<li>for drawing randomness from an on-chain ticket:
<ul>
<li><code>TicketDrawingDST = 1</code></li>
</ul>
</li>
<li>for generating a new random ticket:
<ul>
<li><code>TicketProductionDST = 2</code></li>
</ul>
</li>
<li>for generating randomness for running ElectionPoSt:
<ul>
<li><code>ElectionPoStChallengeSeedDST = 3</code></li>
</ul>
</li>
<li>for generating randomness for running SurprisePoSt:
<ul>
<li><code>SurprisePoStChallengeSeedDST = 4</code></li>
</ul>
</li>
<li>for selection of which miners to surprise:
<ul>
<li><code>SurprisePoStSelectMinersDST = 5</code></li>
</ul>
</li>
<li>for selection of which sectors to sample:
<ul>
<li><code>SurprisePoStSampleSectors = 6</code></li>
</ul>
</li>
</ul>
<h5 id="forming-randomness-seeds">Forming Randomness Seeds</h5>
<p>Different uses of randomness require randomness seeds predicated on a variety of inputs. For instance, we have:</p>
<ul>
<li><code>TicketDrawing</code> &ndash; uses ticket and epoch number</li>
<li><code>TicketProduction</code> &ndash; uses ticket and miner actor addr</li>
<li><code>PoStChallengeSeed</code> &ndash; uses ticket and miner actor addr</li>
<li><code>SurprisePoStSelectMiners</code> &ndash; uses ticket and epoch number
&hellip;</li>
</ul>
<p>In all cases, a ticket is used as the base of randomness (see <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Tickets</a>). In order to make randomness seed creation uniform, the protocol derives all such seeds in the same way, as follows (also see <a href="./#systems__filecoin_blockchain__storage_power_consensus__tickets">Tickets</a>):</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text"> For a given ticket&#39;s randomness ticket_randomness:

buffer = Bytes{}
buffer.append(IntToBigEndianBytes(AppropriateDST))
buffer.append(-1) // a flag to be used in cases where FIL might need longer randomness outputs. Currently unused
buffer.append(ticket_randomness)
buffer.append(other needed serialized inputs)

randomness = SHA256(buffer)
</code></pre></div><p>

















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">crypto</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;bytes&#34;</span>
	<span class="s">&#34;encoding/binary&#34;</span>
	<span class="s">&#34;math&#34;</span>

	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">autil</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/util&#34;</span>
<span class="p">)</span>

<span class="c1">// Specifies a domain for randomness generation.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">DomainSeparationTag</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">DomainSeparationTag_TicketDrawing</span> <span class="nx">DomainSeparationTag</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="kc">iota</span>
	<span class="nx">DomainSeparationTag_TicketProduction</span>
	<span class="nx">DomainSeparationTag_ElectionPoStChallengeSeed</span>
	<span class="nx">DomainSeparationTag_SurprisePoStChallengeSeed</span>
	<span class="nx">DomainSeparationTag_SurprisePoStSelectMiners</span>
	<span class="nx">DomainSeparationTag_SurprisePoStSampleSectors</span>
<span class="p">)</span>

<span class="c1">// Derive a random byte string from a domain separation tag and the appropriate values
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">DeriveRandWithMinerAddr</span><span class="p">(</span><span class="nx">tag</span> <span class="nx">DomainSeparationTag</span><span class="p">,</span> <span class="nx">tix</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span><span class="p">,</span> <span class="nx">minerAddr</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Address</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Randomness</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">addrBuf</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">Buffer</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">minerAddr</span><span class="p">.</span><span class="nf">MarshalCBOR</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">addrBuf</span><span class="p">)</span>
	<span class="nx">autil</span><span class="p">.</span><span class="nf">AssertNoError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>

	<span class="k">return</span> <span class="nf">_deriveRandInternal</span><span class="p">(</span><span class="nx">tag</span><span class="p">,</span> <span class="nx">tix</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">addrBuf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">DeriveRandWithEpoch</span><span class="p">(</span><span class="nx">tag</span> <span class="nx">DomainSeparationTag</span><span class="p">,</span> <span class="nx">tix</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span><span class="p">,</span> <span class="nx">epoch</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Randomness</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nf">_deriveRandInternal</span><span class="p">(</span><span class="nx">tag</span><span class="p">,</span> <span class="nx">tix</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nf">BigEndianBytesFromInt</span><span class="p">(</span><span class="nx">epoch</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">_deriveRandInternal</span><span class="p">(</span><span class="nx">tag</span> <span class="nx">DomainSeparationTag</span><span class="p">,</span> <span class="nx">randSeed</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span><span class="p">,</span> <span class="nx">index</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Randomness</span> <span class="p">{</span>
	<span class="nx">buffer</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
	<span class="nx">buffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nf">BigEndianBytesFromInt</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">tag</span><span class="p">))</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">buffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nf">BigEndianBytesFromInt</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nx">index</span><span class="p">))</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">buffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(</span><span class="nx">randSeed</span><span class="p">)</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">buffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">buffer</span><span class="p">,</span> <span class="nx">s</span><span class="o">...</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">abi</span><span class="p">.</span><span class="nf">Randomness</span><span class="p">(</span><span class="nf">SHA256</span><span class="p">(</span><span class="nx">buffer</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">RandomInt</span><span class="p">(</span><span class="nx">randomness</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Randomness</span><span class="p">,</span> <span class="nx">nonce</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">limit</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">nonceBytes</span> <span class="o">:=</span> <span class="nf">BigEndianBytesFromInt</span><span class="p">(</span><span class="nx">nonce</span><span class="p">)</span>
	<span class="nx">input</span> <span class="o">:=</span> <span class="nx">randomness</span>
	<span class="nx">input</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="nx">nonceBytes</span><span class="o">...</span><span class="p">)</span>
	<span class="nx">ranHash</span> <span class="o">:=</span> <span class="nf">SHA256</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">(</span><span class="nx">input</span><span class="p">[:]))</span>
	<span class="nx">hashInt</span> <span class="o">:=</span> <span class="nf">IntFromBigEndianBytes</span><span class="p">(</span><span class="nx">ranHash</span><span class="p">)</span>
	<span class="nx">num</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Mod</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">hashInt</span><span class="p">),</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">limit</span><span class="p">)))</span>
	<span class="k">return</span> <span class="nx">num</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">BigEndianBytesFromInt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nx">buf</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nf">NewBuffer</span><span class="p">(</span><span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
	<span class="nx">err</span> <span class="o">:=</span> <span class="nx">binary</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">buf</span><span class="p">,</span> <span class="nx">binary</span><span class="p">.</span><span class="nx">BigEndian</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span>
	<span class="nx">autil</span><span class="p">.</span><span class="nf">AssertNoError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">buf</span><span class="p">.</span><span class="nf">Bytes</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">SHA256</span><span class="p">(</span><span class="nx">abi</span><span class="p">.</span><span class="nx">Bytes</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">Bytes</span> <span class="p">{</span>
	<span class="nx">autil</span><span class="p">.</span><span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">IntFromBigEndianBytes</span><span class="p">(</span><span class="nx">bytes</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">autil</span><span class="p">.</span><span class="nf">IMPL_FINISH</span><span class="p">()</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">}</span>
</code></pre></div>























<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">chain</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">abi</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/abi&#34;</span>
	<span class="nx">builtin</span> <span class="s">&#34;github.com/filecoin-project/specs-actors/actors/builtin&#34;</span>
	<span class="nx">node_base</span> <span class="s">&#34;github.com/filecoin-project/specs/systems/filecoin_nodes/node_base&#34;</span>
<span class="p">)</span>

<span class="c1">// Returns the tipset at or immediately prior to `epoch`.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">Tipset</span> <span class="p">{</span>
	<span class="nx">current</span> <span class="o">:=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">HeadTipset</span><span class="p">()</span>
	<span class="k">for</span> <span class="nx">current</span><span class="p">.</span><span class="nf">Epoch</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">epoch</span> <span class="p">{</span>
		<span class="nx">current</span> <span class="p">=</span> <span class="nx">current</span><span class="p">.</span><span class="nf">Parents</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">current</span>
<span class="p">}</span>

<span class="c1">// Draws randomness from the tipset at or immediately prior to `epoch`.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="nx">ts</span> <span class="o">:=</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">TipsetAtEpoch</span><span class="p">(</span><span class="nx">epoch</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ts</span><span class="p">.</span><span class="nf">MinTicket</span><span class="p">().</span><span class="nf">DrawRandomness</span><span class="p">(</span><span class="nx">epoch</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">GetTicketProductionRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="o">-</span> <span class="nx">node_base</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_TICKET</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">GetSealRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="o">-</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_SEAL</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">chain</span> <span class="o">*</span><span class="nx">Chain_I</span><span class="p">)</span> <span class="nf">GetPoStChallengeRandSeed</span><span class="p">(</span><span class="nx">epoch</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">ChainEpoch</span><span class="p">)</span> <span class="nx">abi</span><span class="p">.</span><span class="nx">RandomnessSeed</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">chain</span><span class="p">.</span><span class="nf">RandomnessAtEpoch</span><span class="p">(</span><span class="nx">epoch</span> <span class="o">-</span> <span class="nx">builtin</span><span class="p">.</span><span class="nx">SPC_LOOKBACK_POST</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>




</p>


</div>



</div>

  


</div>

  

  
    








<div id="algorithms__cryptoecon">

<h2 class="section-header">
  Cryptoecon &ndash; Placeholders
</h2>

<div class="section-content">




































<p>The Filecoin network is a complex multi-agent economic system. This section aims to explain some mechanisms and parameters in the system that can help achieve network-level goals. For now, just lists some key mechanisms and parameters that are still subject to changes during testnet but that must be resolved before mainnet launch. Note that this is a list of economic levers that are in consideration and not all of them will be used in mainnet. Some may be added or changed after mainnet launch, through the FIP process, requiring a <strong>network upgrade</strong>.</p>
<ol>
<li><strong>Block reward minting function</strong> - parameters may change over time, including the exponent of the block reward decay function.</li>
<li><strong>Block reward vesting function</strong> - block reward earned from mining may be required to vest over some period of time.</li>
<li><strong>Pledge collateral function and slashing</strong> - pledge collateral needs to satisfy certain security constraints for consensus and hence needs to be re-evaluated.</li>
<li><strong>Deal collateral requirement</strong> - minimum deal collaterals may be adjusted to achieve appropriate incentive structure.
5.<strong>Interactive PoRep slashing</strong> - some penalties may be introduced for failing <code>ProveCommit</code> in interactive <code>PoRep</code>.</li>
<li><strong>Network transaction fee</strong> - burned as a network fee during proof or txn submission.</li>
<li><strong>Reward for pledged but unused storage</strong> - explicit reward for available but unused storage.</li>
<li><strong>Minimum miner size</strong> - the minimum size of sectors a storage miner must have to produce blocks. There are several security and scalability parameters that depend on this.</li>
</ol>
<p>(This list is incomplete, you can help by expanding it.)</p>


</div>



</div>

  


</div>

  

  
    








<div id="listings">

<h1 class="section-header">
  Listings
</h1>

<div class="section-content">






































</div>


  
    








<div id="listings__actors">

<h2 class="section-header">
  Filecoin VM Actors
</h2>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="listings__reserved_ranges">

<h2 class="section-header">
  Reserved Ranges
</h2>

<div class="section-content">




































<h3 id="actor-id-reserved-ranges">Actor ID Reserved Ranges</h3>
<table>
<thead>
<tr>
<th>Actor</th>
<th>ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>SystemActor</td>
<td>0</td>
</tr>
<tr>
<td>InitActor</td>
<td>1</td>
</tr>
<tr>
<td>RewardActor</td>
<td>2</td>
</tr>
<tr>
<td>CronActor</td>
<td>3</td>
</tr>
<tr>
<td>StoragePowerActor</td>
<td>4</td>
</tr>
<tr>
<td>StorageMarketActor</td>
<td>5</td>
</tr>
<tr>
<td>BurntFundsActor</td>
<td>99</td>
</tr>
</tbody>
</table>
<p>All values below 100 are reserved for singleton actors. The first non-singleton actor starts at 100.</p>
<h3 id="method-reserved-ranges">Method Reserved Ranges</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>value send</td>
<td>0</td>
</tr>
<tr>
<td>constructor</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>All other positive values are free for actors to use. For the canonical list, see TODO LINK TO ACTOR CODE WHEN DONE.</p>
<h3 id="error-codes">Error Codes</h3>
<p>TODO</p>


</div>



</div>

  

  
    








<div id="listings__data_structures">

<h2 class="section-header">
  Data Structures
</h2>

<div class="section-content">




































<h3 id="rle-bitset-encoding">RLE+ Bitset Encoding</h3>
<p>RLE+ is a lossless compression format based on <a href="https://en.wikipedia.org/wiki/Run-length_encoding">RLE</a>.
Its primary goal is to reduce the size in the case of many individual bits, where RLE breaks down quickly,
while keeping the same level of compression for large sets of contiugous bits.</p>
<p>In tests it has shown to be more compact than RLE itself, as well as <a href="https://arxiv.org/pdf/1004.0403.pdf">Concise</a> and <a href="https://roaringbitmap.org/">Roaring</a>.</p>
<h4 id="format">Format</h4>
<p>The format consists of a header, followed by a series of blocks, of which there are three different types.</p>
<p>The format can be expressed as the following <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a> grammar.</p>
<pre><code>    &lt;encoding&gt; ::= &lt;header&gt; &lt;blocks&gt;
      &lt;header&gt; ::= &lt;version&gt; &lt;bit&gt;
     &lt;version&gt; ::= &quot;00&quot;
      &lt;blocks&gt; ::= &lt;block&gt; &lt;blocks&gt; | &quot;&quot;
       &lt;block&gt; ::= &lt;block_single&gt; | &lt;block_short&gt; | &lt;block_long&gt;
&lt;block_single&gt; ::= &quot;1&quot;
 &lt;block_short&gt; ::= &quot;01&quot; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt; &lt;bit&gt;
  &lt;block_long&gt; ::= &quot;00&quot; &lt;unsigned_varint&gt;
         &lt;bit&gt; ::= &quot;0&quot; | &quot;1&quot;
</code></pre><p>An <code>&lt;unsigned_varint&gt;</code> is defined as specified <a href="https://github.com/multiformats/unsigned-varint">here</a>.</p>
<h5 id="blocks">Blocks</h5>
<p>The blocks represent how many bits, of the current bit type there are. As <code>0</code> and <code>1</code> alternate in a bit vector
the inital bit, which is stored in the header, is enough to determine if a length is currently referencing
a set of <code>0</code>s, or <code>1</code>s.</p>
<h6 id="block-single">Block Single</h6>
<p>If the running length of the current bit is only <code>1</code>, it is encoded as a single set bit.</p>
<h6 id="block-short">Block Short</h6>
<p>If the running length is less than <code>16</code>, it can be encoded into up to four bits, which a short block
represents. The length is encoded into a 4 bits, and prefixed with <code>01</code>, to indicate a short block.</p>
<h6 id="block-long">Block Long</h6>
<p>If the running length is <code>16</code> or larger, it is encoded into a varint, and then prefixed with <code>00</code> to indicate
a long block.</p>
<blockquote>
<p><strong>Note:</strong> The encoding is unique, so no matter which algorithm for encoding is used, it should produce
the same encoding, given the same input.</p>
</blockquote>
<h6 id="bit-numbering">Bit Numbering</h6>
<p>For Filecoin, byte arrays representing RLE+ bitstreams are encoded using <a href="https://en.wikipedia.org/wiki/Bit_numbering#LSB_0_bit_numbering">LSB 0</a> bit numbering.</p>
<h3 id="hamt">HAMT</h3>
<p>See the draft <a href="https://github.com/ipld/specs/blob/master/data-structures/hashmap.md">IPLD hash map spec</a> for details on implementing the HAMT used for the global state tree map and throughout the actor code.</p>
<h3 id="other-considerations">Other Considerations</h3>
<ul>
<li>The maximum size of an Object should be 1MB (2^20 bytes). Objects larger than this are invalid.</li>
</ul>


</div>



</div>

  

  
    








<div id="listings__system_map">

<h2 class="section-header">
  Components
</h2>

<div class="section-content">




































<p>TODO</p>


</div>



</div>

  

  
    








<div id="listings__libp2p_protocols">

<h2 class="section-header">
  libp2p Protocols
</h2>

<div class="section-content">






































</div>


  
    








<div id="listings__libp2p_protocols__data_transfer_protocol">

<h3 class="section-header">
  Data Transfer Protocol
</h3>

<div class="section-content">




































<ul>
<li><strong>Name</strong>: Data Transfer Protocol</li>
<li><strong>Protocol ID</strong>: <code>/fil/data-transfer/0.0.1</code></li>
</ul>
<p>Message Protobuf</p>
<pre><code>
message DataTransferMessage {
  message Request {
    int32 transferID = 1
    bool isPull = 2
    bytes voucher = 3
    bytes pieceID = 4
    bytes selector = 5
    bool isPartial = 6
    bool isCancel = 7
  }

  message Response {
    int32 transferID = 1
    boolean accepted = 2
  }

  bool isResponse = 1
  Request request = 2
  Response response = 3
}

</code></pre>

</div>



</div>

  


</div>

  


</div>

  

  
    








<div id="glossary">

<h1 class="section-header">
  Glossary
</h1>

<div class="section-content">




































<h2 id="updates-to-definitions">Updates to definitions</h2>
<p>To make any updates to these definitions please submit a pull request with the changes, or open an issue and one of the maintainers will do it for you.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>Want to split all repair stuff to separate doc</li>
<li>Let&rsquo;s refer to Filecoin system rather than network. In a sense, the network is an instantiation of the system (this protocol). We can however refer to the Filecoin VM separately which means the system by which we apply changes to the state of the system at a point in time.</li>
<li>Asterisks indicate that the definition requires updating by any affected party.</li>
</ul>
<h2 id="definitions">Definitions</h2>
<h3 id="actor">Actor</h3>
<p>An actor is an on-chain object with its own state and set of methods. An actors state is persisted on-chain in the state tree, keyed by its address. All actors (miner actors, the storage market actor, account actors) have an address. Actors methods are invoked by crafting messages and getting miners to include them in blocks.</p>
<p>Actors are very similar to smart contracts in Ethereum.</p>
<h3 id="address">Address</h3>
<p>An address is an identifier that refers to an actor in the Filecoin state.</p>
<h3 id="ask">Ask</h3>
<p>An ask contains the terms on which a miner is willing to provide services. Storage asks, for example, contain price and other terms under which a given miner is willing to sell its storage. The word comes from stock market usage of ask, shortened from asking price.</p>
<h3 id="block">Block</h3>
<p>A block in the Filecoin blockchain is a chunk of data appended to the shared history of the network including transactions, messages, etc. and representing the state of the storage network at a given point in time.</p>
<p>See <a href="">Data Structures</a></p>
<h3 id="bootstrapping">Bootstrapping</h3>
<h3 id="chain-weight">Chain weight</h3>
<h3 id="challenge-sampling">Challenge sampling</h3>
<h3 id="challenge-ticket">Challenge Ticket</h3>
<p>Derived from a <code>Partial Ticket</code> as part of ElectionPoSt and used to run leader election.</p>
<h3 id="cid">Cid</h3>
<p>CID is short for Content Identifier, a self describing content address used throughout the ipfs ecosystem. For more detailed information, see <a href="https://github.com/ipld/cid">the github documentation for it</a>.</p>
<h3 id="client">Client</h3>
<p>A client is any user with an account who wishes to store data with a miner. A client&rsquo;s account is used to pay for the storage, and helps to prove the clients ability to pay.</p>
<h3 id="collateral">Collateral</h3>
<p>Collateral is Filecoin tokens pledged by an actor as a commitment to a promise. If the promise is respected, the collateral is returned. If the promise is broken, the collateral is not returned in full. For instance:</p>
<ul>
<li>In becoming a Filecoin storage miner: the miner will put up collateral alongside their SEAL to</li>
<li>In a Filecoin deal: both the miner and client put up collateral to ensure their respect of deal terms.</li>
</ul>
<h3 id="commitment">Commitment</h3>
<p>See <a href="proofs.md">Filecoin Proofs</a></p>
<h3 id="confirmation">Confirmation</h3>
<h3 id="consensus">Consensus</h3>
<h3 id="deal">Deal</h3>
<p>*** *A deal in a Filecoin market is made when a bid and ask are matched, corresponding to an agreement on a service and price between a miner and client.</p>
<h3 id="erasure-coding">Erasure coding</h3>
<p>Erasure coding is a strategy through which messages can be lengthened so as to be made recoverable in spite of errors.</p>
<p>See <a href="https://en.wikipedia.org/wiki/Erasure_code">Wikipedia</a></p>
<h3 id="fault">Fault</h3>
<p>A fault occurs when a proof is not posted in the Filecoin system within the proving period, denoting another malfunction such as loss of network connectivity, storage malfunction, malicious miner, etc.</p>
<h3 id="fair">Fair</h3>
<h3 id="file">File</h3>
<p>Files are what clients bring to the filecoin system to store. A file is split up into <code>pieces</code>, which are what is actually stored by the network.</p>
<h3 id="finality">Finality</h3>
<h3 id="piece-inclusion-proof">Piece Inclusion Proof</h3>
<p>See <a href="proofs.md">Filecoin Proofs</a></p>
<h3 id="gas-fees-prices">Gas, Fees, Prices</h3>
<h3 id="generation-attack-threshold">Generation Attack Threshold</h3>
<p>Security parameter. Number of rounds within which a new Proof-of-Storage must be submitted in order for a miner to retain power in the network (and avoid getting slashed). This number must be be smaller than the minimum time it takes for an adversarial miner to generate a replica of the data (thereby not storing it undetectably for some period of time).</p>
<p>The Generation Attack Threshold is equal to the Polling Time + some Grace Period after which miners get slashed.</p>
<h3 id="ghost">GHOST</h3>
<p><a href="https://eprint.iacr.org/2013/881.pdf">GHOST</a> is an acronym for <code>Greedy Heaviest Observable SubTree</code>, a class of blockchain structures in which multiple blocks can validly be included in the chain at any given height or round. GHOSTy protocols produce blockDAGs rather than blockchains and use a weighting function for fork selection, rather than simply picking the longest chain.</p>
<h3 id="height">Height</h3>
<p><code>Height</code> and <code>epoch</code> are synonymous and used interchangeably in this spec.</p>
<h3 id="leader">Leader</h3>
<p>A leader, in the context of Filecoin consensus, is a node that is chosen to propose the next block in the blockchain.</p>
<h3 id="leader-election">Leader election</h3>
<p>Leader election is the process by which the Filecoin network agrees who gets to create the next block.</p>
<h3 id="message">Message</h3>
<p>A message is a call to an actor in the Filecoin VM.</p>
<h3 id="miner">Miner</h3>
<p>A miner is an actor in the Filecoin system performing a service in the network for a reward.</p>
<p>There are multiple types of miners in Filecoin:</p>
<ul>
<li>Storage miners - storage miners</li>
<li>Retrieval miners:</li>
<li>Repair miners (to be split out):</li>
</ul>
<h3 id="node">Node</h3>
<p>*** *A node is a communication endpoint that implements the Filecoin protocol. (also mention IPLD Node?)</p>
<h3 id="on-chainoff-chain">On-chain/off-chain</h3>
<h3 id="onlineoffline">Online/offline</h3>
<h3 id="partial-ticket">Partial Ticket</h3>
<p>Ticket produced as part of the ElectionPoSt process used to both prove leader elections and prove storage of a given data replica through PoSt. At least one is included in every block header.</p>
<h3 id="payment-channel">Payment Channel</h3>
<p>A payment channel is set up between actors in the Filecoin system to enable off-chain payments with on-chain guarantees, making settlement more efficient.</p>
<h3 id="piece">Piece</h3>
<p>A piece is a portion of a file that gets fitted into a sector.</p>
<h3 id="pledge">Pledge</h3>
<p>****The initial commitment of a storage miner to provide a number of sectors to the system.</p>
<h3 id="polling-time">Polling Time</h3>
<p>Security Parameter. Polling time is the time between two online PoReps in a PoSt proof.</p>
<h3 id="power">Power</h3>
<p>See <code>Power Fraction</code>.</p>
<h3 id="power-fraction">Power Fraction</h3>
<p>A miner&rsquo;s <code>Power Fraction</code> or <code>Power</code> is the ratio of their committed storage as of their last PoSt submission over Filecoin&rsquo;s total committed storage as of the current block. It is used in leader election.</p>
<h3 id="power-table">Power table</h3>
<p>The <a href="./#systems__filecoin_blockchain__storage_power_consensus__storage_power_actor__power_table">Power Table</a> is an abstraction provided by the Filecoin storage market that lists the <code>power</code> of every miner in the system.</p>
<h3 id="protocol">Protocol</h3>
<h3 id="proving-period">Proving Period</h3>
<p>The period of time during which storage miners must compute Proofs of Spacetime. At the end of the period they must submit their PoSt. Put another way, it is the duration of a PoSt.</p>
<h3 id="proving-set">Proving Set</h3>
<p>The elements used as input by a proof of Spacetime to enable a proof to be generated.</p>
<p>**** elements necessary to generate a SEAL, or elements necessary to generate a proof</p>
<h3 id="proof-of-replication">Proof of Replication</h3>
<p>Proof that a unique encoding of data exists in physical storage.</p>
<p>Used in the Filecoin system to generate SEALed sectors through which storage miners prove they hold client data.</p>
<h3 id="proof-of-spacetime">Proof of Spacetime</h3>
<p>Proof that a given encoding of data existed in physical storage continuously over a period of time.</p>
<p>Used in the Filecoin system by a storage miner to prove that client data was kept over the contract duration.</p>
<h3 id="randomness">Random(ness)</h3>
<p>****Source of unpredictability used in the Filecoin system to ensure fairness and prevent malicious actors from gaining an advantage over the system.</p>
<p>TODO add a note to distinguish predictability from randomness</p>
<h3 id="randomness-ticket">Randomness Ticket</h3>
<p>See Ticket.</p>
<h3 id="election-randomness-lookback">Election Randomness Lookback</h3>
<p>Security parameter. A number of rounds to sample back from when choosing randomness for use in leader election. A higher number turns a more localized lottery into a more global one since a miner wins or loses on all descendants of a given randomness, but enables miners to look-ahead and know whether they will be elected in the future.</p>
<p>Also referred to as <code>K</code> in consensus settings.</p>
<h3 id="repair">Repair</h3>
<p>Repair refers to the processes and protocols by which the Filecoin network ensures that data that is partially lost (by, for example, a miner disappearing) can be re-constructed and re-added to the network.</p>
<h3 id="round">Round</h3>
<p>See <code>Height</code> for definition. They are synonymous.</p>
<h3 id="sealunseal">SEAL/UNSEAL</h3>
<p>See <a href="proofs.md">Filecoin Proofs</a></p>
<h3 id="sector">Sector</h3>
<p>A sector is a contiguous array of bytes that a miner puts together, seals, and performs Proofs of Spacetime on.</p>
<h3 id="slashing">Slashing</h3>
<h3 id="smart-contracts">Smart contracts</h3>
<h3 id="storage">Storage</h3>
<p>Storage widely refers to a place in which to store data in a given system.</p>
<p>In the context of:</p>
<ul>
<li>The Filecoin miner: sotrage refers to disk sectors made available to the network.</li>
<li>The Filecoin chain: storage refers to the way in which system state is tracked through time on-chain through blocks.</li>
<li>Actor: the struct that defines an actor.</li>
</ul>
<h3 id="state">State</h3>
<p>****Refers to The shared history of the Filecoin system contains actors and their storage, deals, etc. State is deterministically generated from the initial state and the set of messages generated by the system.</p>
<h3 id="ticket">Ticket</h3>
<p>A <code>ticket</code> is used as a source of randomness in EC leader election. Every block depends on one or more <code>ChallengeTicket</code> derived from a <code>PartialTicket</code> using input from a <code>RandomnessTicket</code> (naming PR welcome). One such new <code>RandomnessTicket</code> or <code>Ticket</code> is produced with every new block and included in its header</p>
<h3 id="ticket-chain">Ticket Chain</h3>
<p>Each chain in Filecoin can be associated to a given <code>ticket chain</code>. The <code>ticket chain</code> is assembled by taking the tickets (usually one) contained by the block with the smallest final ticket in each of the chain&rsquo;s <code>TipSet</code>s.</p>
<p>Ticket comparison is done by interpreting the tickets&rsquo; Bytes as unsigned integers (little endian representation).</p>
<h3 id="tipset">TipSet</h3>
<p>A <code>TipSet</code> is a set of blocks that have the same parent set and same number of <code>tickets</code>, which implies they will have been mined at the same <code>height</code>. A <code>TipSet</code> can contain multiple blocks if more than one miner successfully mines a block at the same <code>height</code> as another miner.</p>
<h3 id="verifiable">Verifiable</h3>
<p>Something that is verifiable can be checked for correctness by a third party.</p>
<h3 id="vdf">VDF</h3>
<p>A verifiable function that guarantees a time delay given some hardware assumptions and a small set of requirements. These requirements are efficient proof verification, random output, and strong sequentiality. Verifiable delay functions are formally defined by [[BBBF]](<a href="https://eprint.iacr.org/2018/601)">https://eprint.iacr.org/2018/601)</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">{proof, value} &lt;‚Äî- VDF(public parameters, seed)
</code></pre></div><h3 id="vm">VM</h3>
<p>Virtual Machine. The Filecoin VM refers to the system by which changes are applied to the Filecoin system&rsquo;s state. The VM takes messages as input, and outputs state.</p>
<h3 id="voucher">Voucher</h3>
<p>Held by an actor as part of a payment channel to complete settlement when the counterparty defaults.</p>
<h3 id="vrf">VRF</h3>
<p>A verifiable random function that receives {Secret Key (SK), seed} and outputs {proof of correctness, output value}. VRFs must yield a proof of correctness and a unique &amp; efficiently verifiable output.</p>
<div class="highlight"><pre class="chroma"><code class="language-text" data-lang="text">{proof, value} &lt;-- VRF(SK, seed)
</code></pre></div><h3 id="weight">Weight</h3>
<p>Every mined block has a computed <code>weight</code>. Together, the <code>weights</code> of all the blocks in a branch of the chain determines the cumulative <code>weight</code> of that branch. Filecoin&rsquo;s Expected Consensus is a GHOSTy or heaviest-chain protocol, where chain selection is done on the basis of an explicit weighting function. Filecoin‚Äôs <code>weight</code> function currently seeks to incentivize collaboration amongst miners as well as the addition of storage to the network. The specific weighting function is defined in <a href="expected-consensus.md#chain-weighting">Chain Weighting</a>.</p>
<h3 id="zksnark">zkSNARK</h3>
<p>Zero Knowledge Succinct ARguments of Knowledge. A way of producing a small &lsquo;proof&rsquo; that convinces a &lsquo;verifier&rsquo; that some computation was done correctly.</p>


</div>



</div>

  

  
    








<div id="appendix">

<h1 class="section-header">
  Appendix
</h1>

<div class="section-content">






































</div>


  
    








<div id="appendix__sharray">

<h2 class="section-header">
  Sharded IPLD Array
</h2>

<div class="section-content">




































<p>The Sharray is an IPLD tree structure used to store an array of items. It is designed for usecases that know all items at the time of creation and do not need insertion or deletion.</p>
<h3 id="ipld-representation">IPLD Representation</h3>
<p>Each sharray node is represented by an IPLD node of the following schema:</p>
<pre><code>type Node struct {
  height Int
  items [Item]
} representation tuple
</code></pre><p><code>Item</code> may be either a direct value, if <code>height == 0</code>, or the Cid of a child node if <code>height &gt; 0</code>.</p>
<p>(For details on IPLD Schemas, see the <a href="https://github.com/ipld/specs/blob/dcbfb25468092be796bab90e90e3f2535fdeddc7/schema/representations.md">IPLD Schema Spec (draft)</a>)</p>
<p>We use DAG-CBOR for serialization, and blake2b-256 for hashing.</p>
<h3 id="construction">Construction</h3>
<p>The tree must not be sparse.
Given an array of size <code>N</code> and a fixed width of <code>W</code>:</p>
<ul>
<li>The left <code>floor(N/W)</code> leaves contain the first <code>N</code> items.</li>
<li>If <code>N % W != 0</code> the final leaf contains the final remainder.</li>
<li>The tree is perfectly balanced.</li>
<li>The height is the distance from the leaves, not the root.</li>
<li>Leaves (nodes with a height of 0) contain array values.</li>
<li>Inner nodes (nodes with height greater than zero) contain the cids of their child nodes.</li>
</ul>
<h3 id="operations">Operations</h3>
<h4 id="createitems"><code>create(items)</code></h4>
<blockquote>
<p>Create a sharray from a given set of items</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">create</span><span class="p">(</span><span class="nx">items</span> <span class="p">[]</span><span class="nx">Item</span><span class="p">)</span> <span class="nx">Cid</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">layer</span> <span class="nx">cidQueue</span>

	<span class="nx">itemQ</span> <span class="o">:=</span> <span class="nf">queue</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">!</span><span class="nx">itemQ</span><span class="p">.</span><span class="nf">Empty</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// get the next &#39;Width&#39; items from the input items
</span><span class="c1"></span>		<span class="nx">vals</span> <span class="o">:=</span> <span class="nx">itemQ</span><span class="p">.</span><span class="nf">PopN</span><span class="p">(</span><span class="nx">width</span><span class="p">)</span>

		<span class="nx">nd</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span>
			<span class="nx">height</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="nx">items</span><span class="p">:</span>  <span class="nx">vals</span><span class="p">,</span>
		<span class="p">}</span>

		<span class="c1">// persist the node to the datastore
</span><span class="c1"></span>		<span class="nf">storeNode</span><span class="p">(</span><span class="nx">nd</span><span class="p">)</span>

		<span class="nx">layer</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">nd</span><span class="p">.</span><span class="nf">Cid</span><span class="p">())</span>
	<span class="p">}</span>

	<span class="kd">var</span> <span class="nx">nextLayer</span> <span class="nx">cidQueue</span>
	<span class="k">for</span> <span class="nx">height</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">height</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">Len</span><span class="p">()</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nx">vals</span> <span class="o">:=</span> <span class="nx">layer</span><span class="p">.</span><span class="nf">PopN</span><span class="p">(</span><span class="nx">width</span><span class="p">)</span>

			<span class="nx">nd</span> <span class="o">:=</span> <span class="nx">Node</span><span class="p">{</span>
				<span class="nx">height</span><span class="p">:</span> <span class="nx">height</span><span class="p">,</span>
				<span class="nx">items</span><span class="p">:</span>  <span class="nx">vals</span><span class="p">,</span>
			<span class="p">}</span>

			<span class="nf">storeNode</span><span class="p">(</span><span class="nx">nd</span><span class="p">)</span>

			<span class="nx">nextLayer</span><span class="p">.</span><span class="nb">append</span><span class="p">(</span><span class="nx">nd</span><span class="p">.</span><span class="nf">Cid</span><span class="p">())</span>
		<span class="p">}</span>
		<span class="nx">layer</span> <span class="p">=</span> <span class="nx">nextLayer</span>
		<span class="nx">nextLayer</span><span class="p">.</span><span class="nf">ClearItems</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">nextLayer</span><span class="p">.</span><span class="nf">First</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><h4 id="geti"><code>get(i)</code></h4>
<blockquote>
<p>Get the element at index <code>i</code></p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">n</span> <span class="nx">node</span><span class="p">)</span> <span class="nf">get</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Item</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Height</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Array</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="p">}</span>

	<span class="nx">childWidth</span> <span class="o">:=</span> <span class="nf">Pow</span><span class="p">(</span><span class="nx">Width</span><span class="p">,</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Height</span><span class="p">)</span>

	<span class="nx">child</span> <span class="o">:=</span> <span class="nf">loadNode</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Array</span><span class="p">[</span><span class="nx">i</span><span class="o">/</span><span class="nx">childWidth</span><span class="p">])</span>
	<span class="k">return</span> <span class="nx">child</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="nx">childWidth</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

</div>



</div>

  

  
    








<div id="appendix__address">

<h2 class="section-header">
  Address
</h2>

<div class="section-content">




































<p>A Filecoin address is an identifier that refers to an actor in the Filecoin state. All actors (miner actors, the storage market actor, account actors) have an address. This address encodes information about the network to which an actor belongs, the specific type of address encoding, the address payload itself, and a checksum. The goal of this format is to provide a robust address format that is both easy to use and resistant to errors.</p>
<p>Note that each <code>ActorAddress</code> in the protocol contains a unique <code>ActorID</code> given to it by the <code>InitActor</code>. Throughout the protocol, actors are referenced by their ID-addresses. ID-addresses are computable from IDs (using <code>makeIdAddress(id)</code>), and vice versa (using the <code>AddressMap</code> to go from addr to ID).</p>
<p>Most actors have an alternative address which is not their key in the state tree, but is resolved to their ID-address during message processing.</p>
<p>Accounts have a public key-based address (e.g. to receive funds), and non-singleton actors have a temporary reorg-proof address.</p>
<p>An account actor&rsquo;s crypto-address (for signature verification) is found by looking up its actor state, keyed by the canonical ID-address. There is no map from ID-address to pubkey address.</p>
<p>The reference implementation is <a href="https://github.com/filecoin-project/go-address">https://github.com/filecoin-project/go-address</a></p>
<h3 id="design-criteria">Design criteria</h3>
<ol>
<li><strong>Identifiable</strong>: The address must be easily identifiable as a Filecoin address.</li>
<li><strong>Reliable</strong>: Addresses must provide a mechanism for error detection when they might be transmitted outside the network.</li>
<li><strong>Upgradable</strong>: Addresses must be versioned to permit the introduction of new address formats.</li>
<li><strong>Compact</strong>: Given the above constraints, addresses must be as short as possible.</li>
</ol>
<h3 id="specification">Specification</h3>
<p>There are 2 ways a filecoin address can be represented. An address appearing on chain will always be formatted as raw bytes. An address may also be encoded to a string, this encoding includes a checksum and network prefix. An address encoded as a string will never appear on chain, this format is used for sharing among humans.</p>
<h4 id="bytes">Bytes</h4>
<p>When represented as bytes a filecoin address contains the following:</p>
<ul>
<li>A <strong>protocol indicator</strong> byte that identifies the type and version of this address.</li>
<li>The <strong>payload</strong> used to uniquely identify the actor according to the protocol.</li>
</ul>
<pre><code>|----------|---------|
| protocol | payload |
|----------|---------|
|  1 byte  | n bytes |
</code></pre><h4 id="string">String</h4>
<p>When encoded to a string a filecoin address contains the following:</p>
<ul>
<li>A <strong>network prefix</strong> character that identifies the network the address belongs to.</li>
<li>A <strong>protocol indicator</strong> byte that identifies the type and version of this address.</li>
<li>A <strong>payload</strong> used to uniquely identify the actor according to the protocol.</li>
<li>A <strong>checksum</strong> used to validate the address.</li>
</ul>
<pre><code>|------------|----------|---------|----------|
|  network   | protocol | payload | checksum |
|------------|----------|---------|----------|
| 'f' or 't' |  1 byte  | n bytes | 4 bytes  |
</code></pre><h4 id="network-prefix">Network Prefix</h4>
<p>The <strong>network prefix</strong> is prepended to an address when encoding to a string. The network prefix indicates which network an address belongs in. The network prefix may either be <code>f</code> for filecoin mainnet or <code>t</code> for filecoin testnet. It is worth noting that a network prefix will never appear on chain and is only used when encoding an address to a human readable format.</p>
<h4 id="protocol-indicator">Protocol Indicator</h4>
<p>The <strong>protocol indicator</strong> byte describes how a method should interpret the information in the payload field of an address. Any deviation for the algorithms and data types specified by the protocol must be assigned a new protocol number. In this way, protocols also act as versions.</p>
<ul>
<li><code>0 </code> : ID</li>
<li><code>1</code> : SECP256K1 Public Key</li>
<li><code>2</code> : Actor</li>
<li><code>3</code> : BLS Public Key</li>
</ul>
<p>An example description in golang:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Protocol byte
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Protocol</span> <span class="p">=</span> <span class="kt">byte</span>

<span class="kd">const</span> <span class="p">(</span>
	<span class="nx">ID</span> <span class="nx">Protocol</span> <span class="p">=</span> <span class="kc">iota</span>
	<span class="nx">SECP256K1</span>
	<span class="nx">Actor</span>
	<span class="nx">BLS</span>
<span class="p">)</span>
</code></pre></div><h5 id="protocol-0-ids">Protocol 0: IDs</h5>
<p><strong>Protocol 0</strong> addresses are simple IDs.  All actors have a numeric ID even if they don&rsquo;t have public keys. The payload of an ID address is base10 encoded. IDs are not hashed and do not have a checksum.</p>
<p><strong>Bytes</strong></p>
<pre><code>|----------|---------------|
| protocol |    payload    |
|----------|---------------|
|    0     | leb128-varint |
</code></pre><p><strong>String</strong></p>
<pre><code>|------------|----------|---------------|
|  network   | protocol |    payload    |
|------------|----------|---------------|
| 'f' or 't' |    '0'   | leb128-varint |
                  base10[...............]
</code></pre><h5 id="protocol-1-libsecpk1-elliptic-curve-public-keys">Protocol 1: libsecpk1 Elliptic Curve Public Keys</h5>
<p><strong>Protocol 1</strong> addresses represent secp256k1 public encryption keys. The payload field contains the <a href="https://blake2.net/">Blake2b 160</a> hash of the public key.</p>
<p><strong>Bytes</strong></p>
<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    1     | blake2b-160(PubKey) |
</code></pre><p><strong>String</strong></p>
<pre><code>|------------|----------|---------------------|----------|
|  network   | protocol |      payload        | checksum |
|------------|----------|---------------------|----------|
| 'f' or 't' |    '1'   | blake2b-160(PubKey) |  4 bytes |
                  base32[................................]
</code></pre><h5 id="protocol-2-actor">Protocol 2: Actor</h5>
<p><strong>Protocol 2</strong> addresses representing an Actor. The payload field contains the SHA256 hash of meaningful data produced as a result of creating the actor.</p>
<p><strong>Bytes</strong></p>
<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    2     | 	SHA256(Random) 	 |
</code></pre><p><strong>String</strong></p>
<pre><code>|------------|----------|-----------------------|----------|
|  network   | protocol |         payload       | checksum |
|------------|----------|-----------------------|----------|
| 'f' or 't' |    '2'   |  	SHA256(Random)  	|  4 bytes |
                  base32[..................................]
</code></pre><h5 id="protocol-3-bls">Protocol 3: BLS</h5>
<p><strong>Protocol 3</strong> addresses represent BLS public encryption keys. The payload field contains the BLS public key.</p>
<p><strong>Bytes</strong></p>
<pre><code>|----------|---------------------|
| protocol |        payload      |
|----------|---------------------|
|    3     | 48 byte BLS PubKey  |
</code></pre><p><strong>String</strong></p>
<pre><code>|------------|----------|---------------------|----------|
|  network   | protocol |      payload        | checksum |
|------------|----------|---------------------|----------|
| 'f' or 't' |    '3'   |  48 byte BLS PubKey |  4 bytes |
                  base32[................................]
</code></pre><h4 id="payload">Payload</h4>
<p>The payload represents the data specified by the protocol. All payloads except the payload of the ID protocol are <a href="https://tools.ietf.org/html/rfc4648#section-6">base32</a> encoded using the lowercase alphabet when seralized to their human readable format.</p>
<h4 id="checksum">Checksum</h4>
<p>Filecoin checksums are calculated over the address protocol and payload using blake2b-4. Checksums are base32 encoded and only added to an address when encoding to a string. Addresses following the ID Protocol do not have a checksum.</p>
<h4 id="expected-methods">Expected Methods</h4>
<p>All implementations in Filecoin must have methods for creating, encoding, and decoding addresses in addition to checksum creation and validation. The follwing is a golang version of the Address Interface:</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">protocol</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">payload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Address</span>

<span class="kd">type</span> <span class="nx">Address</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Encode</span><span class="p">(</span><span class="nx">network</span> <span class="nx">Network</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">Adress</span><span class="p">)</span> <span class="kt">string</span>
	<span class="nf">Decode</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Address</span>
	<span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span>
	<span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">bool</span>
<span class="p">}</span>
</code></pre></div><h5 id="new">New()</h5>
<p>New returns an Address for the specified protocol encapsulating corresponding payload. New fails for unknown protocols.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">protocol</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">payload</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="p">&lt;</span> <span class="nx">SECP256K1</span> <span class="o">||</span> <span class="nx">protocol</span> <span class="p">&gt;</span> <span class="nx">BLS</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrUnknownType</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
		<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
		<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">payload</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h5 id="encode">Encode()</h5>
<p>Software encoding a Filecoin address must:</p>
<ul>
<li>produce an address encoded to a known network</li>
<li>produce an address encoded to a known protocol</li>
<li>produce an address with a valid checksum (if applicable)</li>
</ul>
<p>Encodes an Address as a string, prepending the network prefix, calculating the checksum, and encoding the payload and checksum to <a href="https://tools.ietf.org/html/rfc4648">base32</a>.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Encode</span><span class="p">(</span><span class="nx">network</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">network</span> <span class="o">!=</span> <span class="s">&#34;f&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">network</span> <span class="o">!=</span> <span class="s">&#34;t&#34;</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;Invalid Network&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">SECP256K1</span><span class="p">,</span> <span class="nx">Actor</span><span class="p">,</span> <span class="nx">BLS</span><span class="p">:</span>
		<span class="nx">cksm</span> <span class="o">:=</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">network</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">)</span> <span class="o">+</span> <span class="nx">base32</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="o">+</span><span class="nx">cksm</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">ID</span><span class="p">:</span>
		<span class="k">return</span> <span class="nx">network</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span><span class="p">)</span> <span class="o">+</span> <span class="nx">base10</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">leb128</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="p">))</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="s">&#34;invalid address protocol&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h5 id="decode">Decode()</h5>
<p>Software decoding a Filecoin address must:</p>
<ul>
<li>verify the network is a known network.</li>
<li>verify the protocol is a number of a known protocol.</li>
<li>verify the checksum is valid</li>
</ul>
<p>Decode an Address from a string by removing the network prefix, validating the address is of a know protocol, decoding the payload and checksum, and validating the checksum.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Decode</span><span class="p">(</span><span class="nx">a</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">Address</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="p">&lt;</span> <span class="mi">3</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidLength</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#34;f&#34;</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#34;t&#34;</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrUnknownNetwork</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">protocol</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">raw</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">ID</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
			<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
			<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">leb128</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">base10</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">raw</span><span class="p">)),</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">raw</span> <span class="p">=</span> <span class="nx">base32</span><span class="p">.</span><span class="nf">Decode</span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span>
	<span class="nx">payload</span> <span class="p">=</span> <span class="nx">raw</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span><span class="o">-</span><span class="nx">CksmLen</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">SECP256K1</span> <span class="o">||</span> <span class="nx">protocol</span> <span class="o">==</span> <span class="nx">Actor</span> <span class="p">{</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">20</span> <span class="p">{</span>
			<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidBytes</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nx">cksm</span> <span class="o">:=</span> <span class="nx">payload</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">payload</span><span class="p">)</span><span class="o">-</span><span class="nx">CksmLen</span><span class="p">:]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">cksm</span><span class="p">)</span> <span class="p">{</span>
		<span class="nf">Fatal</span><span class="p">(</span><span class="nx">ErrInvalidChecksum</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">Address</span><span class="p">{</span>
		<span class="nx">Protocol</span><span class="p">:</span> <span class="nx">protocol</span><span class="p">,</span>
		<span class="nx">Payload</span><span class="p">:</span>  <span class="nx">payload</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h5 id="checksum-1">Checksum()</h5>
<p>Checksum produces a byte array by taking the blake2b-4 hash of an address protocol and payload.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go">
<span class="kd">func</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">a</span> <span class="nx">Address</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nf">blake2b4</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Protocol</span> <span class="o">+</span> <span class="nx">a</span><span class="p">.</span><span class="nx">Payload</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h5 id="validatechecksum">ValidateChecksum()</h5>
<p>ValidateChecksum returns true if the Checksum of data matches the expected checksum.</p>
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">ValidateChecksum</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">expected</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="nx">digest</span> <span class="o">:=</span> <span class="nf">Checksum</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">digest</span> <span class="o">==</span> <span class="nx">expected</span>
<span class="p">}</span>
</code></pre></div><h3 id="test-vectors">Test Vectors</h3>
<p>These are a set of test vectors that can be used to test an implementation of
this address spec. Test vectors are presented as newline-delimited address/hex
fields. The &lsquo;address&rsquo; field, when parsed, should produce raw bytes that match
the corresponding item in the &lsquo;hex&rsquo; field. For example:</p>
<pre><code>address1
hex1

address2
hex2
</code></pre><h4 id="id-type-addresses">ID Type Addresses</h4>
<pre><code>f00
0000

f0150
009601

f01024
008008

f01729
00c10d

f018446744073709551615
00ffffffffffffffffff01
</code></pre><h4 id="secp256k1-type-addresses">Secp256k1 Type Addresses</h4>
<pre><code>f17uoq6tp427uzv7fztkbsnn64iwotfrristwpryy
01fd1d0f4dfcd7e99afcb99a8326b7dc459d32c628

f1xcbgdhkgkwht3hrrnui3jdopeejsoatkzmoltqy
01b882619d46558f3d9e316d11b48dcf211327026a

f1xtwapqc6nh4si2hcwpr3656iotzmlwumogqbuaa
01bcec07c05e69f92468e2b3e3bf77c874f2c5da8c

f1wbxhu3ypkuo6eyp6hjx6davuelxaxrvwb2kuwva
01b06e7a6f0f551de261fe3a6fe182b422ee0bc6b6

f12fiakbhe2gwd5cnmrenekasyn6v5tnaxaqizq6a
01d1500504e4d1ac3e89ac891a4502586fabd9b417
</code></pre><h4 id="actor-type-addresses">Actor Type Addresses</h4>
<pre><code>f24vg6ut43yw2h2jqydgbg2xq7x6f4kub3bg6as6i
02e54dea4f9bc5b47d261819826d5e1fbf8bc5503b

f25nml2cfbljvn4goqtclhifepvfnicv6g7mfmmvq
02eb58bd08a15a6ade19d0989674148fa95a8157c6

f2nuqrg7vuysaue2pistjjnt3fadsdzvyuatqtfei
026d21137eb4c4814269e894d296cf6500e43cd714

f24dd4ox4c2vpf5vk5wkadgyyn6qtuvgcpxxon64a
02e0c7c75f82d55e5ed55db28033630df4274a984f

f2gfvuyh7v2sx3patm5k23wdzmhyhtmqctasbr23y
02316b4c1ff5d4afb7826ceab5bb0f2c3e0f364053
</code></pre><h4 id="bls-type-addresses">BLS Type Addresses</h4>
<p>To aid in readability, these addresses are line-wrapped. Address and hex pairs
are separated by <code>---</code>.</p>
<pre><code>f3vvmn62lofvhjd2ugzca6sof2j2ubwok6cj4xxbfzz
4yuxfkgobpihhd2thlanmsh3w2ptld2gqkn2jvlss4a
---
03ad58df696e2d4e91ea86c881e938ba4ea81b395e12
797b84b9cf314b9546705e839c7a99d606b247ddb4f9
ac7a3414dd

f3wmuu6crofhqmm3v4enos73okk2l366ck6yc4owxwb
dtkmpk42ohkqxfitcpa57pjdcftql4tojda2poeruwa
---
03b3294f0a2e29e0c66ebc235d2fedca5697bf784af
605c75af608e6a63d5cd38ea85ca8989e0efde9188b
382f9372460d

f3s2q2hzhkpiknjgmf4zq3ejab2rh62qbndueslmsdz
ervrhapxr7dftie4kpnpdiv2n6tvkr743ndhrsw6d3a
---
0396a1a3e4ea7a14d49985e661b22401d44fed402d1
d0925b243c923589c0fbc7e32cd04e29ed78d15d37d
3aaa3fe6da33

f3q22fijmmlckhl56rn5nkyamkph3mcfu5ed6dheq53
c244hfmnq2i7efdma3cj5voxenwiummf2ajlsbxc65a
---
0386b454258c589475f7d16f5aac018a79f6c1169d2
0fc33921dd8b5ce1cac6c348f90a3603624f6aeb91b
64518c2e8095

f3u5zgwa4ael3vuocgc5mfgygo4yuqocrntuuhcklf4
xzg5tcaqwbyfabxetwtj4tsam3pbhnwghyhijr5mixa
---
03a7726b038022f75a384617585360cee629070a2d9
d28712965e5f26ecc40858382803724ed34f2720336
f09db631f074
</code></pre>

</div>



</div>

  

  
    








<div id="appendix__network_params">

<h2 class="section-header">
  Filecoin Parameters
</h2>

<div class="section-content">




































<p>Some of these parameters are used around the code in the Filecoin subsystems and abi. Others are used as part of the proofs libraries.</p>
<p>Most are generated/finalized using the <a href="https://github.com/filecoin-project/orient">orient framework</a>. It is used to modelize the Filecoin network.</p>
<!-- raw HTML omitted -->
<h4 id="code-parameters">Code parameters</h4>



















<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">node_base</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="nx">addr</span> <span class="s">&#34;github.com/filecoin-project/go-address&#34;</span>
<span class="p">)</span>

<span class="c1">// Parameters for on-chain calculations are in actors/builtin/network_params.go
</span><span class="c1"></span>
<span class="c1">/////////////////////////////////////////////////////////////
</span><span class="c1">// Global
</span><span class="c1">/////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">const</span> <span class="nx">NETWORK</span> <span class="p">=</span> <span class="nx">addr</span><span class="p">.</span><span class="nx">Testnet</span>

<span class="c1">// how many sectors should be challenged in surprise post (if miner has fewer, will get dup challenges)
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">SURPRISE_CHALLENGE_COUNT</span> <span class="p">=</span> <span class="mi">200</span> <span class="c1">// placeholder
</span><span class="c1"></span>
<span class="kd">const</span> <span class="nx">EPOST_SAMPLE_RATE_NUM</span> <span class="p">=</span> <span class="mi">1</span>    <span class="c1">// placeholder
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">EPOST_SAMPLE_RATE_DENOM</span> <span class="p">=</span> <span class="mi">25</span> <span class="c1">// placeholder
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">SPOST_SAMPLE_RATE_NUM</span> <span class="p">=</span> <span class="mi">1</span>    <span class="c1">// placeholder
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">SPOST_SAMPLE_RATE_DENOM</span> <span class="p">=</span> <span class="mi">50</span> <span class="c1">// placeholder
</span><span class="c1"></span>
<span class="c1">/////////////////////////////////////////////////////////////
</span><span class="c1">// Consensus
</span><span class="c1">/////////////////////////////////////////////////////////////
</span><span class="c1"></span>
<span class="kd">const</span> <span class="nx">FINALITY</span> <span class="p">=</span> <span class="mi">500</span>          <span class="c1">// placeholder
</span><span class="c1"></span><span class="kd">const</span> <span class="nx">SPC_LOOKBACK_TICKET</span> <span class="p">=</span> <span class="mi">1</span> <span class="c1">// we chain blocks together one after the other
</span></code></pre></div>





<h4 id="orient-parameters">Orient parameters</h4>
<table>
<thead>
<tr>
<th>LAMBDA</th>
<th>SPACEGAP</th>
<th>BLOCK-SIZE-KIB</th>
<th>SECTOR-SIZE-GIB</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>0.03</td>
<td>2.6084006</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>2.9687543</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>4.60544</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>6.9628344</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>7.195217</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>12.142387</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>15.2998495</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>22.186821</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>42.125595</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>55.240646</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>107.03619</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.03</td>
<td>406.86823</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>2.3094485</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>2.37085</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>3.4674127</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>4.686779</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>4.9769444</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>7.705842</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>9.3208065</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>13.775977</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>25.303907</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>32.48009</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>62.670723</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.06</td>
<td>238.65137</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>2.1490319</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>2.1985393</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>3.0452213</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>3.8423958</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>4.1540065</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>6.059966</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>7.102623</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>10.6557865</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>19.063526</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>24.036263</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>46.211964</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.1</td>
<td>176.24756</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>1.9889219</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>2.1184843</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>2.7405148</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>3.2329829</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>3.5601068</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>4.8721666</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>5.501524</td>
<td>1024</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>8.404295</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>14.560543</td>
<td>32</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>17.942131</td>
<td>256</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>34.33397</td>
<td>128</td>
</tr>
<tr>
<td>10</td>
<td>0.2</td>
<td>131.21773</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>6.5753794</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>10.902712</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>19.707468</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>36.63338</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>37.16689</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>71.018715</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>94.63942</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>133.81236</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>265.37668</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>357.2812</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>695.79944</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.03</td>
<td>2639.3792</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>4.183762</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>6.1194773</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>10.603248</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>18.887196</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>18.958448</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>35.526344</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>46.80707</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>66.525635</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>130.80322</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>175.19678</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>340.8757</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.06</td>
<td>1293.6443</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>3.2964888</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>4.3449306</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>7.2257156</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>12.203384</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>12.303692</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>22.359337</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>29.061607</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>41.564106</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>80.880165</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>107.64613</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>209.20566</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.1</td>
<td>794.4138</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>2.6560488</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>3.0640512</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>4.7880635</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>7.32808</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>7.552495</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>12.856943</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>16.252815</td>
<td>1024</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>23.55217</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>44.856293</td>
<td>32</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>58.89311</td>
<td>256</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>114.18173</td>
<td>128</td>
</tr>
<tr>
<td>80</td>
<td>0.2</td>
<td>434.17523</td>
<td>32</td>
</tr>
</tbody>
</table>


</div>



</div>

  


</div>

  


</div>

</div>

</article>

      

      
    </div>

    
  

  <aside class="book-toc level-6 fixed">
    <nav id="TableOfContents"></nav>
  </aside>



  </main>

  
  
</body>

</html>
